<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>OnReconnect</name>
			<script>-- reconnect
-- Dieser Trigger löst einen Event aus, wenn der Char Statue war.
-- Also nicht neu eingeloggt wurde, sondern "reconnected".
raiseEvent("afterReconnectEvent")</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^Verwende alten Koerper...$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>AvaletTriggerFuerTimer</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
		</TriggerGroup>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Alkohol</name>
			<script>--[[Da der Alkohol-Zustand des Chars nicht per ATCP übertragen wird,
    versuche ich es mal auf die umständliche Weise: per Trigger.]]
    
--[[
Reihenfolge von stark zu schwach:
Du hast einen maechtigen Rausch.
Du bist betrunken.
Du hast einen Schwips.
Du bist angeheitert.
Du fuehlst eine leichte Klarheit im Kopf. (--&gt; nüchtern)
Du verspuerst ploetzlich furchtbare Kopfschmerzen.
Du bist wieder nuechtern.
]]
    
local str = matches[1]
if player.alk == nil then player.alk = "Du bist nuechtern." end

player.alk = "Du bist nuechtern."

if str == "Die Welt dreht sich um Dich." then
  player.alk = str
elseif str == "Du bist sternhagelvoll." then
  player.alk = str
elseif str == "Du hast einen maechtigen Rausch." then
  player.alk = str
elseif str == "Du bist betrunken." then
  player.alk = str
elseif str == "Du hast einen Schwips." then
  player.alk = str
elseif str == "Du bist angeheitert." then
  player.alk = str
elseif str == "Du bist wieder nuechtern." then
  player.alk = "Du bist wieder nuechtern."
elseif str == "Du fuehlst eine leichte Klarheit im Kopf." then
  player.alk = "Du bist nuechtern."
elseif str == "Deine Kopfschmerzen verschwinden." then
  player.alk = "Du bist nuechtern."
else
  --cecho("\nUnbehandelt im Avalet-Trigger Alkohol" .. matches[1].. "\n")
end

raiseEvent("RefreshHDA")
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#55007f</mFgColor>
			<mBgColor>#55ff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>Die Welt dreht sich um Dich.</string>
				<string>Du bist sternhagelvoll.</string>
				<string>Du hast einen maechtigen Rausch.</string>
				<string>Du bist betrunken.</string>
				<string>Du hast einen Schwips.</string>
				<string>Du bist angeheitert.</string>
				<string>Du bist wieder nuechtern.</string>
				<string>Du fuehlst eine leichte Klarheit im Kopf.</string>
				<string>Du verspuerst ploetzlich furchtbare Kopfschmerzen.</string>
				<string>Furchtbare Schmerzen jagen durch Deinen Kopf.</string>
				<string>Deine Kopfschmerzen verschwinden.</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>3</integer>
				<integer>3</integer>
				<integer>3</integer>
				<integer>3</integer>
				<integer>3</integer>
				<integer>3</integer>
				<integer>3</integer>
				<integer>3</integer>
				<integer>3</integer>
				<integer>3</integer>
				<integer>3</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Hangover</name>
			<script>--[[vielleicht wäre es hier gut, noch einen timer einzubauen, der die kopfschmerzanzeige irgendwann
zurücksetzt. Falls der trigger mal den schluss-string verpasst.]]

if matches[1] == "Du verspuerst ploetzlich furchtbare Kopfschmerzen." then
  player.hangover = true
elseif matches[1] == "Furchtbare Schmerzen jagen durch Deinen Kopf." then
  player.hangover = true
elseif matches[1] == "Deine Kopfschmerzen verschwinden." then
  player.hangover = false
end

raiseEvent("RefreshHDA")</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>Du verspuerst ploetzlich furchtbare Kopfschmerzen.</string>
				<string>Furchtbare Schmerzen jagen durch Deinen Kopf.</string>
				<string>Deine Kopfschmerzen verschwinden.</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>0</integer>
				<integer>0</integer>
				<integer>0</integer>
			</regexCodePropertyList>
		</Trigger>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Runenschmiede</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Schmiedehammer</name>
				<script>--echo("yo! "..multimatches[2])
--showMultimatches()


if multimatches[3][2] == "blau" then
  echo("blau")
  avalonUI.runiInfoBoxModel.HammerCharge = CHARGE_POSITIVE
elseif multimatches[3][2] == "rot" then
  echo("rot")
  avalonUI.runiInfoBoxModel.HammerCharge = CHARGE_NEGATIVE
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>3</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Mit diesem Schmiedehammer kannst Du Deine Schmiedekunst ausueben. Die</string>
					<string>Symbole darauf weisen Dich als (Runenmeister|Runenforscher|Grossmeister) in der Runenschmiede aus und</string>
					<string>glimmen (blau|rot)\.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Ladungsumkehr</name>
				<script>if avalonUI.runiInfoBoxModel.HammerCharge == "negativ" then
  echo("negativ, jetzt postitiv")
  avalonUI.runiInfoBoxModel.HammerCharge = "positiv"
  
else 
  echo("jetzt negativ")
  avalonUI.runiInfoBoxModel.HammerCharge = "negativ"
  
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Die Ladung des Schmiedehammers hat sich geaendert.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Motion</name>
			<script>--deleteLine()

if player.motion == nil then player.motion = "" end

local mot = matches[3]

if mot == "klettern" then
  player.motion = "kletter"
  --echo("Du beginnst automatisch zu klettern.")
elseif mot == "schwimmen" then
  player.motion = "schwimme"
  --echo("Du beginnst automatisch zu schwimmen.")
elseif mot == "nicht" then 
  player.motion = ""
  --echo("Du hoerst auf zu klettern/schwimmen.")
else
  echo("Fehler in der Motion-Methode")
end

move = string.trim(player.motion .. " " .. player.lastMove)
tempTimer(0.2, [[ send(move, true) ]])
--send(mot, true)
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^(Du musst hier schon (schwimmen), um weiterzukommen!)$</string>
				<string>^(Dort musst Du (nicht) mehr schwimmen\.)$</string>
				<string>^(Du musst hier schon (klettern), um weiterzukommen!)$</string>
				<string>^(Dort musst Du (nicht) mehr klettern\.)$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
				<integer>1</integer>
				<integer>1</integer>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Prompt</name>
			<script>echo("prompt gefunden")</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string></string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>7</integer>
			</regexCodePropertyList>
		</Trigger>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Infobox</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Spielstand</name>
				<script>--echo("\nGruppenübersicht")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(\+---------------------------------------------------------------------------\+)$</string>
					<string>^(\+[-+]*\+)$</string>
					<string>^\|.*\|$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Gruppenübersicht</name>
				<script>--echo("\nGruppenübersicht")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(\+---------------------------------------------------------------------------\+)$</string>
					<string>^(\+[-+]*\+)$</string>
					<string>^\|.*\|$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Inventar</name>
				<script>-- Diese Trigger-Chain versucht das Inventar (i, ausr, inventar, ausruestung) zu finden. Da das Inventar
-- immer mal wieder anders aussieht, ist das mit einem spezifischeren Trigger kaum zu mache. Deshalb wird
-- hier ganz simpel einfach alles genommen, was in der Ausgabe erscheint. Aktiviert wird diese Trigger-
-- Chain durch ein Alias auf die entsprechenden Befehle. Beendet wird die Chain durch den Prompt. Alles
-- zwischen dem Befehl und dem Prompt sollte somit erfasst werden.
-- So ein "catch all" kann natürlich auch für praktisch alles andere verwendet werden, und übergangsweise
-- mache ich das auch. Hier wird also zur Zeit genau so der Spielstand und die Gruppenübersicht getriggert.
-- Der so erfasste Text wird dann in der InfoBox der Oberfläche ausgegeben.
--
--echo("\nInventar")
-- if not isPrompt() then echo("\n"..getLines(getLineNumber()-1, getLineNumber())[1].."\n") end
-- if not isPrompt() then addToInfoBoxBuffer(getLines(getLineNumber()-1, getLineNumber())[1]) end
-- if not isPrompt() then infoBoxBuffer = infoBoxBuffer..(getLines(getLineNumber()-1, getLineNumber())[1]).."\n" end

setTriggerStayOpen("Inventar", 60)

GUIModel.infoBoxBuffer = GUIModel.infoBoxBuffer or ""

if not isPrompt() then
  GUIModel.infoBoxBuffer = GUIModel.infoBoxBuffer..(getLines(getLineNumber()-1, getLineNumber())[1]).."\n"
  --infoBoxBuffer = infoBoxBuffer..(getLines(getLineNumber()-1, getLineNumber())[1]).."\n"
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>60</conditonLineDelta>
				<mStayOpen>60</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^.*$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>InventarEnde</name>
					<script>disableTrigger("Inventar")
--echo(GUIModel.infoBoxBuffer)
raiseEvent("FlushInfoboxBuffer")
GUIModel.infoBoxBuffer = ""</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string></string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>7</integer>
					</regexCodePropertyList>
				</Trigger>
			</Trigger>
		</TriggerGroup>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>map capture</name>
			<script>-- ^(\+---*\+)
-- Kartengröße max laut Spielerbuch 33x17, default 17x9, minimum vielleicht 9x5 (default-kartengröße für kurzmodus)
if mapCapture and line:sub(1,1) == '|' and line:sub(mapCaptureLen,mapCaptureLen) == '|' then
  --table.insert(mapCapture, line:sub(1, mapCaptureLen))
  selectCurrentLine()
  copy()
  smallMap:appendBuffer()
elseif mapCapture and line:sub(1,1) == '+' and line:sub(mapCaptureLen,mapCaptureLen) == '+' then
  --table.insert(mapCapture, line:sub(1, mapCaptureLen))
  selectCurrentLine()
  copy()
  smallMap:appendBuffer()
  mapCaptureLen = nil
  mapCapture = nil
elseif not mapCapture and matches[2] ~= nil and matches[2]:len() &gt; 10 and matches[2]:len() &lt; 21 then  -- otherwise it will also trigger on sp etc.
  mapCaptureLen = matches[2]:len()
  mapCapture = true
  smallMap = nil
  smallMap = Geyser.MiniConsole:new({
      name = "smallMap", 
      --x="50%-"..tostring(3*mapCaptureLen).."c", y="50%", 
      x="15%", y="14%", 
      width = tostring(mapCaptureLen).."c", height = "11c"
    },
    avalonUI.Box41)
  smallMap:setColor("black")
  smallMap:setFontSize(10)
  smallMap:clear()
  selectCurrentLine()
  copy()
  smallMap:appendBuffer()
end
--[[
if mapCaptureLines and mapCaptureLines &gt; 30 then
  --print("case 1")
  mapCapture = nil
  mapCaptureLines = nil
  mapCaptureLen = nil
elseif mapCapture and line:sub(1,1) == '|' and line:sub(mapCaptureLen,mapCaptureLen) == '|' then
  --print("case 2")
  mapCaptureLines = mapCaptureLines + 1
  selectCurrentLine()
  copy()
  smallMap:appendBuffer()
elseif mapCapture and line:sub(1,1) == '+' and line:sub(mapCaptureLen,mapCaptureLen) == '+'  then
  --print("case 3")
  mapCaptureLines = nil
  selectCurrentLine()
  copy()
  smallMap:appendBuffer()
  mapCaptureLen = nil
  mapCapture = nil
elseif not mapCapture and matches[2]:len() &gt; 10 and matches[2]:len() &lt; 21 then  -- otherwise it will also trigger on sp etc.
  --print("case 4")
  mapCaptureLines = 1
  mapCaptureLen = matches[2]:len()
  mapCapture = true
  smallMap = Geyser.MiniConsole:new({
      name = "smallMap", 
      x="10%", y="30%", 
      width = tostring(mapCaptureLen).."c", height = "13c"
    },
    avalonUI.Box4a)
  smallMap:setFontSize(11)
  smallMap:setColor("black")
  smallMap:clear()
  selectCurrentLine()
  copy()
  smallMap:appendBuffer()
end
--]]</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^(\+---*\+)</string>
				<string>|</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
				<integer>2</integer>
			</regexCodePropertyList>
		</Trigger>
		<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Krankheiten-Vergiftungen-Flüche</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>KrankheitenOneLiner</name>
				<script>--[[
Hier einzeilige Texte, die eine Krankheit bzw. einen Fluch auslösen oder anzeigen.
Mehrzeilige Texte, die innerhalb einer Textzeile eindeutig sind, können hier auch
rein. Dann halt die eindeutige Zeile nehmen, den Rest nicht. 

Zu viel Maalkraut:
Uiii, da geht etwas herum in Deinem Bauch. Vielleicht solltest Du nicht so
viele Pflanzen auf einmal essen.

Dein Bauch fuehlt sich ganz hart und steif an.
Du spuerst, wie Gase schmerzhaft von einer Darmwindung zur naechsten
kriechen.
Dein Bauch fuehlt sich hohl und aufgeblasen an.

Urgs, sind das Magenkraempfe?

]]
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#000000</mFgColor>
				<mBgColor>#ffaa00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Uiii, da geht etwas herum in Deinem Bauch. Vielleicht solltest Du nicht so</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>VergiftungenOneLiner</name>
				<script>--[[
Hier einzeilige Texte, die eine Krankheit bzw. einen Fluch auslösen oder anzeigen.
Mehrzeilige Texte, die innerhalb einer Textzeile eindeutig sind, können hier auch
rein. Dann halt die eindeutige Zeile nehmen, den Rest nicht. Beispiel Skorpion:
Der Skorpion schnellt seinen Stachel nach vorn und rammt ihn Dir tief ins
Fleisch.

Du hast das Gefuehl, als wenn Du Dich zersetzen wuerdest. Zum Glueck ist
dem nicht so, aber Dein Herz rast trotzdem.

]]</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#000000</mFgColor>
				<mBgColor>#ffaa00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Dicke Schweissperlen bilden sich auf Deiner Stirn.</string>
					<string>Heftige Hitzewellen durchdringen Deinen Koerper.</string>
					<string>Irgendwie bist Du krank.</string>
					<string>Der Skorpion schnellt seinen Stachel nach vorn und rammt ihn Dir tief ins</string>
					<string>Du hast das Gefuehl, als wenn Du Dich zersetzen wuerdest. Zum Glueck ist</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>0</integer>
					<integer>0</integer>
					<integer>0</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>FlücheOneLiner</name>
				<script>--[[
Hier einzeilige Texte, die eine Krankheit bzw. einen Fluch auslösen oder anzeigen.
Mehrzeilige Texte, die innerhalb einer Textzeile eindeutig sind, können hier auch
rein. Dann halt die eindeutige Zeile nehmen, den Rest nicht. Beispiel Skorpion:
Der Skorpion schnellt seinen Stachel nach vorn und rammt ihn Dir tief ins
Fleisch.

Du hast das Gefuehl, als wenn Du Dich zersetzen wuerdest. Zum Glueck ist
dem nicht so, aber Dein Herz rast trotzdem.

Müllberg Miobaas:
Du hast auf einmal Visionen von riesigen Muellbergen, die Dich zu
verschuetten drohen.

]]</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#000000</mFgColor>
				<mBgColor>#ffaa00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Dicke Schweissperlen bilden sich auf Deiner Stirn.</string>
					<string>Heftige Hitzewellen durchdringen Deinen Koerper.</string>
					<string>Irgendwie bist Du krank.</string>
					<string>Der Skorpion schnellt seinen Stachel nach vorn und rammt ihn Dir tief ins</string>
					<string>Du hast das Gefuehl, als wenn Du Dich zersetzen wuerdest. Zum Glueck ist</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>0</integer>
					<integer>0</integer>
					<integer>0</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>RecoveryOneLiner</name>
				<script>--[[
Hier einzeilige Texte, die das Ende eines Fluches oder einer Krankheit anzeigen.
Wenn innerhalb von zweit- bzw. mehrzeiligen Texten eine Zeile sehr eindeutig ist,
dann kann das hier auch rein. Dann halt nur die eindeutige Zeile hier aufnehmen,
den Rest nicht.
]]</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Der Fluch scheint von Dir gewichen zu sein.</string>
					<string>hat Dich entflucht.</string>
					<string>Du spuerst, wie eine grosse Last von Dir faellt.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>0</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>QuellwasserAbgefülltFluch</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>2</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Puuuah, das Wasser schmeckt unangenehm schal und brackig. Ein unangenehmes$</string>
					<string>^Gefuehl ueberkommt Dich \.\.\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>HeilungQuelleKrankheit</name>
				<script>--[[
Das Quellwasser scheint wirkliche Wunder vollbringen zu koennen, Dein Fluch
ist voellig verschwunden!
Das Quellwasser scheint wirkliche Wunder vollbringen zu koennen, Deine
Krankheit ist voellig verschwunden!

]]</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>2</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Das Quellwasser scheint wirkliche Wunder vollbringen zu koennen, Deine</string>
					<string>Krankheit ist voellig verschwunden!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>HeilungQuelleVergiftung</name>
				<script>--[[
Das Quellwasser scheint wirkliche Wunder vollbringen zu koennen, Dein Fluch
ist voellig verschwunden!


]]</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>2</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Das Quellwasser scheint wirkliche Wunder vollbringen zu koennen, Deine</string>
					<string>Vergiftung ist voellig verschwunden!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>HeilungQuelleFluch</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>2</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Das Quellwasser scheint wirkliche Wunder vollbringen zu koennen, Dein Fluch</string>
					<string>ist voellig verschwunden!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>IngameMapStart</name>
			<script>-- ^(\+---*\+)
-- ^(\+[-]{9,33}\+)
--[[
   Shalabar redet zu Dir:  probier mal den Regex: ^(\| ?.+\|)( .+)?&amp; in dem
        hast du in der ersten Gruppe die Map und die 2. Gruppe ist optional
        und matched bis zum Ende
   Shalabar redet zu Dir:  probier mal den Regex: ^(\|.+\|)( .+)?&amp; ... sorry
        ... der ist kuerzer
           Shalabar redet zu Dir:  fuer die erste Zeile wuerde ich den hier nehmen:
        ^(\+-+\+)(.+)?&amp;
        
   Shalabar redet zu Dir: twx ich fasse nochmal zusammen fuer die erste und
        letzte zeile:  ^(\+-+\+)(.+)?Dollarzeichen und fuer die anderen:
        ^(\|.+\|)(.+)?Dollarzeichen. Vielleicht hat TWX ja noch einen besseren
        Vorschlag
   Shalabar redet zu Dir: ich fasse nochmal zusammen fuer die erste und letzte
        zeile:  ^(\+-+\+)(.+)?Dollarzeichen und fuer die anderen:
        ^(\|.+\|)(.+)?Dollarzeichen. Vielleicht hat TWX ja noch einen besseren
        Vorschlag
 
]]

-- Kartengröße max laut Spielerbuch 33x17, default 17x9, minimum vielleicht 9x5 (default-kartengröße für kurzmodus)
setTriggerStayOpen("IngameMapStart", 10)

-- ^(\+---*\+)
-- Kartengröße max laut Spielerbuch 33x17, default 17x9, minimum vielleicht 9x5 (default-kartengröße für kurzmodus)
if mapCapture and line:sub(1,1) == '|' and line:sub(mapCaptureLen,mapCaptureLen) == '|' then
  --table.insert(mapCapture, line:sub(1, mapCaptureLen))
  selectCurrentLine()
  copy()
  smallMap:appendBuffer()
elseif mapCapture and line:sub(1,1) == '+' and line:sub(mapCaptureLen,mapCaptureLen) == '+' then
  --table.insert(mapCapture, line:sub(1, mapCaptureLen))
  selectCurrentLine()
  copy()
  smallMap:appendBuffer()
  mapCaptureLen = nil
  mapCapture = nil
elseif not mapCapture and matches[2]:len() &gt; 10 and matches[2]:len() &lt; 21 then  -- otherwise it will also trigger on sp etc.
  mapCaptureLen = matches[2]:len()
  mapCapture = true
  smallMap = Geyser.MiniConsole:new({
      name = "smallMap", 
      --x="50%-"..tostring(3*mapCaptureLen).."c", y="50%", 
      x="10%", y="10%", 
      width = tostring(mapCaptureLen).."c", height = "12c"
    },
    avalonUI.Box41)
  smallMap:setColor("black")
  smallMap:setFontSize(11)
  smallMap:clear()
  selectCurrentLine()
  copy()
  smallMap:appendBuffer()
end
--[[
if mapCaptureLines and mapCaptureLines &gt; 30 then
  --print("case 1")
  mapCapture = nil
  mapCaptureLines = nil
  mapCaptureLen = nil
elseif mapCapture and line:sub(1,1) == '|' and line:sub(mapCaptureLen,mapCaptureLen) == '|' then
  --print("case 2")
  mapCaptureLines = mapCaptureLines + 1
  selectCurrentLine()
  copy()
  smallMap:appendBuffer()
elseif mapCapture and line:sub(1,1) == '+' and line:sub(mapCaptureLen,mapCaptureLen) == '+'  then
  --print("case 3")
  mapCaptureLines = nil
  selectCurrentLine()
  copy()
  smallMap:appendBuffer()
  mapCaptureLen = nil
  mapCapture = nil
elseif not mapCapture and matches[2]:len() &gt; 10 and matches[2]:len() &lt; 21 then  -- otherwise it will also trigger on sp etc.
  --print("case 4")
  mapCaptureLines = 1
  mapCaptureLen = matches[2]:len()
  mapCapture = true
  smallMap = Geyser.MiniConsole:new({
      name = "smallMap", 
      x="10%", y="30%", 
      width = tostring(mapCaptureLen).."c", height = "13c"
    },
    avalonUI.Box4a)
  smallMap:setFontSize(11)
  smallMap:setColor("black")
  smallMap:clear()
  selectCurrentLine()
  copy()
  smallMap:appendBuffer()
end
--]]</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>2</conditonLineDelta>
			<mStayOpen>9</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^(\+[-]{9,33}\+)</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>IngameMapKarte</name>
				<script>--^\|.*\|[^\|]{0,}$

-- ^(\+---*\+)
-- Kartengröße max laut Spielerbuch 33x17, default 17x9, minimum vielleicht 9x5 (default-kartengröße für kurzmodus)
if mapCapture and line:sub(1,1) == '|' and line:sub(mapCaptureLen,mapCaptureLen) == '|' then
  --table.insert(mapCapture, line:sub(1, mapCaptureLen))
  selectCurrentLine()
  copy()
  smallMap:appendBuffer()
elseif mapCapture and line:sub(1,1) == '+' and line:sub(mapCaptureLen,mapCaptureLen) == '+' then
  --table.insert(mapCapture, line:sub(1, mapCaptureLen))
  selectCurrentLine()
  copy()
  smallMap:appendBuffer()
  mapCaptureLen = nil
  mapCapture = nil
elseif not mapCapture and matches[2]:len() &gt; 10 and matches[2]:len() &lt; 21 then  -- otherwise it will also trigger on sp etc.
  mapCaptureLen = matches[2]:len()
  mapCapture = true
  smallMap = Geyser.MiniConsole:new({
      name = "smallMap", 
      --x="50%-"..tostring(3*mapCaptureLen).."c", y="50%", 
      x="10%", y="10%", 
      width = tostring(mapCaptureLen).."c", height = "12c"
    },
    avalonUI.Box41)
  smallMap:setColor("black")
  smallMap:setFontSize(11)
  smallMap:clear()
  selectCurrentLine()
  copy()
  smallMap:appendBuffer()
end
--[[
if mapCaptureLines and mapCaptureLines &gt; 30 then
  --print("case 1")
  mapCapture = nil
  mapCaptureLines = nil
  mapCaptureLen = nil
elseif mapCapture and line:sub(1,1) == '|' and line:sub(mapCaptureLen,mapCaptureLen) == '|' then
  --print("case 2")
  mapCaptureLines = mapCaptureLines + 1
  selectCurrentLine()
  copy()
  smallMap:appendBuffer()
elseif mapCapture and line:sub(1,1) == '+' and line:sub(mapCaptureLen,mapCaptureLen) == '+'  then
  --print("case 3")
  mapCaptureLines = nil
  selectCurrentLine()
  copy()
  smallMap:appendBuffer()
  mapCaptureLen = nil
  mapCapture = nil
elseif not mapCapture and matches[2]:len() &gt; 10 and matches[2]:len() &lt; 21 then  -- otherwise it will also trigger on sp etc.
  --print("case 4")
  mapCaptureLines = 1
  mapCaptureLen = matches[2]:len()
  mapCapture = true
  smallMap = Geyser.MiniConsole:new({
      name = "smallMap", 
      x="10%", y="30%", 
      width = tostring(mapCaptureLen).."c", height = "13c"
    },
    avalonUI.Box4a)
  smallMap:setFontSize(11)
  smallMap:setColor("black")
  smallMap:clear()
  selectCurrentLine()
  copy()
  smallMap:appendBuffer()
end
--]]</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^\|[^\|]{9,33}\|</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</Trigger>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Statistics</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>BonusStundenEPZaehler</name>
				<script>if matches[1] == "Du bekommst nun eine Zeit lang erhoehte Erfahrung." then

  player.bonusEP = 0
  avalonUI.refreshCounter()

elseif matches[2] == "ausserordentliche" then

  local ep = nil
  
  ep = tonumber(matches[3])
  player.bonusEP = tonumber(player.bonusEP) + ep
  avalonUI.refreshCounter()
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Du bekommst nun eine Zeit lang erhoehte Erfahrung.</string>
					<string>Du erhaeltst (ausserordentliche) ([0-9]+) Erfahrungspunkte\.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
	</TriggerPackage>
	<TimerPackage>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>avaletTimersTimer</name>
			<script>-- Timer-Timer
-- Dieser Mudlet-Timer sorgt dafür, dass die Anzeige der Avalet-Timer
-- aktualisiert wird. Die hier sekündlich aufgerufene Funktion sorgt dafür,
-- dass ggf. die Reihenfolge der Timer geändert wird, dass die Schriftfarbe
-- die Restlaufzeit wiedergibt und dass der Fortschrittsbalken aktualisiert wird.
avalonUI.refreshTimer()</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:01.000</time>
		</Timer>
		<Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>DateTime</name>
			<script>--avalonUI.getAvalonTime()
avalonUI.Box42:echo(avalonUI.getAvalonTime())</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:01.000</time>
		</Timer>
		<Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>ATCP-Update</name>
			<script>-- ATCP-Update
-- Manche Informationen werden von ATCP nicht automatisch verschickt. Beispielsweise
-- werden der Hunger- und der Durst-Status nicht aktualisiert, wenn der Char isst
-- oder trinkt. Und die Anzeige des Alters auf der Oberfläche ist natürlich auch nicht
-- aktuell. Ich setz hier deshalb mal alle 5 Sekunden eine manuelle Aktualisierung. 
-- Mal sehen, ob sich das bewährt.
_ = sendATCP("ava_req_update")</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:05.000</time>
		</Timer>
	</TimerPackage>
	<AliasPackage>
		<Alias isActive="no" isFolder="no">
			<name>Umlauts</name>
			<script>--[[
-- Hier werden Umlaute und sz in der Benutzereingabe durch die
-- entsprechende Umschreibung ersetzt.
-- Credits to Heiko im Mudlet-Forum
-- https://forums.mudlet.org/viewtopic.php?t=234

command = string.gsub(command, 'ü', 'ue' );
command = string.gsub(command, 'ö', 'oe' );
command = string.gsub(command, 'ä', 'ae' );
command = string.gsub(command, 'Ä', 'Ae' );
command = string.gsub(command, 'Ö', 'Oe' );
command = string.gsub(command, 'Ü', 'Ue' );
command = string.gsub(command, 'ß', 'ss' );

--send( command );
-- Hier wird noch geprüft, ob die Eingabe nach dem Umbau vielleicht
-- auf irgendeine anderes Alias passt. Wenn nicht, wird command an
-- das Mud geschickt. Wenn doch, übernimmt das andere Alias.
expandAlias(command,false)

]]</script>
			<command></command>
			<packageName></packageName>
			<regex>ü|ö|ä|Ü|Ö|Ä|ß</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>ausloggen</name>
			<script>-- logout
-- Dieses Alias soll ausgelöst werden, wenn der Spieler den
-- Charakter richtig ausloggt. Aber NICHT, wenn er Statue wird.
-- Der hier ausgelöste Event räumt dann hauptsächlich Daten ab, damit
-- die nächste Session sauber beginnt. (Session-EP, Chat-Tabs)
send(matches[1],false)
raiseEvent("logoutEvent")
</script>
			<command></command>
			<packageName></packageName>
			<regex>^(ende|ende hier|einschlafen|schlaf ein|schlafe ein)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>Laufrichtung</name>
			<script>-- Laufrichtung
-- Hier wollte ich sicherlich dafür sorgen, dass die Laufrichtung auch dann erfasst wird,
-- wenn der Spieler tatsächlich das Laufen richtig austippt. TODO
mapCapture=nil
send(matches[1],false)
</script>
			<command></command>
			<packageName></packageName>
			<regex>^(n|norden|s|sueden|o|osten|w|westen|no|nordost|so|suedost|sw|suedwest|nw|nordwest|no|nordosten|so|suedosten|sw|suedwesten|nw|nordwesten)$</regex>
		</Alias>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Infobox</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>TEST ruebersicht</name>
				<script>-- TODO: Das hier ist nur zum testen gewesen und sollte gar nicht in einem Release auftauchen.
if player.name == "rofhessa" then
  avalonUI.ruebersichtTEST()
else
  send("ruebersicht")
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^ruebersicht$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>InfoboxDefault</name>
				<script>--Infobox auf Default stellen
if GUIModel.infoBoxTempTimerID ~= nil then killTimer(GUIModel.infoBoxTempTimerID) end
GUIModel.infoBoxTempTimerID=nil
raiseEvent("RefreshInfobox")
</script>
				<command></command>
				<packageName></packageName>
				<regex>^cinfo$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Gruppenübersicht</name>
				<script>--tempTrigger auf ^+---------------...-------------+$, und dann bis zum Prompt
--ausleiten in info-bereich (gruppeninformation)
--^(g|gruppe) (info|gesundheit|tp|einst|einstellungen|sonst|sonstiges)

enableTrigger("Inventar")

--setTriggerStayOpen("Parent trigger name", 0)

send(matches[1],false)
</script>
				<command></command>
				<packageName></packageName>
				<regex>^(g(ruppe)?( (info|gesundheit|tp|einst|einstellungen|sonst|sonstiges))?)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Spielstand</name>
				<script>--tempTrigger auf ^+---------------...-------------+$, und dann bis zum Prompt
--ausleiten in info-bereich (gruppeninformation)

enableTrigger("Inventar")

--setTriggerStayOpen("Parent trigger name", 0)

send(matches[1],false)
</script>
				<command></command>
				<packageName></packageName>
				<regex>^(sp|spielstand|info)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ausruestung</name>
				<script>--tempTrigger auf ^+---------------...-------------+$, und dann bis zum Prompt
--ausleiten in info-bereich (gruppeninformation)

enableTrigger("Inventar")

--setTriggerStayOpen("Parent trigger name", 0)

send(matches[1],false)
</script>
				<command></command>
				<packageName></packageName>
				<regex>^(inventar|ausruestung|ausr|i|inv)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Kampfaufbau</name>
				<script>--tempTrigger auf ^+---------------...-------------+$, und dann bis zum Prompt
--ausleiten in info-bereich (gruppeninformation)

enableTrigger("Inventar")

--setTriggerStayOpen("Parent trigger name", 0)

send(matches[1],false)
</script>
				<command></command>
				<packageName></packageName>
				<regex>^(kampfaufbau)$</regex>
			</Alias>
		</AliasGroup>
		<Alias isActive="yes" isFolder="no">
			<name>schau</name>
			<script>sendATCP("ava_req_iid", "hier")
send(matches[1],false)
</script>
			<command></command>
			<packageName></packageName>
			<regex>^(b|betrachte|betrachten|schau)$</regex>
		</Alias>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<Script isActive="yes" isFolder="no">
			<name>Avalet init</name>
			<packageName></packageName>
			<script>-- init
-- Das Modul Avalet wird im Wesentlichen über eine Funktion initialisiert, die durch den 
-- "sysInstall"-Event aufgerufen wird. Diese Funktion findet sich unter "View --&gt; buildUI".
-- Eine zweite Funktion, die dann ausgeführt wird, findet sich hier weiter unten.

--cecho("&lt;magenta&gt;Avalet init ...\n")

CSSMan = CSSMan or {}
avalonUI = avalonUI or {}


character = character or {}
player = player or {}

avalonUI.chats = avalonUI.chats or {}

-- Speicherort des Moduls. Wird zu:
-- C:/Users/&lt;usrdir&gt;/Documents/Avalet/Avalet.mpackage
modulePath = getModulePath("Avalet")

-- Speicherort des geladenen Profils. Wird zu:
-- C:/Users/&lt;usrdir&gt;/.config/mudlet/profiles/&lt;Profilname&gt;
mudletHomeDir = getMudletHomeDir()

local readFileFromFS = function(path, mode)
  debugc("readFileFromFS()")

  local data = {}
  local file = io.open (path, mode)
  data = yajl.to_value(file:read())
  file:close()
  return data
end

local writeDataToFS = function(path, data, mode)
  debugc("writeDataToFS()")
  
  local file = io.open (path, mode)
  file:write(yajl.to_string(data))
  file:flush()
  file:close()
  return true
end


characterFilePath = characterFilePath or ""
function avalonUI.loadCharacterFileFromDisk(charName)
	--debugc("function loadCharacterFileFromDisk(charName)")
  
  -- Trennzeichen sind abhängig vom Betriebssystem
  if string.char(getMudletHomeDir():byte()) == "/" then _sep = "/" else  _sep = "\\" end
  
  characterFilePath = getMudletHomeDir() .. _sep .. "AvaletCharacter" .. string.title(charName) .. ".json"
  
  -- Hier werden Leerzeichen im Pfad mit einem "\" maskiert, um Probleme unter
  -- Linux zu beheben. Scheint zu funktionieren. Alternativ müsste man das mit
  -- Anführungszeichen um den Pfad rum loesen.
  if _sep == "/" then string.gsub(characterFilePath, " ", "\ ") end
  
  if io.exists(characterFilePath) then
    -- Die Tabelle der geladenen Daten wird mit der Player-Tabelle gemerged
    subset = readFileFromFS(characterFilePath, "r")
    for k,v in pairs(subset) do
      if k ~= "loginIsReconnect" then
        --cecho("&lt;magenta&gt;k: " .. tostring(k) .. "\n")
        player[k] = v 
      end
    end
  else
    --cecho("&lt;magenta&gt;Charakter-Datei nicht gefunden für: " .. charName .. "\n")
    writeDataToFS(characterFilePath, player, "w")
  end
end

-- function loadCharacterSettingsFromDisk(charName)
--[[Eigentlich würde ich hier "Profil-Settings" behandeln. Aber da gibt es ja noch den User-Wunsch, mehrere Chars
    im gleichen Profil spielen zu können. Also muss es innerhalb eines Profils die Möglichkeit geben, verschiedene
    Chars auch verschieden zu konfigurieren. (Beispiel: unterschiedliche Hintergrundfarben)]]
characterSettingsPath = characterSettingsPath or ""
avaletCharacterSettingsPrefix = "AvaletCharacterSettings"
function avalonUI.loadCharacterSettingsFromDisk(charName)
  debugc("function loadCharacterSettingsFromDisk(charName): " .. charName)
  
	if string.char(getMudletHomeDir():byte()) == "/" then _sep = "/" else  _sep = "\\" end
  
  characterSettingsPath = getMudletHomeDir() .. _sep .. avaletCharacterSettingsPrefix .. string.title(charName) .. ".json"
  
  -- Das hier ist der Versuch, ein Problem mit Leerzeichen im Pfad unter Linux zu lösen.
  -- Indem das Leerzeichen mit einem "\" maskiert wird. Alternativ müsste man das mit 
  -- Anführungszeichen um den Pfad rum lösen.
  if _sep == "/" then string.gsub(characterFilePath, " ", "\ ") end
  
--	if io.exists(characterFilePath) then
		--cecho("&lt;magenta&gt;Charakter-Datei ist vorhanden, versuche Datei zu laden:\n" .. characterFilePath .. "\n")
    -- merge 2 tables
--    subset = readFileFromFS(characterSettingsPath, "r")
--    for k,v in pairs(subset) do player[k] = v end
		--player = readFileFromFS(characterFilePath, "r")
		--echo("...done\n")
--	else
	  --cecho("&lt;magenta&gt;Charakter-Datei nicht gefunden für: " .. charName .. "\n")
		--echo("Erzeuge Character-Objekt\n")
		--player = Character()
		--echo("...done\n")
--		writeDataToFS(characterSettingsPath, player, "w")
--	end  
  return
end


characterChatsPath = characterChatsPath or ""
function avalonUI.loadCharacterChatsFromDisk(charName)
  debugc("function loadCharacterChatsFromDisk")
  
  if string.char(getMudletHomeDir():byte()) == "/" then _sep = "/" else  _sep = "\\" end
  
  characterChatsPath = getMudletHomeDir() .. _sep .. "AvaletChats" .. string.title(charName) .. ".json"
  
  -- Leerzeichen im Pfad maskieren für Linux-Systeme 
  if _sep == "/" then string.gsub(characterChatsPath, " ", "\ ") end
  
  if io.exists(characterChatsPath) then
    subset = readFileFromFS(characterChatsPath, "r")
    for k,v in pairs(subset) do avalonUI.chats[k] = v end
  else
    writeDataToFS(characterChatsPath, avalonUI.chats, "w")
  end
end



-- function loadVersionInformation()
function avalonUI.loadVersionInformation()
  --local versionFilePath = getMudletHomeDir().. .."/Avalet/version"
  -- TODO
  return

end -- function loadVersionInformation()


-- function initPlayer(name)
-- Wenn nach dem Start von Mudlet der Name des angemeldeten Charakters per ATCP
-- ERSTMALS übertragen wird, kann dieses Modul die Charakter-abhängigen Teile
-- initialisieren. Also im Grunde alles außer das, was Avalet selbst betrifft.
-- Diese Funktion wird sowohl nach einem echten login als auch nach einem
-- reconnect ausgeführt!
function avalonUI.initPlayer(name)
  debugc("Funktion initPlayer aufgerufen mit Parameter: " .. name)

  -- Settings des Chars laden
  avalonUI.loadCharacterSettingsFromDisk(name)

  -- Charakterdaten laden
  avalonUI.loadCharacterFileFromDisk(name)
  -- Unterscheiden zwischen einem reconnect und einem echten login:
  -- (Den echten Login zu erkennen geht leider nicht. Was bei einem
  -- echten login vorhanden sein soll, muss man beim echten logout
  -- weiter unten setzen.)
  if not player.loginIsReconnect then
    --cecho("&lt;magenta&gt;\nes ist _kein_ reconnect: "..tostring(player.ep).."\n")
    player.sessionEP = tonumber(player.ep)
  end

  -- Chat-Verläufe laden
  avalonUI.loadCharacterChatsFromDisk(name)
  -- Nachdem die Inhalte der Chat-Tabs geladen wurden, muss das aktuelle
  -- Tab-Element noch aktualisiert werden.
  --cecho("&lt;magenta&gt;\nAktualisierung des aktuellen Chat-Tabs?\n")
  raiseEvent("RefreshTabElement", GUIModel.tabElement.currentTab)
end --function initPlayer(name)



-- Function: onKeyPadEvent
-- fuer das Laufen per Keypad, und fuer das Catchen
-- der letzten Bewegung fuer den Mapper
-- und fuer das automatische Schwimmen/ Klettern
-- Dieser Event wird jedesmal ausgelöst, wenn eine Taste des Ziffernblocks verwendet wird.
-- Das ist unter "Keybindings" bzw. "Tasten" so definiert.
-- Hier kommt eine ZAHL an als key, und diese Zahl wird dann über den Index des Arrays
-- in eine Richtung umgewandelt!
function avalonUI.onKeyPadEvent(eventName,key)--,tDirections)
  tDirections = {"sw","s","so","w","sc","o","nw","n","no","h","r","rein","raus"}
  player.lastMove = tDirections[key]
  --tPlayer.sLastMoveDirection=tDirections[key]
  mapCapture=nil
  local str = ""
  if key &gt; 0 and key &lt; 10 and key ~= 5 then
    str = string.trim(player.motion .. " " .. player.lastMove)
  else
    str = player.lastMove
  end
  send(str, false)

end --function onKeyPadEvent
registerAnonymousEventHandler("keyPadEvent", "avalonUI.onKeyPadEvent")



-- Der "sysConnectionEvent" ist ein Standard-Event von Mudlet.
-- Er wird ausgelöst, wenn eine Verbindung zum MUD besteht. Aber davon
-- abgesehen kann man hier noch nicht viel machen: ATCP funktioniert
-- hier noch nicht, ein Charakter ist noch nicht verfügbar (noch nicht
-- angemeldet), ...
function avalonUI.onSysConnectionEvent()
  debugc("function onSysConnectionEvent()")

  -- check if UTF-8 is available:
  if table.contains(getServerEncodingsList(), "UTF-8") then
    if getServerEncoding() == "ASCII" then
      setServerEncoding("UTF-8")
      print("ServerEncoding auf UTF-8 gesetzt!")
    end
  end
  
end
registerAnonymousEventHandler("sysConnectionEvent", "avalonUI.onSysConnectionEvent")


-- Der "sysExitEvent" ist ein Standard-Event von Mudlet.
-- Er wird ausgelöst, wenn Mudlet das Profil schließt.
function avalonUI.onSysExitEvent()
	debugc("onSysExitEvent")

  -- Sichere Charakter-Daten. Das ist hier vielleicht überflüssig,
  -- weil es durch den "sysDisconnectionEvent" schon geschieht.
  -- Deshalb testweise auskommentiert.
  if player.name ~= "" then
    --writeDataToFS(characterFilePath, player, "w")
  end
end
registerAnonymousEventHandler("sysExitEvent", "avalonUI.onSysExitEvent")


-- Der Event "sysDisconnectionEvent" ist ein Standard-Event von Mudlet.
-- Er wird ausgelöst, wenn die Verbindung zum MUD abreisst. Das kann sowohl
-- durch ein logout geschehen als auch durch jeden anderen Verbindungs-
-- abbruch.
function avalonUI.onSysDisconnectionEvent()
  debugc("onSysDisconnectionEvent()")
  
  -- Hier wird vorsorglich der Wert gesetzt, der bei der nächsten Verbindungs-
  -- aufnahme ausgewertet wird. VOR dieser Auswertung wird der Wert aber noch-
  -- mal überschrieben, wenn diese Verbindungsaufnahme ein "reconnect" ist.
  player.loginIsReconnect = false
  
  writeDataToFS(characterFilePath, player, "w")
  writeDataToFS(characterChatsPath, avalonUI.chats, "w")
end
registerAnonymousEventHandler("sysDisconnectionEvent", "avalonUI.onSysDisconnectionEvent")


-- Dieses Event wird ausgelöst, wenn der Spieler den Charakter richtig ausloggt,
-- also mit "schlafe ein" etc. Ausgelöst wird dieses Event durch ein Alias auf
-- die Befehle, mit denen das Ausloggen möglich ist. Außer ich hab einen vergessen.
-- Derzeit: ^(ende|ende hier|einschlafen|schlaf ein|schlafe ein)$
function avalonUI.onLogoutEvent()
	debugc("onLogoutEvent()")

  -- Die Basis, auf der die Session-EP berechnet werden, wird hier schon mal für die
  -- nächste Session gesetzt.
  -- Das geschieht neuerdings beim Login nochmal, und damit die Anzeige im UI nach dem
  -- logout noch den Wert der dann grade beendeten Session zeigt, ist das hier erstmal
  -- auskommentiert. Testweise. TODO
  --player.sessionEP = tonumber(player.ep)
  
  -- der nächste Login wird zwangsläufig ein "richtiger" login sein, kein reconnect
  player.loginIsReconnect = false

  -- Bei einem richtigen logout werden die ChatTab-Verläufe gelöscht:
  -- TODO: evtl. konfigurierbar machen, die Beschränkung auf (derzeit) 500 Zeilen
  -- setzt ja auch schon eine Grenze.
  for k,v in pairs(GUIModel.tabElement.tabs) do

    avalonUI.chats[v] = {}
    
  end

end
registerAnonymousEventHandler("logoutEvent", "avalonUI.onLogoutEvent")



-- afterReconnectEvent wird durch einen Trigger auf "Verwende alten Koerper..." ausgelöst.
-- Das ist notwendig, da das MUD bei einem Reconnect die ATCP-Daten nicht erneut schickt.
function avalonUI.afterReconnectEvent()
  debugc("afterReconnectEvent()")
  --cecho("&lt;magenta&gt;\nab jetzt ist es ein reconnect\n")
  --debugc("ab jetzt ist es ein reconnect")
  player.loginIsReconnect = true
  -- "sendATCP" gibt "true" zurück, und das wird unter Umständen im Hauptfenster
  -- ausgegeben. Außer man speichert es in einer Variable wie zum Beispiel "_".
  _ = sendATCP("ava_req_update")
end
registerAnonymousEventHandler("afterReconnectEvent", "avalonUI.afterReconnectEvent")



-- Func: fsysProtocolEnabled
-- Ich hab versucht, hier auch auf "GMCP" zu prüfen und eine
-- Warnung auszugeben. Aber offenbar wird GMCP nicht wie die
-- anderen Protokolle aktiviert, ich hatte jedenfalls keinen
-- Auslöser des "elseif", trotz aktiviertem GMCP. TODO
function avalonUI.onSysProtocolEnabled(event,arg)
	debugc("&lt;red&gt;onSysProtocolEnabled() running at this point.\n")
	if arg =="ATCP" then
		--echo("ATCP Support aktiviert.\n")
		sendATCP("ava_set_mapper",1)
		sendATCP("ava_set_channel",1)
		sendATCP("ava_set_comm",1)
		sendATCP("ava_set_rcomm",1)
		sendATCP("ava_set_soul",1)
		sendATCP("ava_set_rsoul",1)
		--sendATCP("ava_set_soundpack",1)
		sendATCP("ava_req_update",1)
		sendATCP("ava_req_graphics_status",1)
	elseif arg=="GMCP" then
		debugc("&lt;red&gt;GMCP ist offenbar aktiviert. So wird Avalet nicht funktionieren.\nBitte GMXP in den Einstellungen deaktivieren und neu starten.")
	else
		--echo("Support fuer "..arg.." ist aktiv.\n")
	end
end
registerAnonymousEventHandler("sysProtocolEnabled", "avalonUI.onSysProtocolEnabled")



-- function onSysInstall
-- Wird ausgeführt nach der Installation eines Moduls oder eines Paketes.
-- Dazu wird ein EventHandler für das entsprechende Mudlet-Event registriert.
-- Hier muss zunächst geschaut werden, ob der Event auch Avalet betrifft. 
-- Anschließend findet hier Modul-Initialisierung statt.
-- Avalet:    setModulePriority("Avalet", 1)
-- SubModule: priority &gt; 2, vorher prüfen ob avalet installiert ist
function avalonUI.onSysInstall(_, name)
  debugc("function onSysInstall()")
  -- Erstmal prüfen, ob es Avalet ist, was da installiert wurde:
  if name ~= "Avalet" then return end
  
  -- Für eine vernünftige Versionierung bzw. für einen irgendwie gearteten
  -- Update-Mechanismus muss Avalet etwas über die eigene Versionsnummer wissen.
  avalonUI.loadVersionInformation()

  -- Die Modul-Priorität von Avalet wird auf 1 gesetzt, um später Submodule mit
  -- einer niedrigeren Priorität ausstatten zu können. Das sollte dazu führen,
  -- dass die Submodule NACH Avalet installiert werden. (Das ist aber ungetestet
  -- und ich sehe auch nicht, wie das gehen kann. Wenn ich die Priorität erst
  -- NACH der installation setzen kann... Vermutlich also ein TODO.)  
  setModulePriority("Avalet", 1)
  
  --	Nach einem Reconnect braucht Avalet den Charakternamen. Nach einem normalen
  -- Login wird der sehr schnell per ATCP gesendet. Nach einem reconnect (Statue)
  -- aber nicht. Der Trigger, der hier erzeugt wird, reagiert auf "Verwende alten 
  -- Koerper..." und löst dann einen Event aus, der ein ATCP-Update vom Server
  -- anfordert. Damit kommt dann auch der Charaktername.
  if not exists("OnReconnect", "trigger") then
    luaCode = [[raiseEvent("afterReconnectEvent")]]
    permRegexTrigger("OnReconnect", "Avalet", {"^Verwende alten Koerper\.\.\.$"}, luaCode)
  end
end -- function onSysInstall
registerAnonymousEventHandler("sysInstall", "avalonUI.onSysInstall")


-- function onSysUninstall(_, name)
-- Diese Funktion soll ausgeführt werden, wenn Avalet deinstalliert wird.
-- Deshalb wird hier ein EventHandler für das onSysUninstall-Event registriert.
-- In der Funktion muss dann noch geschaut werden, ob das auch Avalet ist,
-- was deinstalliert wurde.
-- Die Funktion wird grad nicht verwendet, aber das wird sich sicher noch ändern.
function avalonUI.onSysUninstall(_, name)
  --debugc("function onSysUninstall()")
  -- Erstmal prüfen, ob es Avalet ist, was da deinstalliert wurde:
  if name ~= "Avalet" then return end

end -- function onSysUninstall(_, name)
registerAnonymousEventHandler("sysUninstall", "avalonUI.onSysUninstall")


-- sysInstallPackage - Standard-Event von Mudlet
-- Avalet funktioniert nicht, wenn es als Paket installiert wird - nur als Modul!
-- Deshalb hier die Fehlermeldung. Aus gutem Grund nenne ich diesen Dialog den
-- "Dubhe-Dialog".
function avalonUI.onSysInstallPackage(_, name)
  debugc("function onSysInstallPackage()")
  -- Erstmal prüfen, ob es Avalet ist, was da installiert wurde:
  if name ~= "Avalet" then return end
  
  cecho("\n\n&lt;magenta&gt;!!!    ACHTUNG: Avalet wurde als Paket installiert!    !!!\n")
  cecho(    "&lt;magenta&gt;!!!        Avalet funktioniert als Paket nicht.        !!!\n")
  cecho(    "&lt;magenta&gt;!!!    Avalet muss jetzt erst deinstalliert werden!    !!!\n")
  cecho(    "&lt;magenta&gt;!!! Anschliessend Avalet bitte als MODUL installieren! !!!\n\n")
  
end
registerAnonymousEventHandler("sysInstallPackage", "avalonUI.onSysInstallPackage")
</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Frameworks</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>Jor'Mox's GUIframe</name>
				<packageName></packageName>
				<script>-- Jor'Mox's GUIframe Script
-- 3/07/2019
-- v1.4.2
-- To resize frames or move tabs, right click and drag either the resize label or the tab
-- until the desired result is achieved.
-- To add a window to a frame for the script to manage, use the
-- GUIframe.addWindow(window, name, container, hideText) function, where the window
-- variable contains the Geyser object you want to add, the name variable contains
-- the name you want it to be referred to as, which also is used as the text printed
-- on the associated tab that is created, the container variable is a string containing
-- one of the following: bottom, top, topleft, topright, bottomleft, bottomright,
-- and the hideText variable is an optional boolean which, if true, prevents text being
-- written on the tab for this window.
-- To remove a window from GUIframe, use the GUIframe.removeWindow(name, container)
-- function, where the name variable is the same name you gave the window when adding it,
-- and the optional container variable is a string specifying which container to remove
-- the window from. If no container is specified, the window is removed regardless of
-- which container it is in.
-- Resizing of frames can be enabled or disabled using the GUIframe.enable(side) and
-- GUIframe.disable(side, hide) functions respectively. If the second argument to
-- GUIframe.disable is false, then the entire set of frames on that side is hidden, and
-- the border is adjusted as if that side had be resized to zero.
-- To save and load settings, use the GUIframe.saveSettings() and
-- GUIframe.loadSettings(redraw) functions. If the redraw argument is true, the border
-- background color is changed to black to force the area of the borders to be redrawn.
-- Additionally, the GUIframe.reinitialize() function can be used to force the script to
-- initialize itself again, going back to default settings.
-- To activate a tab without it being clicked, use the GUIframe.activate(name) function.
-- And to apply a stylesheet to a tab that is different from the default stylesheet, use
-- the GUIframe.styleTab(name, style) function, where the style variable contains a string
-- with the CSS to be applied. Since tabs are styled only when created or when this
-- function is used, there should be no concern with this styling being overwritten.
GUIframe = GUIframe or {}
local mainW, mainH = getMainWindowSize()
local halfW, halfH = math.floor(mainW / 2), math.floor(mainH / 2)
GUIframe.configs = GUIframe.configs or {}
GUIframe.defaults =
  {
    tabHeight = 20,
    tabStyle =
      [[
        background-color: green;
        border-width: 2px;
        border-style: outset;
        border-color: limegreen;
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
        margin-right: 1px;
        margin-left: 1px;
        qproperty-alignment: 'AlignCenter | AlignCenter';]],
    tabEchoStyle = '&lt;center&gt;&lt;p style="font-size:14px; color:white"&gt;',
    leftStartWidth = 50,
    leftStartHeight = halfH,
    rightStartWidth = 50,
    rightStartHeight = halfH,
    topStartHeight = 50,
    bottomStartHeight = 50,
    resizeHeight = 30,
    resizeWidth = 30,
    resizeHoverImage = "/Avalet/imgs/blue_arrows.png",
    resizeRestImage = "/Avalet/imgs/blue_arrows_20t.png",
    borderOffset = 5,
  }
GUIframe.windows = GUIframe.windows or {}
GUIframe.tabs = GUIframe.tabs or {}
GUIframe.tabCoords = GUIframe.tabCoords or {}
GUIframe.sides =
  GUIframe.sides or {left = 'enabled', right = 'enabled', top = 'enabled', bottom = 'enabled'}
local resize_style = "border-image: url(%s%s);"
local configs = table.update(GUIframe.defaults, GUIframe.configs)
local tabsInfo, containerInfo, resizeInfo
local container_names =
  {
    'topLeftContainer',
    'bottomLeftContainer',
    'topRightContainer',
    'bottomRightContainer',
    'bottomContainer',
    'topContainer',
  }
local tab_names =
  {'topLeftTabs', 'topRightTabs', 'bottomLeftTabs', 'bottomRightTabs', 'midLeftTabs'}
local resizeLabels = {'resizeLeft', 'resizeRight', 'resizeTop', 'resizeBottom'}
local sides = {"top", "bottom", "left", "right"}
local side_containers =
  {
    left = {"topLeftContainer", "bottomLeftContainer", "topLeftTabs", "bottomLeftTabs"},
    right = {"topRightContainer", "bottomRightContainer", "topRightTabs", "bottomRightTabs"},
    top = {"topContainer"},
    bottom = {"bottomContainer"},
  }

local function get_window_coords(win, update)
  -- gets coords for window, stores data in tabCoords table as needed
  local x, y = win:get_x(), win:get_y()
  local w, h = win:get_width(), win:get_height()
  if update then
    GUIframe.tabCoords[win.name] = {x = x, y = y, w = w, h = h}
  end
  return x, y, w, h
end

local function check_overlap(tab, x, y)
  -- checks to see if given coords overlap tab or tab container
  if type(tab) == "string" then
    tab = GUIframe[tab] or GUIframe.tabs[tab]
  end
  if tab.hidden or tab.auto_hidden then
    return false
  end
  local info = GUIframe.tabCoords[tab.name]
  local x1, y1 = info.x, info.y
  local x2, y2 = x1 + info.w, y1 + info.h
  return (x &gt;= x1 and x &lt;= x2 and y &gt;= y1 and y &lt;= y2)
end

local function update_tab(tab, x, y, w, h)
  -- resizes and moves tab and updates tab coords table
  tab:move(x, y)
  tab:resize(w, h)
  local info = GUIframe.tabCoords[tab.name] or {}
  info.x, info.y = tab:get_x(), tab:get_y()
  info.w, info.h = tab:get_width(), tab:get_height()
  if table.contains(tab_names, tab.name) then
    info.container = true
  end
  GUIframe.tabCoords[tab.name] = info
end

local function get_containers(pos)
  if type(pos) == "table" then
    pos = pos.name
  end
  for _, w in ipairs({'right', 'left', 'container', 'tabs'}) do
    pos = pos:gsub(w, w:title())
  end
  local con, tab
  if string.find(pos, "Container") then
    con = GUIframe[pos]
    if not con then
      return
    end
    tabs = con.tabs
  elseif string.find(pos, "Tabs") then
    tabs = GUIframe[pos]
    if not tab then
      return
    end
    con = tabs.con
  else
    con = GUIframe[pos .. "Container"]
    tabs = GUIframe[pos .. "Tabs"]
  end
  return con, tabs
end

local function config()
  configs = table.update(GUIframe.defaults, GUIframe.configs)
  GUIframe.windows = {}
  GUIframe.tabCoords = {}
  tabsInfo =
    {
      topLeftTabs =
        {
          name = 'topLeftTabs',
          x = 0,
          y = 0,
          width = configs.leftStartWidth,
          height = configs.tabHeight,
        },
      bottomLeftTabs =
        {
          name = 'bottomLeftTabs',
          x = 0,
          y = configs.leftStartHeight,
          width = configs.leftStartWidth,
          height = configs.tabHeight,
        },
      topRightTabs =
        {
          name = 'topRightTabs',
          x = mainW - configs.rightStartWidth,
          y = 0,
          width = configs.rightStartWidth,
          height = configs.tabHeight,
        },
      bottomRightTabs =
        {
          name = 'bottomRightTabs',
          x = mainW - configs.rightStartWidth,
          y = configs.rightStartHeight,
          width = configs.rightStartWidth,
          height = configs.tabHeight,
        },
    }
  containerInfo =
    {
      topLeftContainer =
        {
          name = 'topLeftContainer',
          x = 0,
          y = configs.tabHeight,
          width = configs.leftStartWidth,
          height = configs.leftStartHeight - configs.tabHeight,
        },
      bottomLeftContainer =
        {
          name = 'bottomLeftContainer',
          x = 0,
          y = configs.leftStartHeight + configs.tabHeight,
          width = configs.leftStartWidth,
          height = configs.leftStartHeight - configs.tabHeight,
        },
      topRightContainer =
        {
          name = 'topRightContainer',
          x = mainW - configs.rightStartWidth,
          y = configs.tabHeight,
          width = configs.rightStartWidth,
          height = configs.rightStartHeight - configs.tabHeight,
        },
      bottomRightContainer =
        {
          name = 'bottomRightContainer',
          x = mainW - configs.rightStartWidth,
          y = configs.rightStartHeight + configs.tabHeight,
          width = configs.rightStartWidth,
          height = configs.rightStartHeight - configs.tabHeight,
        },
      bottomContainer =
        {
          name = 'bottomContainer',
          x = configs.leftStartWidth,
          y = mainH - configs.bottomStartHeight,
          height = configs.bottomStartHeight,
          width = mainW - configs.leftStartWidth - configs.rightStartWidth,
        },
      topContainer =
        {
          name = 'topContainer',
          x = configs.leftStartWidth,
          y = 0,
          height = configs.topStartHeight,
          width = mainW - configs.leftStartWidth - configs.rightStartWidth,
        },
    }
  resizeInfo =
    {
      resizeLeft =
        {
          name = 'resizeLeft',
          x = configs.leftStartWidth,
          y = configs.leftStartHeight - configs.resizeHeight / 2,
          height = configs.resizeHeight,
          width = configs.resizeWidth,
        },
      resizeRight =
        {
          name = 'resizeRight',
          x = configs.rightStartWidth - configs.resizeWidth,
          y = configs.rightStartHeight - configs.resizeHeight / 2,
          height = configs.resizeHeight,
          width = configs.resizeWidth,
        },
      resizeTop =
        {
          name = 'resizeTop',
          x = halfW - configs.resizeWidth / 2,
          y = configs.topStartHeight,
          height = configs.resizeHeight,
          width = configs.resizeWidth,
        },
      resizeBottom =
        {
          name = 'resizeBottom',
          x = halfW - configs.resizeWidth / 2,
          y = mainH - configs.bottomStartHeight - configs.resizeHeight,
          height = configs.resizeHeight,
          width = configs.resizeWidth,
        },
    }
  for name, cons in pairs(containerInfo) do
    GUIframe[name] = Geyser.Container:new(cons)
  end
  for name, cons in pairs(tabsInfo) do
    GUIframe[name] = Geyser.Container:new(cons)
    local cname = name:gsub("Tabs", "Container")
    GUIframe[cname].tabs = GUIframe[name]
    GUIframe[name].con = GUIframe[cname]
  end
  local style = resize_style
  local path = getMudletHomeDir()
  path = path:gsub("[\\/]", "/")
  configs.resizeRestImage = configs.resizeRestImage:gsub("[\\/]", "/")
  configs.resizeHoverImage = configs.resizeHoverImage:gsub("[\\/]", "/")
  local no_image
  if
    not (io.exists(path .. configs.resizeHoverImage) and io.exists(path .. configs.resizeRestImage))
  then
    debugc("GUIframe: config: resize image(s) not found")
    echo("GUIframe: config: resize image(s) not found".."\n"..path.."\n"..configs.resizeRestImage.."\n")
    path = "255,20,147,"
    style = "background-color: rgba(%s%s);"
    no_image = true
  end
  for name, cons in pairs(resizeInfo) do
    GUIframe[name] = Geyser.Label:new(cons)
    GUIframe[name]:setColor(0, 0, 0, 0)
    GUIframe[name]:setStyleSheet(
      string.format(style, path, (no_image and "100") or configs.resizeRestImage)
    )
    GUIframe[name]:setOnEnter(
      "GUIframe." .. name .. ".setStyleSheet",
      GUIframe[name],
      string.format(style, path, (no_image and "255") or configs.resizeHoverImage)
    )
    GUIframe[name]:setOnLeave(
      "GUIframe." .. name .. ".setStyleSheet",
      GUIframe[name],
      string.format(style, path, (no_image and "100") or configs.resizeRestImage)
    )
    GUIframe[name]:setClickCallback("GUIframe.buttonClick", name)
    GUIframe[name]:setReleaseCallback("GUIframe.buttonRelease", name)
    GUIframe[name]:setMoveCallback("GUIframe.buttonMove", name)
  end
  setBorderLeft(configs.leftStartWidth + configs.borderOffset)
  setBorderRight(configs.rightStartWidth + configs.borderOffset)
  setBorderTop(configs.topStartHeight + configs.borderOffset)
  setBorderBottom(configs.bottomStartHeight + configs.borderOffset)
  GUIframe.initialized = true
end

local function deselectContainer(container, tabs)
  -- hide all windows in container
  for _, win in pairs(container.windowList) do
    win:hide()
    win.active = false
  end
  -- unhighlight all tabs in tabs container
  if tabs then
    for _, tab in pairs(tabs.windowList) do
      local name = tab.name:gsub("Tab", "")
      local show = GUIframe.windows[name].showText
      if show then
        tab:echo(configs.tabEchoStyle .. name)
      end
    end
  end
end

local function adjustTabs(tabs)
  if not GUIframe.initialized then
    error("GUIframe not initialized", 2)
  end
  -- remove duplicated window names
  local found = {}
  for k, v in ipairs(tabs.windows) do
    if not table.contains(found, v) and tabs.windowList[v] and not tabs.windowList[v].isClicked then
      table.insert(found, v)
    end
  end
  -- calculate tab width and set height
  local w, h = math.floor(100 / #tabs.windows), configs.tabHeight

  local function wrap(num)
    return tostring(num) .. "%"
  end

  -- resize and reposition all tabs
  local shown, first
  for k, v in ipairs(found) do
    local tab = tabs.windowList[v]
    if not first then
      first = v:gsub("Tab", "")
    end
    if not shown and tab.active then
      shown = v
    elseif tab.active then
      tab.active = false
    end
    update_tab(tab, wrap(w * (k - 1)), 0, wrap(w), h)
  end
  if first and not shown and GUIframe.windows[first] then
    GUIframe.windows[first]:show()
  end
  tabs.space_pos = nil
end

local function reorderTabs(tabs, name, pos)
  local windows = tabs.windows
  while table.contains(windows, name) do
    table.remove(windows, table.index_of(windows, name))
  end
  table.insert(windows, pos, name)
end

local function makeSpace(tabs, tab, pos)
  if not GUIframe.initialized then
    error("GUIframe not initialized", 2)
  end
  local windows = table.deepcopy(tabs.windows)
  local space_pos = tabs.space_pos
  local tab_pos = table.index_of(windows, tab.name)
  -- calculate tab width and set height
  local num_tabs = #windows + 1
  if tab_pos then
    num_tabs = num_tabs - 1
    if pos &gt; tab_pos then
      pos = pos - 1
    end
    if pos == space_pos then
      pos = pos + 1
    end
  elseif space_pos and pos &gt;= space_pos then
    pos = pos + 1
  end
  local w, h = math.floor(100 / num_tabs), configs.tabHeight

  local function wrap(num)
    return tostring(num) .. "%"
  end

  -- resize and reposition all tabs
  if tab_pos then
    table.remove(windows, tab_pos)
  end
  for k, v in ipairs(windows) do
    if k &gt;= pos then
      update_tab(tabs.windowList[v], wrap(w * k), 0, wrap(w), h)
    else
      update_tab(tabs.windowList[v], wrap(w * (k - 1)), 0, wrap(w), h)
    end
  end
  tabs.space_pos = pos
end

local function round(num, roundTo)
  local b, r = math.modf(num / roundTo)
  if r &gt;= 0.5 then
    b = b + 1
  end
  return b * roundTo
end

local function setBorder(side, val)
  local funcs =
    {left = setBorderLeft, right = setBorderRight, top = setBorderTop, bottom = setBorderBottom}
  val = math.max(val, 0)
  funcs[side](val)
end

local function resizeContainers(side, w, h)
  if table.contains({"left", "right"}, side) then
    local info =
      {
        left =
          {
            resize = "resizeLeft",
            cons = {"topLeftContainer", "bottomLeftContainer"},
            tabs = {"topLeftTabs", "bottomLeftTabs"},
            x = 0,
            w = w,
          },
        right =
          {
            resize = "resizeRight",
            cons = {"topRightContainer", "bottomRightContainer"},
            tabs = {"topRightTabs", "bottomRightTabs"},
            x = w,
            w = mainW - w,
          },
      }
    info = info[side]
    -- move and resize top, bottom and tab containers
    update_tab(GUIframe[info.tabs[1]], info.x, 0, info.w, configs.tabHeight)
    update_tab(GUIframe[info.tabs[2]], info.x, h, info.w, configs.tabHeight)
    GUIframe[info.cons[1]]:resize(info.w, h - configs.tabHeight)
    GUIframe[info.cons[1]]:move(info.x, configs.tabHeight)
    GUIframe[info.cons[2]]:resize(info.w, mainH - h - configs.tabHeight)
    GUIframe[info.cons[2]]:move(info.x, h + configs.tabHeight)
    -- adjust border size
    setBorder(side, info.w + configs.borderOffset)
    -- adjust width of top and bottom containers
    local x, y
    x = (GUIframe.sides.left ~= "hidden" and GUIframe.topLeftContainer:get_width()) or 0
    w = ((GUIframe.sides.right ~= "hidden" and GUIframe.topRightContainer:get_x()) or mainW) - x
    for _, con in ipairs({GUIframe.topContainer, GUIframe.bottomContainer}) do
      y, h = con:get_y(), con:get_height()
      con:resize(w, h)
      con:move(x, y)
    end
  elseif table.contains({"top", "bottom"}, side) then
    local x = 0
    w = mainW
    if GUIframe.sides.left ~= "hidden" then
      w = w - GUIframe.topLeftContainer:get_width()
      x = GUIframe.topLeftContainer:get_width()
    end
    if GUIframe.sides.right ~= "hidden" then
      w = w - GUIframe.topRightContainer:get_width()
    end
    local info =
      {
        top = {con = "topContainer", y = 0, h = h},
        bottom = {con = "bottomContainer", y = h, h = mainH - h},
      }
    local con = GUIframe[info[side].con]
    con:resize(w, info[side].h)
    con:move(x, info[side].y)
    setBorder(side, info[side].h + configs.borderOffset)
  end
end

local function refresh()
  if not GUIframe.initialized then
    error("GUIframe not initialized", 2)
  end
  mainW, mainH = getMainWindowSize()
  local rH, rW = configs.resizeHeight, configs.resizeWidth
  local x, y, w
  -- adjust bottom left and right container heights
  for _, C in ipairs({GUIframe.bottomLeftContainer, GUIframe.bottomRightContainer}) do
    C:resize(C:get_width(), mainH - C:get_y())
  end
  -- reposition right containers
  w = GUIframe.topRightContainer:get_width()
  for
    _, C in
      ipairs(
        {
          GUIframe.topRightContainer,
          GUIframe.topRightTabs,
          GUIframe.bottomRightContainer,
          GUIframe.bottomRightTabs,
        }
      )
  do
    C:move(mainW - w, C:get_y())
  end
  -- resize and reposition bottom and top containers
  w, x = mainW, 0
  if GUIframe.sides.left ~= "hidden" then
    w = w - GUIframe.topLeftContainer:get_width()
    x = GUIframe.topLeftContainer:get_width()
  end
  if GUIframe.sides.right ~= "hidden" then
    w = w - GUIframe.topRightContainer:get_width()
  end
  for _, C in ipairs({GUIframe.topContainer, GUIframe.bottomContainer}) do
    C:resize(w, C:get_height())
    C:move(x, C.name == "topContainer" and 0 or mainH - C:get_height())
  end
  -- reposition resize labels
  x, y = GUIframe.topLeftContainer:get_width(), GUIframe.bottomLeftTabs:get_y()
  GUIframe.resizeLeft:move(x, y - rH / 2)
  x, y = GUIframe.topRightContainer:get_x(), GUIframe.bottomRightTabs:get_y()
  GUIframe.resizeRight:move(x - rW, y - rH / 2)
  x = (GUIframe.topContainer:get_width() - rW) / 2
  if GUIframe.sides.left ~= "hidden" then
    x = x + GUIframe.topLeftContainer:get_width()
  end
  y = GUIframe.topContainer:get_height()
  GUIframe.resizeTop:move(x, y)
  y = GUIframe.bottomContainer:get_y()
  GUIframe.resizeBottom:move(x, y - rH)
end

-- enables the resize label for the given side and shows all associated containers if hidden

function GUIframe.enable(side)
  if not GUIframe.initialized then
    error("GUIframe not initialized", 2)
  end
  if not table.contains(sides, side) then
    error("GUIframe.enable: invalid side", 2)
  end
  local cons = side_containers[side]
  for _, con in ipairs(cons) do
    GUIframe[con]:show()
    for _, win in pairs(GUIframe[con].windowList) do
      -- loop can be removed after Geyser fix comes in
      if win.active then
        win:show()
      end
    end
  end
  if table.contains({"left", "right"}, side) then
    setBorder(side, GUIframe[cons[1]]:get_width() + configs.borderOffset)
  else
    setBorder(side, GUIframe[cons[1]]:get_height() + configs.borderOffset)
  end
  GUIframe["resize" .. side:title()]:show()
  GUIframe.sides[side] = "enabled"
  refresh()
end

-- disables and hides the resize label for the given side, and hides all associated containers if indicated

function GUIframe.disable(side, hide)
  if not GUIframe.initialized then
    error("GUIframe not initialized", 2)
  end
  if not table.contains(sides, side) then
    error("GUIframe.disable: invalid side", 2)
  end
  local cons = side_containers[side]
  GUIframe.sides[side] = "disabled"
  if hide then
    for _, con in ipairs(cons) do
      GUIframe[con]:hide()
      for _, win in pairs(GUIframe[con].windowList) do
        -- loop can be removed after Geyser fix comes in
        if win.type == "mapper" then
          win:hide()
        end
      end
    end
    local border = _G["setBorder" .. side:title()]
    border(0)
    GUIframe.sides[side] = "hidden"
  end
  GUIframe["resize" .. side:title()]:hide()
  refresh()
end

-- adds a Geyser window or container to the given container, with a tab showing the given name if applicable

function GUIframe.addWindow(window, name, container, hideText)
  if not GUIframe.initialized then
    config()
  end
  if type(container) == "table" then
    container = container.name
  end
  local con, tabs = get_containers(container)
	if not window then
		error("GUIframe.addWindow: invalid window", 2)
	end
  if not con then
    error("GUIframe.addWindow: invalid container name", 2)
  end
  if not name then
    error("GUIframe.addWindow: name argument required", 2)
  end
  -- remove window from any containers
  for _, tcon in ipairs(container_names) do
    if table.contains(GUIframe[tcon].windows, window.name) then
      GUIframe.removeWindow(name, tcon)
    end
  end
  deselectContainer(con, tabs)
  -- add tab for window, if applicable
  if tabs then
    local showText = not hideText
    window.showText = showText
    local lbl =
      Geyser.Label:new({name = name .. "Tab", x = 0, y = 0, width = 10, height = 10}, tabs)
    lbl:setStyleSheet(configs.tabStyle)
    if showText then
      lbl:echo(configs.tabEchoStyle .. "&lt;b&gt;" .. name)
    end
    lbl:setClickCallback("GUIframe.buttonClick", name)
    lbl:setReleaseCallback("GUIframe.buttonRelease", name)
    lbl:setMoveCallback("GUIframe.buttonMove", name)
    GUIframe.tabs[name] = lbl
    adjustTabs(tabs)
  end
  -- add window to container and set size and position
  con:add(window)
  window:resize("100%", "100%")
  window:move(0, 0)
  window:show()
  GUIframe.windows[name] = window
  raiseEvent("sysWindowResizeEvent")
end

-- removes a named Geyser window or container from the named container (using name given in GUIframe.addWindow)

function GUIframe.removeWindow(name, container)
  if not GUIframe.initialized then
    error("GUIframe not initialized", 2)
  end
  if not container then
    container = GUIframe.windows[name].container
  end
  local con, tabs = get_containers(container)
  if not con or not table.contains(container_names, con.name) then
    error("GUIframe.removeWindow: invalid container name", 2)
  end
  if not name then
    error("GUIframe.removeWindow: name argument required", 2)
  end
  if tabs then
    local lbl = tabs.windowList[name .. "Tab"]
    if lbl then
      tabs:remove(lbl)
      adjustTabs(tabs)
      lbl:hide()
    end
  end
  local window = GUIframe.windows[name]
  con:remove(window)
  window:hide()
end

-- saves the current GUI setup, including the size of the different containers and what windows go in which container

function GUIframe.saveSettings()
  if not GUIframe.initialized then
    error("GUIframe not initialized", 2)
  end
  local saveTbl = {}
  local w, h = GUIframe.topLeftContainer:get_width(), GUIframe.bottomLeftTabs:get_y()
  saveTbl.left = {w = w, h = h}
  w, h = GUIframe.topRightContainer:get_width(), GUIframe.bottomRightTabs:get_y()
  saveTbl.right = {w = w, h = h}
  w, h = GUIframe.topContainer:get_width(), GUIframe.topContainer:get_height()
  saveTbl.top = {w = w, h = h}
  w, h = GUIframe.bottomContainer:get_width(), GUIframe.bottomContainer:get_height()
  saveTbl.bottom = {w = w, h = h}
  -- get added windows and containers they are assigned to
  local windows = {}
  local text = {}
  for k, v in pairs(GUIframe.windows) do
    local con = v.container.name
    windows[con] = windows[con] or {}
    table.insert(windows[con], k)
    text[con] = text[con] or {}
    text[con][k] = v.showText
  end
  -- reorder windows to match tab order for tabbed containers
  for con, wins in pairs(windows) do
    if con:find("Left") or con:find("Right") then
      local tabs = GUIframe[con].tabs.windows
      local new = {}
      for k, v in ipairs(tabs) do
        local wname = v:gsub("Tab", "")
        table.insert(new, {wname, text[con][wname]})
      end
      windows[con] = new
    end
  end
  saveTbl.windows = windows
  saveTbl.sides = GUIframe.sides
  table.save(getMudletHomeDir() .. "/GUIframeSave.lua", saveTbl)
end

-- loads GUI setup from a previous save

function GUIframe.loadSettings(redraw)
  if not GUIframe.initialized then
    error("GUIframe not initialized", 2)
  end
  local saveTbl = {}
  local path = getMudletHomeDir() .. "/GUIframeSave.lua"
  path = path:gsub("\\", "/")
  mainW, mainH = getMainWindowSize()
  if not io.exists(path) then
    debugc("GUIframe.loadSettings: save file doesn't exist.")
    return
  end
  table.load(path, saveTbl)
  resizeContainers("left", saveTbl.left.w, saveTbl.left.h)
  resizeContainers("right", mainW - saveTbl.right.w, saveTbl.right.h)
  resizeContainers("top", saveTbl.top.w, saveTbl.top.h)
  resizeContainers("bottom", saveTbl.bottom.w, mainH - saveTbl.bottom.h)
  for con, wins in pairs(saveTbl.windows) do
    for _, name in ipairs(wins) do
      if type(name) == "string" then
        GUIframe.addWindow(GUIframe.windows[name], name, con)
      else
        local n, s = name[1], not name[2]
        GUIframe.addWindow(GUIframe.windows[n], n, con, s)
      end
    end
  end
  for side, state in pairs(saveTbl.sides) do
    if state == "enabled" then
      GUIframe.enable(side)
    elseif state == "disabled" then
      GUIframe.disable(side, false)
    elseif state == "hidden" then
      GUIframe.disable(side, true)
    end
  end
  -- force redraw of screen
  if redraw then
    setBackgroundColor(1, 1, 1)
    setBackgroundColor(0, 0, 0)
  end
end

-- can be called to force the script to run its config function again

function GUIframe.reinitialize()
  config()
end

-- can be called to activate a given tab without clicking on it

function GUIframe.activate(name)
  if not GUIframe.initialized then
    error("GUIframe not initialized", 1)
  end
  local window = GUIframe.windows[name]
  if window then
    local con, tabs = get_containers(window.container.name)
    -- hide and unhighlight other windows and tabs
    deselectContainer(con, tabs)
    -- show selected window
    window:show()
    window.active = true
    -- highlight selected tab
    if window.showText then
      GUIframe.tabs[name]:echo(configs.tabEchoStyle .. "&lt;b&gt;" .. name)
    end
  end
end

-- can be called to apply a style to a given tab

function GUIframe.styleTab(name, style)
  if not GUIframe.initialized then
    error("GUIframe not initialized", 1)
  end
  local tab = GUIframe.tabs[name]
  if tab then
    tab:setStyleSheet(style)
  end
end

-- internally used function to handle button click callbacks

function GUIframe.buttonClick(name, event)
  if not GUIframe.initialized then
    error("GUIframe not initialized", 2)
  end
  if table.contains(resizeLabels, name) then
    if event.button == "RightButton" then
      local lbl = GUIframe[name]
      lbl.difX, lbl.difY = event.x, event.y
      lbl.savedX, lbl.savedY = getMousePosition()
      GUIframe[name].isClicked = true
    end
  elseif event.button == "LeftButton" then
    local window = GUIframe.windows[name]
    local con, tabs = get_containers(window.container.name)
    -- hide and unhighlight other windows and tabs
    deselectContainer(con, tabs)
    -- show selected window
    window:show()
    window.active = true
    -- highlight selected tab
    if window.showText then
      GUIframe.tabs[name]:echo(configs.tabEchoStyle .. "&lt;b&gt;" .. name)
    end
  elseif event.button == "RightButton" then
    local window, tab = GUIframe.windows[name], GUIframe.tabs[name]
    tab.savedX, tab.savedY = getMousePosition()
    tab.difX, tab.difY, tab.isClicked = event.x, event.y, true
    -- force update of coords for all tabs and tab containers
    GUIframe.tabCoords = {}
    for _, name in ipairs(tab_names) do
      get_window_coords(GUIframe[name], true)
      for tname, tab in pairs(GUIframe[name].windowList) do
        get_window_coords(tab, true)
      end
    end
  end
  raiseEvent("GUIframe.buttonClick", name, event)
end

-- internally used function to handle button release callbacks

function GUIframe.buttonRelease(name, event)
  if not GUIframe.initialized then
    error("GUIframe not initialized", 2)
  end
  if table.contains(resizeLabels, name) then
    if event.button == "RightButton" then
      local lbl = GUIframe[name]
      lbl.savedX, lbl.savedY, lbl.difX, lbl.difY, lbl.isClicked = nil, nil, nil, nil, false
    end
  elseif event.button == "RightButton" then
    local window, tab = GUIframe.windows[name], GUIframe.tabs[name]
    local con, tabs = get_containers(window.container.name)
    tab.difX, tab.difY, tab.savedX, tab.savedY, tab.isClicked = nil, nil, nil, nil, false
    hideWindow("show_container")
    for _, tname in ipairs(tab_names) do
      local info = GUIframe[tname]
      if info.mouse_over then
        local pos = info.space_pos
        info.mouse_over = nil
        GUIframe.addWindow(window, name, tname:gsub("Tabs", ""), not window.showText)
        if pos then
          reorderTabs(info, tab.name, pos)
          adjustTabs(info)
        end
      end
    end
    adjustTabs(tabs)
  end
  raiseEvent("GUIframe.buttonRelease", name, event)
end

-- internally used function to handle button move callbacks

function GUIframe.buttonMove(name, event)
  if not GUIframe.initialized then
    error("GUIframe not initialized", 2)
  end
  if table.contains(resizeLabels, name) then
    lbl = GUIframe[name]
    if lbl.isClicked then
      local w, h = getMousePosition()
      w, h = round(w - lbl.difX, 10), round(h - lbl.difY, 10)
      mainW, mainH = getMainWindowSize()
      local side, cW, cH, rX, rY
      local minX = GUIframe.sides.left ~= "hidden" and GUIframe.topLeftContainer:get_width() or 0
      local maxX = GUIframe.sides.right ~= "hidden" and GUIframe.topRightContainer:get_x() or mainW
      local minY = GUIframe.sides.top ~= "hidden" and GUIframe.topContainer:get_height() or 0
      local maxY = GUIframe.sides.left ~= "hidden" and GUIframe.bottomContainer:get_y() or mainH
      local mid, min, max = GUIframe.topContainer:get_width(), math.min, math.max
      local tabH, rH, rW = configs.tabHeight, configs.resizeHeight, configs.resizeWidth
      w, h = max(w, 0), max(h, 0)
      -- specify position of resize labels and size of containers
      local info =
        {
          resizeLeft =
            {
              side = "left",
              x = min(w, maxX - rW),
              y = min(max(h + rH / 2, tabH), mainH - tabH) - rH / 2,
              w = min(w, maxX - rW),
              h = min(max(h + rH / 2, tabH), mainH - tabH),
            },
          resizeRight =
            {
              side = "right",
              x = min(max(w, minX), mainW),
              y = min(max(h + rH / 2, tabH), mainH - tabH) - rH / 2,
              w = min(max(w, minX), mainW - rW) + rW,
              h = min(max(h + rH / 2, tabH), mainH - tabH),
            },
          resizeTop =
            {
              side = "top",
              x = minX + (mid - rW) / 2,
              y = min(h, maxY - rH),
              w = maxX - minX,
              h = min(h, maxY - rH),
            },
          resizeBottom =
            {
              side = "bottom",
              x = minX + (mid - rW) / 2,
              y = min(max(h, minY) - rH, mainH),
              w = maxX - minX,
              h = min(max(h, minY) + rH, mainH),
            },
        }
      info = info[name]
      lbl:move(info.x, info.y)
      resizeContainers(info.side, info.w, info.h)
    end
  else
    local window, tab = GUIframe.windows[name], GUIframe.tabs[name]
    local con, tabs = get_containers(window.container.name)
    local x, y = getMousePosition()
    local over_con, over_tab
    if tab and tab.isClicked then
      moveWindow(tab.name, x - tab.difX, y - tab.difY)
      -- check to see if mouse is over any tab containers
      for _, tcon in ipairs(tab_names) do
        if check_overlap(tcon, x, y) then
          over_con = tcon
          GUIframe[tcon].mouse_over = true
          local info = GUIframe.tabCoords[tcon]
          local tx, ty, tw, th = info.x, info.y, info.w, info.h
          createLabel("show_container", 0, 0, 0, 0, 1)
          moveWindow("show_container", tx, ty)
          resizeWindow("show_container", tw, th)
          setLabelStyleSheet(
            "show_container",
            [[
                        background-color: black;
                        border: 2px solid white;]]
          )
          showWindow("show_container")
          lowerWindow("show_container")
          -- check to see if mouse is over any tabs
          for tname, info in pairs(GUIframe.tabs) do
            if tname ~= name and check_overlap(info, x, y) then
              over_tab = info.name
              local windows = GUIframe[tcon].windows
              local index = table.index_of(windows, over_tab)
              makeSpace(GUIframe[tcon], tab, index)
              break
            end
          end
          break
        end
      end
      -- remove any unnecessary spaces in tab containers
      for _, name in ipairs(tab_names) do
        if name ~= over_con then
          adjustTabs(GUIframe[name])
          GUIframe[name].mouse_over = nil
        end
      end
    end
  end
  raiseEvent("GUIframe.buttonMove", name, event)
end

-- internally used function to handle sysWindowResizeEvent

function GUIframe.eventHandler(event, ...)
  if event == "sysWindowResizeEvent" and GUIframe.initialized then
    refresh()
  end
end

registerAnonymousEventHandler("sysWindowResizeEvent", "GUIframe.eventHandler")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>CSSMan</name>
				<packageName></packageName>
				<script>-- CSSMan by Vadi. Public domain.

CSSMan = {}
CSSMan.__index = CSSMan

function CSSMan.new(stylesheet)
  local obj  = { stylesheet = {} }
  setmetatable(obj,CSSMan)
  local trim = string.trim

  assert(type(stylesheet) == "string", "CSSMan.new: no stylesheet provided. A possible error is that you might have used CSSMan.new, not CSSMan:new")

  for line in stylesheet:gmatch("[^\r\n]+") do
    local attribute, value = line:match("^(.-):(.-);$")
    if attribute and value then
      attribute, value = trim(attribute), trim(value)
      obj.stylesheet[attribute] = value
    end
  end

  return obj
end

function CSSMan:set(key, value)
  self.stylesheet[key] = value
end

function CSSMan:get(key)
  return self.stylesheet[key]
end

function CSSMan:getCSS(key)
  local lines, concat = {}, table.concat
  for k,v in pairs(self.stylesheet) do lines[#lines+1] = concat({k,": ", v, ";"}) end
  return concat(lines, "\n")
end

function CSSMan:gettable()
  return self.stylesheet
end

function CSSMan:settable(tbl)
  assert(type(tbl) == "table", "CSSMan:settable: table expected, got "..type(tbl))

  self.stylesheet = tbl
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Logging</name>
				<packageName></packageName>
				<script>-- Das Ziel des Avalet-Loggers ist, eine Möglichkeit zu haben, aus verschiedenen
-- Quellen Ausgaben in verschiedene Dateien umzuleiten. Um diese dann optional in den
-- Tabs auf der Oberfläche anzeigen zu können.
-- Quellen für diese Ausleitung sind beispielsweise: 
-- --&gt; Trigger
-- --&gt; ATCP
-- --&gt; Logging-Ausgaben im Code für Debugging und Error-Logging im Betrieb
-- Und zwar vorzugsweise sowohl aus Avalet heraus als auch durch eventuelle
-- Sub-Module.
-- Funktionen sind also:
-- --&gt; Eine Datei angeben zu können, die innerhalb des Profils gespeichert wird,
--     und in die dann die Logausgaben irgendwie in geschickter Weise (Dateigröße?)
--     rausgeschrieben werden.
-- --&gt; Einen Tab im Frontend anlegen können, in dem die Log-Ausgabe, also der Inhalt
--     der Datei, in einer Mini-Konsole angezeigt wird. (Muss es nicht geben, einfach
--     in eine Datei loggen können sollte auch gehen.)
-- --&gt; Aus den verschiedenen Quellen in den entsprechenden Logger reinschreiben zu können.
-- --&gt; Ein intelligenter Umgang mit den Dateien und dem verwendeten Speicher.
--
-- Das Logging (inklusive auch von Triggern, Timern etc.) basiert erstmal auf einer
-- Arbeit vom User Wyd aus dem Mudlet-Forum, die ich unter dieser Adresse gefunden habe:
-- https://forums.mudlet.org/viewtopic.php?t=1424
--
-- Anpassungen von Marco Steffens


Logger = Logger or {
		_currFileNum = 0,

		_fileName = nil,

		_keepOpen = {}
}

function Logger:getLogDirectory()
	if string.char(getMudletHomeDir():byte()) == "/" then _sep = "/" else  _sep = "\\" end
	local logdir = getMudletHomeDir() ..  _sep .. "log" .. _sep
  -- Marco Steffens: Es gab Probleme mit Leerzeichen im Pfad unter Linux. 
  -- Das hier ist der Versuch, das Problem zu lösen. Indem das Leerzeichen
  -- mit einem "\" maskiert wird. Alternativ müsste man das mit Anführungs-
  -- zeichen um den Pfad rum lösen.
  if _sep == "/" then
    string.gsub(logdir, " ", "\ ")
  end
  
	return logdir
end

function Logger:echo(message)
	cecho("\n&lt;red&gt;Logger: ")
	cecho("&lt;white&gt;" .. message)
end

function Logger:Log(file, val, options)
	options = options or Logger.options or {}

	local line = ""
  if table.contains(options, "timestamp") then
		local time_format = "'['dd'.'MM'.'yyyy' - 'hh':'mm':'ss'.'zzz]: "
		line = line .. getTime(true, time_format)
	end

	if table.contains(options, "split") then
		local maxSize = options.split
		self:_checkFileSize(file, maxSize)
	end
	
	local keepopen = table.contains(options, "keepOpen")

	local f
	
	if not self._keepOpen[file] then
		local filename = self:getLogDirectory()  .. file .. ".txt"
		f = io.open(filename, "a+")
		self._keepOpen[file] = f
	else
		f = self._keepOpen[file]
	end

	line = line .. val
	f:write(line .. "\n")

	if not keepopen then
		self:_closeLog(file)
	end
end

function Logger:CloseLog(file)
	if file then
		self:_closeLog(file)
	else
		for f, _ in pairs(self._keepOpen) do
			self:_closeLog(f)
		end
	end
end

function Logger:SearchLog(file, pattern)
	self:_closeLog(file) -- close the log if its open, so we can access it

	local filename = self:getLogDirectory() .. file .. ".txt"
	if not io.exists(filename) then
		self:echo("File '" .. file .. "' does not exist!")
		return
	end

	local counter = 0

	local numBackups = self:_getCurrentFileNumber(file)

	Logger:echo("Searching for '&lt;green&gt;" .. pattern .. "&lt;white&gt;' in file '" .. file .. "'")
	
	local t = 1;
	local lines = 0
	local r = rex.new(pattern)

	while t &lt;= numBackups do
		local bfilename = self:getLogDirectory() .. file .. "." .. tostring(t) .. ".txt"
		local f = io.open(bfilename, "r")

		for line in f:lines() do
			lines = lines + 1
			if r:match(line) then
				cecho("\n&lt;grey&gt;" .. line .. "  &lt;white&gt;(in " .. file .. "." .. tostring(t) .. ".txt)")
				counter = counter + 1
			end
		end

		f:close()

		t = t + 1
	end

	local f = io.open(filename, "r")

	for line in f:lines() do
		lines = lines + 1
		if r:match(line) then
			cecho("\n&lt;grey&gt;" .. line .. "  &lt;white&gt;(in " .. file .. ".txt)")
			counter = counter + 1
		end
	end

	f:close()

	Logger:echo("Term matched " .. counter .. " times in " .. lines .. " lines.")
end

-- Hinzugefügt von Marco Steffens
function Logger:logFileExists(file)
  self:_closeLog(file) -- close the log if its open, so we can access it
	local filename = self:getLogDirectory() .. file .. ".txt"
	if not io.exists(filename) then
    return false
	else
    return true
  end
end


-- Hinzugefügt von Marco Steffens
function Logger:ReadLog(file)
	self:_closeLog(file) -- close the log if its open, so we can access it
	debugc("File: "..self:getLogDirectory() .. file .. ".txt\n")
	local filename = self:getLogDirectory() .. file .. ".txt"
	if not io.exists(filename) then
		self:echo("File '" .. file .. "' does not exist!")
		return
	else
		local f = io.open(filename, "r")
		content = ""
    lastdate = ""
		for line in f:lines() do
			if line ~= "" then
				-- "'['dd'.'MM'.'yyyy' - 'hh':'mm':'ss'.'zzz]: "
				-- "[05.04.2020 - 16:45:00.283]: "
				--x = string.gsub("hello world", "%w+", "%0 %0", 1)
				-- ^\[\d{2}\.\d{2}\.\d{4} - (\d{2}:\d{2}:\d{2}).\d{3}\]: (.*)$
				-- "^%[%d{2}%.%d{2}%.%d{4} %- (%d{2}:%d{2}:%d{2})%.%d{3}%]: (.*)$", "[%0]: %1", 1)
				-- %^ITALIC%^schelmisch%^NO_ITALIC%^
        date = string.gsub(line, "^%[(%d+%.%d+%.%d+) %- %d+:%d+:%d+%.%d+%]: .*$", "%1", 1)
        if lastdate ~= date then
          content = content .. "\n\n~~~~~~~~~~~~~~~~~~~~ " .. date .. " ~~~~~~~~~~~~~~~~~~~~\n"
          lastdate = date
        end
				line = string.gsub(line, "^%[%d+%.%d+%.%d+ %- (%d+:%d+:%d+)%.%d+%]: (.*)$", "%1: %2", 1)
				content = content .. "\n" .. line
			end
		end
		return content
	end
end




-- TEST

-- Hinzugefügt von Marco Steffens
function Logger:ReadLogWithLineLimit()
  --file = "C:/Users/mstef/.config/mudlet/profiles/Ava - Rofhessa - DEV\log\Sagen.txt"
  file = "Sagen"
	self:_closeLog(file) -- close the log if its open, so we can access it
	debugc("File: "..self:getLogDirectory() .. file .. ".txt\n")
	local filename = self:getLogDirectory() .. file .. ".txt"
	if not io.exists(filename) then
		self:echo("File '" .. file .. "' does not exist!")
		return
	else
		local f = io.open(filename, "r")
		content = ""
    
    --f:seek("end",-24)
    --content = f:read("*a")
    
    --content = f:lines()
    lineCounter = 0
 		 for line in f:lines() do 
  			if line ~= "" then
       lineCounter = lineCounter + 1 
      end
--				-- "'['dd'.'MM'.'yyyy' - 'hh':'mm':'ss'.'zzz]: "
--				-- "[05.04.2020 - 16:45:00.283]: "
--				--x = string.gsub("hello world", "%w+", "%0 %0", 1)
--				-- ^\[\d{2}\.\d{2}\.\d{4} - (\d{2}:\d{2}:\d{2}).\d{3}\]: (.*)$
--				-- "^%[%d{2}%.%d{2}%.%d{4} %- (%d{2}:%d{2}:%d{2})%.%d{3}%]: (.*)$", "[%0]: %1", 1)
--				-- %^ITALIC%^schelmisch%^NO_ITALIC%^
--				line = string.gsub(line, "^%[%d+%.%d+%.%d+ %- (%d+:%d+:%d+)%.%d+%]: (.*)$", "%1: %2", 1)
--				content = content .. "\n" .. line
--			end
		  end
    content = tostring(lineCounter)
		return content
	end--if not io.exists(filename) then
end --function Logger:ReadLogWithLineLimit()

--- TEST ENDE





function Logger:LogSection(file, options)
		if self.trigger_id then 
			Logger:echo("Already logging a section. Do Logger:StopLogging() first")
			return
		end

		options = options or {}
		
		if not table.contains(options, "keepOpen") then table.insert(options, "keepOpen") end
		
		local splitSize = 0
		if table.contains(options, "split") then
			splitSize = options.split
			self:_checkFileSize(file, splitSize)
		end

		-- we don't want to pass this on
		options.split = nil

		self:Log(file, "\n\n", {"keepOpen"})
		self:Log(file, "[[[START OF SECTION]]]", {"timestamp", "keepOpen"})

		self.logging_file = file
		self.options = options
		self.trigger_id = tempRegexTrigger(".*", [[ Logger:Log("]] .. file .. [[", matches[1], Logger.options)]])	
		
		if splitSize ~= 0 then
			self.splitSize = splitSize
			enableTimer("Check File Size")
		end
		Logger:echo("Started logging!")
end

function Logger:StopLogging()
	if self.trigger_id then
		killTrigger(self.trigger_id)
		self:_closeLog(self.logging_file)
		self.trigger_id = nil
		self.options = nil
		self.splitSize = 0
		disableTimer("Check File Size")
		self:Log(self.logging_file, "[[[END OF SECTION]]]", {"timestamp"})

		self.logging_file = nil
		Logger:echo("Logging stopped!")
	end
end

function Logger:_checkFileSize(file, maxSize)
	--Check whether our file size is to big
	if self:_getFileSize(file) &gt;= maxSize then
		-- if it is, we need to rename the current file.txt to file.n.text
		self:_closeLog(file)
		local t = self:_getNextFileNumber(file)
		os.rename(self:getLogDirectory() .. file .. ".txt", self:getLogDirectory() .. file .. "." .. t .. ".txt")
	end
end

function Logger:_getFileSize(file)
	local filename = self:getLogDirectory()  .. file .. ".txt"
	local f = io.open(filename, "r")

	if not f then return 0 end
	local size = f:seek("end")    -- get file size
  	
	f:close()
	return size / 1024 -- We want size in kb's, not bytes
end

function Logger:_getCurrentFileNumber(file)
	local t = 1
	local stop = false
	while not stop do
		local filename = self:getLogDirectory() .. file .. "." .. tostring(t) .. ".txt"
		if io.exists(filename) then
			t = t + 1
		else
			stop = true
		end
	end

	self._currFileNum = t - 1

	return self._currFileNum
end

function Logger:_getNextFileNumber(file)
	local current = self:_getCurrentFileNumber(file)
	self._currFileNum = current + 1
	return self._currFileNum
end


function Logger:_closeLog(file)
	if self._keepOpen[file] then
		self._keepOpen[file]:close()
		self._keepOpen[file] = nil
	end
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Misc Functions</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>Utility Functions</name>
				<packageName></packageName>
				<script>-- Hilfsfunktionen
--function readFileFromFS(path, mode)
--	data = {}
--	file = io.open (path, mode)
--	data = yajl.to_value(file:read())
--	file:close()
--	return data
--end
--
--function writeDataToFS(path, data, mode)
--  debugc("\n&lt;magenta&gt;writeDataToFS()\n")
--  debugc("&lt;magenta&gt;path: " .. path .. "\n")
--  --cecho("&lt;magenta&gt;data: " .. tostring(data) .. "\n")
--  --cecho("&lt;magenta&gt;mode: " .. tostring(mode) .. "\n")
--
--	file = io.open (path, mode)
--	file:write(yajl.to_string(data))
--	file:flush()
--	file:close()
--	return true
--end

-- Formats numbers with german thousands seperator
-- Code originally written by Richard Warburton http://richard.warburton.it
function thousands(n)
  local left,num,right = string.match(n,'^([^%d]*%d)(%d*)(.-)$')
  return left..(num:reverse():gsub('(%d%d%d)','%1\.'):reverse())..right
end

function resizeEvent( event, x, y )
  echo("RESIZE EVENT: event="..event.." x="..x.." y="..y.."\n")
end

function resizeEvent( event, x, y, windowname )
  echo("RESIZE EVENT: event="..event.." x="..x.." y="..y.." windowname="..windowname.."\n")
end

</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<Script isActive="yes" isFolder="no">
			<name>CONFIG</name>
			<packageName></packageName>
			<script>avalonUI = avalonUI or {}

--[[Schriftart für die Seiten-Bereiche. "main" bedeutet, dass die Schriftart
des Hauptfensters verwendet wird. (Diese ist einstellbar unter "Settings" --&gt; "Main display".)
Eine Liste der hier einstellbaren Schriftarten wird mit dem Befehl "lua display(getAvailableFonts())"
angezeigt. Änderungen erfordern Neustart von Mudlet.]]
avalonUI.font = "main"
--avalonUI.font = "Bitstream Vera Sans Mono"

avalonUI.infoBoxFontSize = 10
avalonUI.chatFontSize = 10
avalonUI.chatTabFontSize = 9


-- Ausrichtung der Timer-Fortschrittsbalken
-- (Änderung erst durch Neustart von Mudlet)
avalonUI.timerOrientation = "goofy"      -- fancy! Rückschrittsbalken!
--avalonUI.timerOrientation = "horizontal" -- doofe Fortschrittsbalken

--avalonUI.CounterColor = "gold"  -- geht so nicht, wird im css festgelegt
--avalonUI.GaugeFrontColorTimer = "green"
--avalonUI.GaugeFrontColorTimer = "#254b50" --So eine Art Silvergrey
--angeblich harmonisches Farbset:
avalonUI.GaugeFrontColorTimer = "#00575d" --Blue Stone
--avalonUI.GaugeFrontColorTimer = "#00929c" --Persian Green
--avalonUI.GaugeFrontColorTimer = "#66f5ff" --Aquamarine
--avalonUI.GaugeFrontColorTimer = "#993f00" --Brown
--avalonUI.GaugeFrontColorTimer = "#ff6900" --Orange
--avalonUI.GaugeFrontColorTimer = "#ffa566" --Atomic Tangerine

avalonUI.GaugeFrontColorTP = "darkred"
--avalonUI.GaugeFrontColorAP = "darkgoldenrod"
avalonUI.GaugeFrontColorAP = "#a35a00"
avalonUI.GaugeFrontColorZP = "darkblue"
avalonUI.GaugeFrontColorMana = "#4b0082" --war: "purple"
avalonUI.MiniConsoleCenterFontSize = 9
avalonUI.MiniConsoleTabsFontSize = 9


avalonUI.settings = avalonUI.settings or {}
avalonUI.settingsSettings = settingsSettings or {
  isSettingsDialogVisible = false,
  tabs = {"Diverses","Chats-Tabs","Farben","Über Avalet"},
  width = 800, -- auch möglich: "20%"
  height = 600,
  current = nil,
}
  



avalonUI.CSS = {}

--  background-color: black;
--  border-color: DarkSlateBlue;
--  border-style: double;
--  border-radius: 1px;
--  border-width: 1px;
--  margin: 1px;
--  qproperty-alignment: 'AlignCenter | AlignCenter';
--  display:none;
--  visibility: hidden;
avalonUI.CSS.base = CSSMan.new([[
	background-color: rgba(0,0,0,100);
	border-style: solid;
	border-width: 1px;
	border-radius: 10px;
	border-color: white;
	font: TypeWriter;
	margin-left: 10px;
	margin-right: 10px;
  
]])
  
avalonUI.CSS.frameworkTabs = CSSMan.new([[
  display:none;
  visibility: hidden;
  margin: 0pt;
  
]])
  
 -- CSS Boxes
avalonUI.CSS.boxCSS = CSSMan.new([[
	background-color: rgba(0,0,0,100);
	border-style: solid;
	border-width: 1px;
	border-radius: 10px;
	border-color: white;
	font: TypeWriter;
	margin: 10px;
]])

 -- CSS Overlay Boxes
avalonUI.CSS.overlayCSS = CSSMan.new([[
	background-color: rgba(50,50,50,200);
	border-style: solid;
	border-width: 1px;
	border-radius: 10px;
	border-color: white;
	font: TypeWriter;
	margin: 10px;
]])

-- CSS Tab-Element ---------------------------------------------

avalonUI.CSS.tabElementFooterCSS = CSSMan.new([[
	background-color: rgb(20,0,20);
	border-bottom-left-radius: 10px;
	border-bottom-right-radius: 10px;
]])

-- Each window actually has two labels. One for the light blue background, and another for the dark blue center. This will create that dark blue center. 
avalonUI.CSS.tabElementCenterCSS = CSSMan.new([[
	background-color: rgba(0,0,0,100);
	border-radius: 10px;
	margin: 5px;
]])

-- Now we create the windows that appear when each tab is clicked. Each window has two labels, one atop the other. The first, which we'll create here, has rounded edges on its bottom. 
--	background-color: rgb(20,0,20);
avalonUI.CSS.tabElementAtopCSS = CSSMan.new([[
	background-color: rgb(0,0,0);
	border-bottom-left-radius: 10px;
	border-bottom-right-radius: 10px;
]])

-- The second label serves as the window's center and has rounded edges on all sides. And a margin of 5px from it's parent, the label we just created. When adding stuff to your windows, this is the label you'll want to use. menu.&lt;tabname&gt;center
avalonUI.CSS.tabElementCenterTabCSS = CSSMan.new([[
	background-color: rgba(0,0,0,100);
	border-radius: 10px;
	margin: 5px;
]])

-- Hier werden die Tabs und die Seiten dazu erzeugt.
-- Erzeugt einen Tab für jeden Eintrag in der Menu-Liste
-- Stylesheet für jeden Tab
--background-color: ]]..menu.color1..[[;
--background-color: rgb(20,0,20);
avalonUI.CSS.MenuTabCSS = CSSMan.new([[
	background-color: rgb(0,0,0);
  border: 1px solid white;
  border-radius: 10px;
	margin-right: 1px;
	margin-left: 1px;
]])
--purple
--	border-radius: 10px;
avalonUI.CSS.MenuTabCurrentCSS = CSSMan.new([[
	background-color: rgba(52,128,23,255);
  color: black;
  font: bold;
  border: 2px solid white;
  border-radius: 10px;
	margin-right: 1px;
	margin-left: 1px;
]])
--rgb(50,0,50);
avalonUI.CSS.MenuTabMarkedCSS = CSSMan.new([[
	background-color: rgba(52,128,23,120);
  border: 1px solid white;
  border-radius: 10px;
	margin-right: 1px;
	margin-left: 1px;
]])

-- CSS Top Menu ------------------------------------------------

--	border-width: 1px;
--	border-color: white;
--	margin: 2px; 
--	border-style: solid;
--	border-radius: 7;
--	padding: 3px;
-- 	qproperty-alignment: 'AlignTop';
avalonUI.CSS.MenuLabelCSS = CSSMan.new([[
	background-color: rgba(0,0,0,100);
	font-weight: bold;
	font-size: 16pt;
	color: white;
]])
--avalonUI.TopMenuOptions:echo([[&lt;p style="font-size:22px"&gt;&lt;b&gt;&lt;font color="white"&gt;&amp;#9881;]])

-- CSS Counter -------------------------------------------------

--background-color: rgb(50,0,50);
--background-color: rgb(98,119,0);
avalonUI.CSS.counterCSS = CSSMan.new([[
	background-color: black;
	border-style: solid;
	border-width: 1px;
	border-radius: 10px;
	border-color: black;
	font: TypeWriter;
	margin: 5px;
]])

-- CSS Hunger-/Durst-/Alk-Anzeige ------------------------------

avalonUI.CSS.HDACSS = CSSMan.new([[
	background-color: rgb(0,0,0);
	border-style: solid;
	border-width: 1px;
	border-radius: 2px;
	border-color: white;
	margin-right: 1px;
	margin-left: 1px;
]])

avalonUI.CSS.HDAGreenCSS = CSSMan.new([[
	background-color: rgb(0,255,0);
	border-style: solid;
	border-width: 1px;
	border-radius: 10px;
	border-color: white;
	border-top-left-radius: 10px;
	border-top-right-radius: 10px;
	margin-right: 1px;
	margin-left: 1px;
]])

avalonUI.CSS.HDAYellowCSS = CSSMan.new([[
	background-color: rgb(255,255,0);
	border-style: solid;
	border-width: 1px;
	border-radius: 10px;
	border-color: white;
	border-top-left-radius: 10px;
	border-top-right-radius: 10px;
	margin-right: 1px;
	margin-left: 1px;
]])

avalonUI.CSS.HDARedCSS = CSSMan.new([[
	background-color: rgb(255,0,0);
	border-style: solid;
	border-width: 1px;
	border-radius: 10px;
	border-color: white;
	border-top-left-radius: 10px;
	border-top-right-radius: 10px;
	margin-right: 1px;
	margin-left: 1px;
]])

avalonUI.CSS.HDABlankCSS = CSSMan.new([[
	background-color: rgb(0,0,0);
	border-style: solid;
	border-width: 1px;
	border-radius: 2px;
	border-color: white;
	margin-right: 1px;
	margin-left: 1px;
]])

-- CSS Gauges --------------------------------------------------

avalonUI.CSS.GaugeBackCSS = CSSMan.new([[
	background-color: rgba(0,0,0,0);
	border-style: solid;
	border-color: white;
	border-width: 1px;
	border-radius: 5px;
	padding: 5px;
	width: 30%;
	height: 80%;
]])

avalonUI.CSS.GaugeFrontCSS = CSSMan.new([[
	background-color: rgba(0,0,0,0);
	border-style: solid;
	border-color: white;
	border-width: 1px;
	border-radius: 5px;
	padding: 5px;
	width: 30%;
	height: 80%;
]])

--	background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #78bd33, stop: 0.1 #6ebd20, stop: 0.49 #4c9900, stop: 0.5 #387000, stop: 1 #4c9900);
avalonUI.CSS.GaugeTextCSS = CSSMan.new([[
	padding: 5px;
	font-weight: bold;
]])

--	background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #78bd33, stop: 0.1 #6ebd20, stop: 0.49 #4c9900, stop: 0.5 #387000, stop: 1 #4c9900);
avalonUI.CSS.GaugeTimerTextCSS = CSSMan.new([[
	font-weight: bold;
	padding: 50px;
]])
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>initCharacter</name>
			<packageName></packageName>
			<script>--initCharacter()

function avalonUI.initCharacter()

  character = {}
  
  character.name = ""           -- ATCP: AvalonName
  character.vollername = ""     -- ATCP: AvalonVollName
  character.nation = ""           -- wird zwar nicht direkt per atcp übertragen, lässt sich aber aus den kanälen ermitteln
  character.alter = ""          -- ATCP: AvalonAlter
  character.gilde = ""          -- ATCP: AvalonGilde
  character.zuenfte = ""        -- ATCP: AvalonZuenfte
  character.ep = 0             -- ATCP: AvalonEP
  character.level = ""          -- ATCP: AvalonLevel
  character.gesinnung = ""      -- ATCP: AvalonGesinnung
  character.portfolio = ""      -- ATCP: AvalonPortfolio
  character.hunger = ""         -- ATCP: AvalonHunger
  character.durst = ""          -- ATCP: AvalonDurst

  character.alk = ""          -- wird leider nicht übertragen
  character.hangover = false
  character.fluch = 0          -- wird leider nicht übertragen
  character.krankheit = 0          -- wird leider nicht übertragen
  character.vergiftung = 0          -- wird leider nicht übertragen
  --
  character.hoehe = ""          -- ATCP: AvalonHoehe
  character.flucht = ""         -- ATCP: AvalonFlucht
  character.schutz = ""         -- ATCP: AvalonSchutz
  character.gruppenname = ""    -- ATCP: AvalonGruppe
  character.zaubern = 0         -- ATCP: AvalonZaubern
  character.kampf = "0"           -- ATCP: AvalonKampf
  character.angegriffen = ""    -- ATCP: AvalonAngegriffen
  character.getoetet = ""       -- ATCP: AvalonGetoetet
  character.gruppeGetoetet = "" -- ATCP: AvalonGruppeGetoetet
  character.allyGetoetet = ""   -- ATCP: AvalonAllyGetoetet
  --
  character.stats = character.stats or {}
  character.stats.tp = 0        -- ATCP: AvalonTP
  character.stats.tp_max = 0    -- ATCP: AvalonMAXTP
  character.stats.ap = 0        -- ATCP: AvalonAP
  character.stats.ap_max = 0    -- ATCP: AvalonMAXAP
  character.stats.zp = 0        -- ATCP: AvalonSP
  character.stats.zp_max = 0    -- ATCP: AvalonMAXSP
  character.stats.mp = 0        -- ATCP: AvalonMP
  character.stats.mp_max = 0    -- ATCP: AvalonMAXMP
  --
  character.inventarRein = ""	  -- ATCP: AvalonInventarRein
  character.inventarRaus = ""	  -- ATCP: AvalonInventarRaus
  character.behaelterRein = ""	  -- ATCP: AvalonBehaelterRein
  character.behaelterRaus = ""  -- ATCP: AvalonBehaelterRaus
  character.gefuehrt = ""       -- ATCP: AvalonGefuehrt
  character.gesenkt = ""        -- ATCP: AvalonGesenkt
  character.angezogen = ""      -- ATCP: AvalonAngezogen
  character.ausgezogen = ""     -- ATCP: AvalonAusgezogen
  --
  character.lastMove = ""
  
  character.ep_speicher = ""
  
  character.sessionEP = 0
  
  character.bonusEP = 0
  
  character.schildEP = 0
  
  character.loginIsReconnect = false
  
  character.avalonRoomID = ""
  character.avalonRoomHash = ""
  character.istDunkel = ""
  
  character.motion = ""
  
  return character
end

</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>initTimer</name>
			<packageName></packageName>
			<script>-- Timer (und Trigger für Timer)
--
-- HINWEIS: Hier geht es um Timer und Trigger. Wenn hier von TRIGGERN geschrieben
-- wird, dann sind die normalen Mudlet-Trigger gemeint. (Die man sich als Spieler
-- anlegt, um nicht immer alles selber tippen zu müssen.) Wenn hier von TIMERN 
-- geschrieben wird, dann sind normalerweise die Timer gemeint, die auf der 
-- Oberfläche von Avalet angezeigt werden! Die die Laufzeit beispielsweise von 
-- Schutzzaubersprüchen anzeigen. Es sind NICHT die Mudlet-Timer gemeint!
--
-- Hier werden die Daten für die Trigger gesammelt, die letztlich die Timer auf 
-- der Oberfläche erzeugen sollen.
-- In den Funktionen weiter unten werden diese Trigger dann erzeugt. Es gibt (derzeit)
-- vier verschiedene Funktionen, die das tun. Benutzt wird nur eine davon, aber aus 
-- verschiedenen Gründen lasse ich die anderen drin. Und zwar:
-- Trigger können als "temporäre" oder als "permantente" Trigger angelegt werden.
-- "Temporäre" Trigger haben die Eigenschaft, dass sie nicht im Code-Editor (und auch
-- nicht in dieser Datei hier) auftauchen. Außerdem werden sie durch einen Neustart
-- von Mudlet gelöscht und neu erzeugt. Dadurch kann man sie leicht aktualisieren.
-- "Permantente" Trigger stehem in Code-Editor, und können so leichter kontrolliert
-- und beim Entwickeln von Avalet auch leichter modifiziert werden. Sie überstehen
-- aber einen Neustart von Mudlet, und da man sie auch nicht ohne weiteres per Lua
-- löschen kann, ist es sehr viel schwieriger, sie gegebenenfalls zu aktualisieren.
-- Ich habe Funktionen für beides geschrieben, weil ich zum Debuggen die permanenten
-- Trigger verwendet habe, für die ausgelieferte Version von Avalet dann aber wieder
-- auf die temporären Trigger umstelle.
-- Außerdem gibt es jeweils eine Funktion, bei der alle Trigger auf ein mal beim Start
-- von Mudlet bzw. bei der Installation von Avalet erzeugt werden. Also die Start- und
-- die Stop-Trigger für die einzelnen Timer. Und es gibt jeweils eine Funktion, bei der
-- NUR die Start-Trigger bei der Installation erzeugt werden. Die dazugehörigen STOP-
-- Trigger werden dann erzeugt, wenn der Start-Trigger ausgelöst wurde. Und dann werden
-- sie als ONE-TIME-Trigger angelegt, löschen sich also nach einmaligem Auslösen. Das
-- spart rund die Hälfte der Trigger - und da Trigger die ganze Zeit die Texte mitlesen
--  müssen, spart es Laufzeit. 
-- Es gibt also insgesamt vier Funktionen, mit denen die "Trigger für Timer" erzeugt werden.
-- Verwendet wird aber jeweils nur eine. Fürs debugging lass ich die anderen hier drin.
-- Außerdem: Die Trigger werden in eine Trigger-Group namens "AvaletTriggerFuerTimer"
-- geschrieben. Eigentlich kann man eine solche Group von Lua aus erzeugen und die Trigger
-- dann reinschreiben. Ich hatte dabei aber das Problem, dass die Trigger zwar alle 
-- richtig geschrieben wurden und auch aktiv waren. Die Trigger-Group war aber per default
-- deaktiviert. Wodurch auch die in ihr enthaltenen Trigger nicht funktionierten. Die
-- Trigger-Group war erst nach einem Speichern aktivierbar. Letztlich hab ich die Group
-- dann fest in Avalet reingeschrieben. Damit hat dann alles funktioniert. Also NICHT so:
-- permGroup("AvaletTriggerFuerTimer", "trigger")

-- function avalonUI.initTimer()
-- Hier werden die Daten für die Timer gesammelt, aus denen die Trigger erzeugt werden. Und
-- am Ende dieser Funktion werden sie dann auch erzeugt.
-- Die Trigger werden entweder als temporäre oder als permanente Trigger erzeugt, aber in 
-- jedem Fall werden sie "RegexTrigger" sein - die Texte, auf denen die Trigger reagieren
-- sollen, müssen also reguläre Ausdrücke sein. 
-- Außerdem ist es notwendig, die Zeichen zur Maskierung von Sonderzeichen ("\") extra einmal
-- zu maskieren. 
-- Die Angabe einer ["duration"] kann entfallen, der Timer wird dann OHNE Fortschrittsanzeige
-- angezeigt, bis der Stop-Trigger ihn entfernt. (Also die ganze Zeit mit vollen Fortschritts-
-- balken.) In dem Fall ist UNBEDINGT sicher zu stellen, dass das Löschen des Timers auch
-- wirklich funktioniert! Die Trigger MIT Laufzeit werden ebenfalls durch einen STOP-Trigger
-- entfernt, zusätzlich aber auch (derzeit:) 30 Sekunde nach Ende ihrer eingetragenen Laufzeit.
-- Bei den Trigger MIT Laufzeit ist es also möglich, auf einen STOP-String zu verzichten. Der
-- muss in dem Fall aber trotzdem hier reingeschrieben werden, und zwar so: ["stop"] = ""
-- Beim Hinzufügen weiterer Zeilen bitte die alphabetische Sortierung berücksichtigen... 
function avalonUI.initTimer()
  
  local timerStrings = {
    --{["name"]="Name", ["start"]="Start-RegExpr",["stop"]="Stop-RegExpr", ["duration"]="600"},
    --{["name"]="Name", ["start"]="Start-RegExpr",["stop"]="", ["duration"]="600"},
    --{["name"]="Name", ["start"]="Start-RegExpr",["stop"]="Stop-RegExpr"},
    {["name"]="Arkanschild", ["start"]="Du wirst von einem Arkanschild umgeben\\.", ["stop"]="Dein Arkanschild loest sich auf\\.", ["duration"]="600"},
    {["name"]="Blaetterhaut", ["start"]="Deine Haut ist nun mit Blaettern bedeckt, die Dir ein angenehmes Klima|Deine Holzhaut ist nun mit Blaettern bedeckt, die Dir ein angenehmes Klima", ["stop"]="Deine Blaetterhaut loest sich auf\\.", ["duration"]="600"},  
    {["name"]="Blutrausch", ["start"]="Du laesst einen fuerchterlichen Urschrei von Dir. Es scheint so, als .*", ["stop"]="Die roetlichen Manawolken loesen sich auf\\.", ["duration"]="600"},
    {["name"]="Daemonenhaut", ["start"]="Du bist nun vollkommen in eine Daemonenhaut eingehuellt\\.", ["stop"]="Deine Daemonenhaut loest sich auf\\.", ["duration"]="600"},
    {["name"]="Daemonenschwert", ["start"]="Vorsichtig streifst Du mit Deiner Hand ueber \\w+ \\w+\\.", ["stop"]="Dein \\w+ verliert seine magische Kraft\\.", ["duration"]="600"},
    {["name"]="Erdaura", ["start"]="Du hebst Deine Haende, beschreibst einen Halbkreis.*|Die Partikel verdichten sich um Dich\\.", ["stop"]="Dein Staubschleier loest sich auf\\.", ["duration"]="600"},
    {["name"]="EP-Verdoppelung", ["start"]="^Du bekommst nun eine Zeit lang erhoehte Erfahrung\\.$", ["stop"]="", ["duration"]="3600"},
    {["name"]="Feueraura", ["start"]="Du senkst Deine Haende, aber der Schutz der Manawolken.*", ["stop"]="Deine Feueraura loest sich auf\\.", ["duration"]="600"},
    {["name"]="Feueraura III", ["start"]="Die Manawolken verdichten sich um Dich\\.", ["stop"]="Deine Feueraura loest sich auf\\.", ["duration"]="1200"},
    {["name"]="Friedfertigkeit", ["start"]="Du fuehlst Dich nun .* friedfertig\\.", ["stop"]="Du fuehlst Dich wieder kaempferischer, ungestuemer\\.", ["duration"]="600"},
    {["name"]="Holzhaut", ["start"]="Deine Haut sieht nun hoelzern und sehr widerstandsfaehig aus\\.|Deine Blaetterhaut sieht nun hoelzern und sehr widerstandsfaehig aus\\.|Deine Blaetterhaut fuehlt sich nun recht hoelzern an\\.|Deine Haut fuehlt sich nun recht hoelzern an\\.", ["stop"]="Deine Holzhaut loest sich auf\\.", ["duration"]="600"},
    {["name"]="Kampfbeschwoerung", ["start"]="Du wirst von einer heiligen Aura umgeben\\.",["stop"]="Deine heilige Aura loest sich auf\\.", ["duration"]="600"},
    {["name"]="Kampfeslust", ["start"]="Du bekommst so langsam richtig Lust auf ein kleines Kraeftemessen\\.", ["stop"]="Du fuehlst Dich wieder ruhiger, besonnener\\.", ["duration"]="600"},
    {["name"]="Kampfsegen", ["start"]="Du bist motiviert und willig zu kaempfen\\.", ["stop"]="Deine Motivation und Dein Kampfeswille schwinden\\.", ["duration"]="600"},
    {["name"]="Kernschild", ["start"]="Das Glitzern legt sich als schuetzendes Schild ueber Dich\\.", ["stop"]="Dein Kernschild loest sich auf\\.", ["duration"]="1000"},
    {["name"]="Knochenschild", ["start"]="Du erhebst Dich wieder, der wirbelnde Schild aus Knochen umgibt Dich", ["stop"]="Deine schuetzende Knochenwolke loest sich auf\\.", ["duration"]="600"},
    {["name"]="Lebensaura", ["start"]="Du oeffnest die Augen, aber der Schutz der Bluetenblaetter umgibt Dich", ["stop"]="Deine Lebensaura loest sich auf\\.", ["duration"]="600"},
    {["name"]="Lebenssegen", ["start"]="Du wirst von einem inneren Leuchten erfuellt\\.", ["stop"]="Dein inneres Leuchten erlischt wieder\\.", ["duration"]="600"},
    {["name"]="Licht I", ["start"]="Du erzeugst Dir eine kleine Feuerkugel\\.", ["stop"]="Deine Feuerkugel erlischt\\.", ["duration"]="240"},
    {["name"]="Licht II", ["start"]="Du erzeugst Dir eine kleine Leuchtflamme\\.",["stop"]="Deine Leuchtflamme erlischt\\.", ["duration"]="600"},
    {["name"]="Licht III", ["start"]="Ein grosser Lichtbogen breitet sich ueber Deinem Kopf aus\\.", ["stop"]="Dein Lichtbogen verschwindet\\.", ["duration"]="1200"},
    {["name"]="Luftaura", ["start"]="Du bist in den Watteflocken kaum noch auszumachen\\.", ["stop"]="Deine Watteflocken loesen sich auf\\.", ["duration"]="600"},
    {["name"]="Magieaufladung", ["start"]="Du hast einen Teil Deiner regenerativen Energien in Deine Zauber umgelenkt\\.",["stop"]="Deine Energien fliessen wieder normal\\.", ["duration"]="600"},
    {["name"]="Magiertrance", ["start"]="^Die Welt um Dich herum verliert an Bedeutung. Nur noch Deine Zauber sind$",["stop"]="Du erwachst aus Deiner Trance\\.", ["duration"]="600"},
    {["name"]="Manarausch", ["start"]="Dichte Manawolken bilden nun einen gewaltigen Schutz um Dich herum\\.",["stop"]="Dein Manarausch laesst wieder nach\\."},
    {["name"]="Pflanzenblick", ["start"]="Du siehst die Pflanzen um Dich herum jetzt viel klarer\\.", ["stop"]="Dein besonderer Blick fuer die Pflanzen an Deinem Weg verschwindet wieder\\.", ["duration"]="600"},
    {["name"]="Regenerationssegen", ["start"]="Du wirst von einem warmen Leuchten umgeben\\.", ["stop"]="Das Dich umgebende Leuchten erlischt wieder\\.", ["duration"]="600"},
    {["name"]="Schild", ["start"]="Du wirst von einem magischen Schild umgeben\\.",["stop"]="Dein magischer Schild loest sich auf\\.", ["duration"]="600"},
    {["name"]="Schwarzschild", ["start"]="Du wirst von einem magischen Schild umgeben, der Dich besser parieren",["stop"]="Dein Schwarzschild loest sich auf\\.", ["duration"]="600"},
    {["name"]="Segen", ["start"]="^Das Ankh auf (Deiner|Deinem|den)([a-z ,]*)([A-Za-z\\s]+) beginnt\\, schwach zu( leuchten\\.)?", ["stop"]="(Dein|Deine)([a-z ,]*)([A-z\\s]+) verliert .* magische Kraft.", ["duration"]="600"},
    {["name"]="Steinhaut", ["start"]="Du bist nun vollkommen in eine Steinhaut eingehuellt, .*",["stop"]=".*Du befreist Dich von Deiner Steinhaut.*|.*Deine Steinhaut loest sich auf.*|Das hat Deiner Steinhaut den letzten Rest gegeben, sie loest sich auf\\.", ["duration"]="1800"},
    {["name"]="Sternenstaub", ["start"]="Du wirst von Sternenstaub umgeben\\.",["stop"]="Dein Sternenstaub loest sich auf\\.", ["duration"]="600"},
    {["name"]="Todesaura", ["start"]="Du senkst Deine Haende, aber der Schutz der schwarzen Schleier.*|Die schwarzen Schleier verdichten sich um Dich\\.",["stop"]="Deine Todesaura loest sich auf\\.", ["duration"]="600"},
    {["name"]="Todkonvertieren", ["start"]="Du wirst von einem heiligen Schutz umgeben\\.", ["stop"]="Dein heiliger Schutz loest sich auf\\.", ["duration"]="600"},
    {["name"]="Trotz", ["start"]="Du hast nun verbesserte Verteidigungsfertigkeiten\\.", ["stop"]="Deine verbesserten Verteidigungsfertigkeiten schwinden\\.", ["duration"]="600"},
    {["name"]="Vergeltung", ["start"]="Du oeffnest Deine Augen und buendelst Deine Wut\\.", ["stop"]="Die Wut in Dir scheint besiegt\\.", ["duration"]="600"},
    {["name"]="Wasseraura", ["start"]="Es regnet aus der Wolke auf Dich herab.*",["stop"]="Dein Wasserschleier loest sich auf\\.", ["duration"]="600"},
    {["name"]="Weissschild", ["start"]="Du wirst von einem magischen Schild umgeben, der Dich Deinen Gegner .*", ["stop"]="Dein Weissschild loest sich auf\\.", ["duration"]="600"},
    {["name"]="Windhaut", ["start"]="Du bist nun vollkommen in eine Windhaut eingehuellt\\.",["stop"]="Du befreist Dich von Deiner Windhaut\\.|Deine Windhaut loest sich auf\\.", ["duration"]="600"},
    {["name"]="Zauberwaffe", ["start"]="Du uebertraegst die Energie auf (Dein|Deine|Deinen|den)([a-z ,]*)([A-Za-z\\s]+)\\.",["stop"]="(Der|Die|Das|Dein|Deine) ([a-z ,]*)([A-Za-z\\s]+) verliert [a-z]* Energie\\.", ["duration"]="600"},
    {["name"]="Zorn", ["start"]="Du wirst von kuehlen Winden umgeben\\.", ["stop"]="Die kuehlen Winde, welche Dich umgeben, verschwinden\\.", ["duration"]="600"},
    {["name"]="Orktal - Vorbereitung", ["start"]="\\| einmal zum Angriff blasen.                            \\|", ["stop"]="\\| zweimal zum Angriff blasen.                           \\|", ["duration"]="900"},
    {["name"]="Orktal - Angriff 1 von 3", ["start"]="\\| zweimal zum Angriff blasen.                           \\|", ["stop"]="\\| dreimal zum Angriff blasen.                           \\|", ["duration"]="600"},
    {["name"]="Orktal - Angriff 2 von 3", ["start"]="\\| dreimal zum Angriff blasen.                           \\|", ["stop"]="\\| viermal zum Angriff blasen.                           \\|", ["duration"]="600"},
    {["name"]="Orktal - Angriff 3 von 3", ["start"]="\\| viermal zum Angriff blasen.                           \\|", ["stop"]="\\| Freudenschreie ertoenen aus dem Dorf im Sueden als    \\|", ["duration"]="900"},
  }
 
  -- Jetzt müssen die Timer-Trigger noch erzeugt werden. Dafür gibt es, wie weiter
  -- oben beschrieben, vier Möglichkeiten:
  -- 1) erzeugt alle Start- und alle Stop-Trigger als temporäre Trigger:
  --avalonUI.createTempTimer(timerStrings)
  -- 2) erzeugt alle START-Trigger als temporäre Trigger. Die STOP-Trigger werden 
  --    vom jeweiligen START-Trigger erzeugt, und zwar als ONE-TIME temp. Trigger:
  avalonUI.createImprovedTempTimer(timerStrings)
  -- 3) erzeugt alle Start- und alle Stop-Trigger als permante Trigger:
  --avalonUI.createPermTimer(timerStrings)
  -- 4) erzeugt alle Start-Trigger als permanente Trigger. Die STOP-Trigger werden
  --    vom jeweiligen START-Trigger erzeugt, und zwar als ONE-TIME-temp.(!) Trigger:
  --avalonUI.createMixedTimer(timerStrings)

end -- function avalonUI.initTimer()



-- function avalonUI.createTempTimer(timerStrings)
-- Hier werden die Start- UND die Stop-Trigger als TEMPORÄRE Trigger erzeugt
function avalonUI.createTempTimer(timerStrings)

  for _, v in pairs(timerStrings) do
  
    if v["duration"] == nil then
      v["duration"] = "false"
    end

    local param = ""
    local luaCode = ""
    -- Bei bestimmten Zaubern werden Begriffe aus dem auslösenden Text verwendet, um den
    -- Namen für den Timer zu bauen. Hier wird der dafür notwendige Parameter gesetzt.
    -- (Beim Stop-Trigger dann das Gegenstück, damit der richtige Timer gelöscht wird.)
    if v["name"] == "Segen" then param = ", matches[4]" end
    if v["name"] == "Zauberwaffe" then param = ", matches[4]" end

    -- START-Trigger:
    luaCode = [[avalonUI.registerTimer("]]..v["name"]..[[", "]]..v["duration"]..[["]]..param..[[)]]
    tempRegexTrigger(v["start"], luaCode)
    
    -- STOP-Trigger (nur bei Bedarf):
    if v["stop"] ~= "" then
      luaCode = [[avalonUI.deregisterTimer("]]..v["name"]..[["]]..param..[[)]]
      tempRegexTrigger(v["stop"], luaCode)
    end
  end -- for
end



-- function avalonUI.createImprovedTempTimer(timerStrings)
-- Hier werden die START-Trigger als temporäre Trigger erzeugt. Und zwar so,
-- dass sie sich beim Auslösen ihren eigenen temporären One-Time-STOP-Trigger
-- erzeugen
function avalonUI.createImprovedTempTimer(timerStrings)
  -- Beispiel für einen Timer-Trigger, der sich seinen eigenen Timer-Ende-Trigger setzt:
  -- permRegexTrigger("Flamme", "AvaletTriggerFuerTimer", {"^Flamme an!$"}, [[registerTimer("Flamme", "60"); tempRegexTrigger("^Flamme aus!$", function() removeTimer("Flamme") end, 1)]])
  -- Nur der Timer-Ende-Trigger:
  -- tempRegexTrigger("^Flamme aus!$", function() removeTimer("Flamme") end, 1)

  for _, v in pairs(timerStrings) do

    if v["duration"] == nil then
      v["duration"] = "false"
    end

    local param = ""
    local stopTimer = ""
    local luaCode = ""
      -- Bei bestimmten Zaubern werden Begriffe aus dem auslösenden Text verwendet, um den
      -- Namen für den Timer zu bauen. Und zwar ist das bei den Kleriker-Segen der Fall,
      -- weil die anders nicht zu unterscheiden sind. Hier wird der dafür notwendige Parameter gesetzt.
      -- (Beim Stop-Trigger dann das Gegenstück, damit der richtige Timer gelöscht wird.)
    if v["name"] == "Segen" then param = ", matches[4]" end
    if v["name"] == "Zauberwaffe" then param = ", matches[4]" end
    
    -- Wenn eine Stop-RegExpr existiert, wird beim Auslösen des Triggers ein temporärer One-Time-Stop-Trigger gesetzt.
    -- Da ich das folgende schon vor mehr als 20 Minuten geschrieben habe, verstehe ich es jetzt selber nicht mehr.
    -- Aber die Ersetzung von "\" durch "\\" MUSS sein, weil die einzelnen Maskierungen beim Verarbeiten entfallen,
    -- also jeweils immer eine. Und weil beim Stop-Timer-Trigger eine Verarbeitung mehr erfolgt als beim Start-Dings. 
    if v["stop"] ~= nil and v["stop"] ~= "" then
      stopTimer = [[; tempRegexTrigger("]]..string.gsub(v["stop"], [[\]], [[\\]])..[[", function() avalonUI.deregisterTimer("]]..v["name"]..[["]]..param..[[) end, 1)]]
    end

    -- Zusammenbau und Erzeugen des temporären Triggers:
    luaCode = [[avalonUI.registerTimer("]]..v["name"]..[[", "]]..v["duration"]..[["]]..param..[[)]] .. stopTimer
    tempRegexTrigger(v["start"], luaCode)
      
  end -- for  
end -- function avalonUI.createMixedTimer(timerStrings)



-- function avalonUI.createPermTimer(timerStrings)
-- Hier werden die Start- UND die Stop-Trigger als PERMANENTE Trigger erzeugt
-- Wenn diese permanenten Trigger von mir beim Entwickeln erzeugt werden, schreibt Mudlet
-- sie in diese Datei, also in den Code, und speichert sie. Dann würde ich die Datei packen
-- und als Modul ausliefern und die Trigger wären fest eincodiert. Wenn ich dran denken
-- würde, die Trigger vor dem Ausliefern immer zu löschen, könnte ich die permantenten Trigger
-- trotzdem verwenden. Denn dann würden sie zwar auch bei der Installation von Avalet erzeugt
-- werden. Da Mudlet aber nicht in ein gepacktes Modul schreiben kann, wären sie nach Programm-
-- ende wieder gelöscht. Und mit der Abfrage, ob sie existieren, würden sie dann beim Programm-
-- START wieder neu erzeugt werden. Aber da ich da nicht dran denken werde, benutze ich statt
-- dessen die temporären Trigger. (Und die permanenten Trigger zur zum Debuggen.)
-- Sollte sich dieser Vorbehalt mal ändern, warum auch immer, dann wäre es vielleicht
-- besser, die START-Trigger als permanente Trigger auszulegen, die STOP-Trigger dann als 
-- temporäre. Wie in der Funktion "avalonUI.createMixedTimer()"
function avalonUI.createPermTimer(timerStrings)

  -- Erzeugt eine sortierte Liste von Triggern. Weil es einfach schöner ist, wenn man die
  -- Liste im Code-Editor von Mudlet sieht. Ist bei temporäten Triggern ja unnötig.
  local sortTimerStrings = function (a, b) return a["name"] &lt; b["name"] end
  table.sort(timerStrings, sortTimerStrings)

  for _, v in pairs(timerStrings) do

    -- Trigger nur erzeugen, wenn sie nicht schon existieren:  
    if not exists(v["name"].."Start", "trigger") then

      if v["duration"] == nil then
        v["duration"] = "false"
      end

      local param = ""
      local luaCode = ""
      -- Bei bestimmten Zaubern werden Begriffe aus dem auslösenden Text verwendet, um den
      -- Namen für den Timer zu bauen. Und zwar ist das bei den Kleriker-Segen der Fall,
      -- weil die anders nicht zu unterscheiden sind. Hier wird der dafür notwendige Parameter gesetzt.
      -- (Beim Stop-Trigger dann das Gegenstück, damit der richtige Timer gelöscht wird.)
      if v["name"] == "Segen" then param = ", matches[4]" end
      if v["name"] == "Zauberwaffe" then param = ", matches[4]" end
      
      -- Zusammenbau und Erzeugen des START-Triggers als permanter Trigger:
      luaCode = [[avalonUI.registerTimer("]]..v["name"]..[[", "]]..v["duration"]..[["]]..param..[[)]]
      permRegexTrigger(v["name"].."Start", "AvaletTriggerFuerTimer", {v["start"]}, luaCode)
    end -- if exists
      
    -- Nur bei Bedarf und wenn er nicht schon existiert: der STOP-Trigger:
    if not exists(v["name"].."Stop", "trigger") and v["stop"] ~= "" then
      -- Zusammenbau und Erzeugen des STOP-Triggers als permanenter Trigger:
      luaCode = [[avalonUI.deregisterTimer("]]..v["name"]..[["]]..param..[[)]]
      	permRegexTrigger(v["name"].."Stop", "AvaletTriggerFuerTimer", {v["stop"]}, luaCode)
    end -- if exists
  end -- for
end --function avalonUI.createPermTimer(timerStrings)



-- function avalonUI.createMixedTimer(timerStrings)
-- Hier werden die START-Trigger als PERMANENTE Trigger erzeugt. Und zwar so,
-- dass sie sich beim Auslösen ihren eigenen TEMPORÄREN One-Time-STOP-Trigger
-- erzeugen
-- Siehe auch Kommentar zur vorherigen Funktion (createPermTimer())
function avalonUI.createMixedTimer(timerStrings)
  -- Beispiel für einen Timer-Trigger, der sich seinen eigenen Timer-Ende-Trigger setzt:
  -- permRegexTrigger("Flamme", "AvaletTriggerFuerTimer", {"^Flamme an!$"}, [[registerTimer("Flamme", "60"); tempRegexTrigger("^Flamme aus!$", function() removeTimer("Flamme") end, 1)]])
  -- Nur der Timer-Ende-Trigger:
  -- tempRegexTrigger("^Flamme aus!$", function() removeTimer("Flamme") end, 1)

  -- Erzeugt eine sortierte Liste von Triggern. Weil es einfach schöner ist, wenn man die
  -- Liste im Code-Editor von Mudlet sieht. Ist bei temporäten Triggern ja unnötig.
  local sortTimerStrings = function (a, b) return a["name"] &lt; b["name"] end
  table.sort(timerStrings, sortTimerStrings)

  for _, v in pairs(timerStrings) do

    -- Eigentlich wäre es sinnvoll, der Trigger würde gelöscht werden, wenn er schon existiert.
    -- Weil man nur so ein Update der zu triggernden Texte machen kann. Geht aber nicht. Die
    -- Mudlet-Funktion "killTrigger" kann nur temporäre Trigger löschen. (Evtl. könnte man hier
    -- über die Trigger-Group löschen, aber dann müsste man die neu erzeugen und das ging auch
    -- nicht. Siehe oben.)
    if not exists(v["name"], "trigger") then

      if v["duration"] == nil then
        v["duration"] = "false"
      end

      local param = ""
      local stopTimer = ""
      local luaCode = ""
      -- Bei bestimmten Zaubern werden Begriffe aus dem auslösenden Text verwendet, um den
      -- Namen für den Timer zu bauen. Und zwar ist das bei den Kleriker-Segen der Fall,
      -- weil die anders nicht zu unterscheiden sind. Hier wird der dafür notwendige Parameter gesetzt.
      -- (Beim Stop-Trigger dann das Gegenstück, damit der richtige Timer gelöscht wird.)
      if v["name"] == "Segen" then param = ", matches[4]" end
      if v["name"] == "Zauberwaffe" then param = ", matches[4]" end
      
      -- Wenn eine Stop-RegExpr existiert, wird beim Auslösen des Triggers ein temporärer One-Time-Stop-Trigger gesetzt.
      -- Da ich das folgende schon vor mehr als 20 Minuten geschrieben habe, verstehe ich es jetzt selber nicht mehr.
      -- Aber die Ersetzung von "\" durch "\\" muss sein, weil die einzelnen Maskierungen beim verarbeiten entfallen,
      -- also jeweils immer eine. Und weil beim Stop-Timer-Trigger eine Verarbeitung mehr erfolgt als beim Start-Dings. 
      if v["stop"] ~= nil and v["stop"] ~= "" then
        stopTimer = [[; tempRegexTrigger("]]..string.gsub(v["stop"], [[\]], [[\\]])..[[", function() avalonUI.deregisterTimer("]]..v["name"]..[["]]..param..[[) end, 1)]]
      end
      
      -- Zusammenbau und erzeugen des PERMANENTEN Start-Triggers, der sich einen eigenen TEMPORÄREN Stop-Trigger erzeugt:      
      luaCode = [[avalonUI.registerTimer("]]..v["name"]..[[", "]]..v["duration"]..[["]]..param..[[)]] .. stopTimer
      permRegexTrigger(v["name"], "AvaletTriggerFuerTimer", {v["start"]}, luaCode)

    end -- if not exists
      
  end -- for  
end -- function avalonUI.createMixedTimer(timerStrings)
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>settings</name>
			<packageName></packageName>
			<script>--Benutzerdefinierte Einstellungen

avalonUI.settings = avalonUI.settings or {}
avalonUI.settings.GUIframe  = avalonUI.settings.GUIframe or {}
avalonUI.settings.avalet    = avalonUI.settings.avalet or {}
avalonUI.settings.character = avalonUI.settings.character or {}
avalonUI.settings.chatTabs  = avalonUI.settings.chatTabs or {}


avalonUI.settings.avalet = {
  ["name"] = "Avalet",
  ["timerGaugeDirection"] = "goofy",
  ["chatTabs"] = {},
}

avalonUI.settings.character = {
  ["name"] = "",
  ["backgroundColor"] = "black",
}

--[[Tabs im Chat-Bereich
    Die Liste hier legt fest, welche Tabs angezeigt werden sollen. Der hier verwendete "Name" wird intern verwendet, um
    den Namen des Kanals zu finden. Das heisst, der Name hier muss exakt so geschrieben werden, wie er hier steht. Und 
    kann nicht verwendet werden, um den Tab kreativ zu beschriften. Mögliche Kanäle sind:
    Reden, Sagen, Laber, Neuling, Gruppe, Volk, Gilde, Zuenfte, Schwafel, Tod, Monster, Gebruell, Logout, Raetsel, Spiele,
    Statue
    Geplant aber noch nicht möglich: ein Sammeltab]]
avalonUI.settings.chatTabs = {
  {["name"] = "Reden", ["position"] = 1, ["aktiv"] = true},
  {["name"] = "Sagen", ["position"] = 2, ["aktiv"] = true},
  {["name"] = "Laber", ["position"] = 3, ["aktiv"] = true},
  {["name"] = "Neuling", ["position"] = 4, ["aktiv"] = true},
  {["name"] = "Gruppe", ["position"] = 5, ["aktiv"] = true},
  {["name"] = "Volk", ["position"] = 6, ["aktiv"] = true},
  {["name"] = "Gilde", ["position"] = 7, ["aktiv"] = true},
  --{["name"] = "Schwafel", ["position"] = 8, ["aktiv"] = true},
}


-- Einstellungen der Höhe/Breite der Fensterbereiche
avalonUI.settings.GUIframe = {
  ["leftStartWidth"] = nil,
  ["leftStartHeight"] = nil,
  ["rightStartWidth"] = nil,
  ["rightStartHeight"] = nil,
}


</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>GUIFrame defaults</name>
			<packageName></packageName>
			<script>local mainW, mainH = getMainWindowSize()
local tabSheet = table.deepcopy(avalonUI.CSS.base)

--tabSheet.stylesheet.margin = nil
--tabSheet:set("background-color", "rgba(0,0,0,100)")
--tabSheet:set("border-style", "solid")
--tabSheet:set("border-width", "1px")
--tabSheet:set("border-radius", "10px")
--tabSheet:set("border-color", "white")
--tabSheet:set("font", "TypeWriter")
--tabSheet:set("margin-left", "10px")
--tabSheet:set("margin-right", "10px")
--tabSheet:set("width", "98%")
--tabSheet:set("height", "20px")

GUIframe.configs = {
    tabHeight = 0,--20,
    tabStyle = tabSheet:getCSS(),
    tabEchoStyle = '&lt;center&gt;&lt;p style="font-size:13px; color:LightYellow"&gt;',
    leftStartWidth = math.floor(mainW * 0.16),       --math.floor(mainW / 6.8),
    leftStartHeight = math.floor(mainH / 2.0),        --math.floor(mainH / 3),2.5
    rightStartWidth = math.floor(mainW * 0.38),        --math.floor(mainW / 3),
    rightStartHeight = math.floor(mainH / 2),    --math.floor(mainH * 0.42),
    topStartHeight = 60,   --30
    bottomStartHeight = 0, --65
    resizeHoverImage = "/Avalet/imgs/blue_arrows.png",
    resizeRestImage = "/Avalet/imgs/blue_arrows_20t.png",
    borderOffset = 0,
}</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>LagCoefficient</name>
			<packageName></packageName>
			<script>-- Avalet misst an verschiedenen Stellen die Antwortzeiten vom Mud
-- und errechnet daraus den "Lag-Koeffizienten".
-- Das ist nur so mittel ernst gemeint. Aber wer weiss, vielleicht
-- taugt es ja. Irgendwann.

--[[
Die Idee ist, an unterschiedlichen Stellen Antwortzeiten vom MUD zu messen. Und
dann die Werte der einzelnen Stellen zu verdichten und auszuwerten. 
Derzeitiger Plan: Der Mittelwert aus den fünf(?) kleinsten Werten bildet die Basis.
Und die letzen 50(?) Werte werden dann für den Koeffizienten herangezogen. 
Dabei müsste dann noch unterschieden werden, wie die Situation über eine gewisse Zeit
ist. Meint: Kommen immer mehrere gute Werte und dann aber ein oder zwei schlechte?
Oder sind die Werte insgesamt alle nicht so super? Oder immer abwechselnd oder so?
Man muss da also auch irgendwie die Verteilung über die Zeit sehen.
Heisst aber auch: es muss zu jedem Messwert ein Zeitwert gespeichert sein.
]]</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>AvalonTime</name>
			<packageName></packageName>
			<script>function avalonUI.getAvalonTime()

  timeStr = ""

  local sec = os.time(os.date("*t"))-808437600
  --cecho("&lt;magenta&gt;\n"..sec.."\n")
  local jahr = math.floor(sec/31536000*13)
  sec = sec-(jahr*31536000/13)
  local tag = math.floor(sec/86400*13+1)
  sec = sec-((tag-1)*86400/13)
  local stunde = math.floor(sec/3600*13)
  if (stunde &lt;=9) then stunde ="0"..stunde;end 
  sec = sec-(stunde*3600/13)
  local minute = math.floor(sec/60*13)
  if (minute &lt;=9) then minute ="0"..minute;end 
  wtage={"Sonntag","Montag","Dienstag","Mittwoch","Donnerstag","Freitag","Samstag"}
  if (tag&lt;=365) then monat=12;atag=tag-334;end
  if (tag&lt;=334) then monat=11;atag=tag-304;end
  if (tag&lt;=304) then monat=10;atag=tag-273;end
  if (tag&lt;=273) then monat=9;atag=tag-243;end 
  if (tag&lt;=243) then monat=8;atag=tag-212;end
  if (tag&lt;=212) then monat=7;atag=tag-181;end
  if (tag&lt;=181) then monat=6;atag=tag-151;end
  if (tag&lt;=151) then monat=5;atag=tag-120;end
  if (tag&lt;=120) then monat=4;atag=tag-90;end
  if (tag&lt;=90) then monat=3;atag=tag-59;end
  if (tag&lt;=59) then monat=2;atag=tag-31;end
  if (tag&lt;=31) then monat=1;atag=tag;end
  season = "-"
  if tag &gt;=0 and tag &lt;=76 then season = "Winter";end
  if tag &gt;=77 and tag &lt;= 132 then season = "Fruehling";end
  if tag &gt;=133 and tag &lt;= 256 then season = "Sommer";end
  if tag &gt;=257 and tag &lt;= 322 then season = "Herbst";end
  if tag &gt;=323 then season = "Winter";end
  datum = {}
  datum.monat = monat
  datum.jahr = jahr
  datum.wtag = atag
  datum.wtagdesc = wtage[((tag+(jahr*365)+3)%7)+1]
  datum.stunde = stunde
  datum.minute = minute
  datum.season = season
  --ClockBox:echo([[&amp;lt;p style="font-size:12px"&amp;gt;&amp;lt;b&amp;gt;&amp;lt;font color="white"&amp;gt;]]..wtage[((tag+(jahr*365)+3)%7)+1]..", "..atag.."."..monat.."."..jahr.." "..stunde..":"..minute.." ("..season..")")
--[[
]]

  timeStr = wtage[((tag+(jahr*365)+3)%7)+1]..", "..atag.."."..monat.."."..jahr.." "..stunde..":"..minute.." ("..season..")"

  return timeStr

end


function avalonUI.getSimplifiedAvalonTime()

  simplAvaTime = nil
  
  return simplAvaTime
  
end

</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>ModelControl</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>createChatModel</name>
				<packageName></packageName>
				<script>-- createChatModel

--------------------------------------------
--- Tabs-Element rechts unten
-------------------------------------------
function avalonUI.createChatModel()
  -- Generelle Variablen für das Tab-Element
  GUIModel.tabElement = GUIModel.tabElement or {
    tabs = {"Reden", "Sagen", "Laber", "Neuling", "Gruppe", "Volk", "Gilde", "Schwafel"},
  }
  -- Speichert das aktuell ausgewählte Element:
  GUIModel.tabElement.currentTab = GUIModel.tabElement.currentTab or GUIModel.tabElement.tabs[1]
  
  for k,v in pairs(GUIModel.tabElement.tabs) do
  
    avalonUI.chats[v] = {}
    
  end

end



-- In der per ATCP empfangenen Kommunikation gibt es Formatierungsanweisungen,
-- die hier rausgefiltert werden.
local clearMessage = function(str)
  local message = str
  message = string.gsub(message, "%%%^ITALIC%%%^", "")
  message = string.gsub(message, "%%%^NO_ITALIC%%%^", "")
  message = string.gsub(message, "%%%^NC_html_begin_colour%(%#[A-Za-z0-9]+%)%%%^", "")
  message = string.gsub(message, "%%%^NC_html_end_colour%%%^", "")
  
  return message
end



-- Hier wird die Kommunikation verarbeitet, die über die Comm-Kanäle per ATCP eingehen.
-- Eine erste Verarbeitung fand schon beim Eingang der Nachricht statt, also bei
-- ATCP --&gt; atcp (Trennung von channel und message nämlich, aber auch die Zuordnung von
-- einzelnen Kanälen zu Sammelbegriffen, bspswse "vr" zu "Volk".
function avalonUI.processMessage(channel, message)

  -- Die Nachricht kann Steuercode enthalten, beispielsweise für farbigen Text.
  -- Der wird hier rausgefiltert.
  message = clearMessage(message)
  
  local logfilename = ""
  if player.name ~= nil and player.name ~= "" then
    logfilename = string.title(player.name) .. channel
  else
    logfilename = channel
  end
  
  Logger:Log(logfilename, message, {"timestamp", split = 4000})

  local timestamp = getTime(true, "'['dd'.'MM'.'yyyy' - 'hh':'mm':'ss'.'zzz]: ")

  local line = ""

  -- Hier können auch Comm-Nachrichten landen, für die es keinen Tab gibt. Also:
  if avalonUI.chats[channel] ~= nil then
    -- Die Tabelle der einzelnen Chat-Tabs wird auf 500 Elemente begrenzt.
    -- Um Speicher zu sparen. Die Zahl kann sich noch ändern, aber 500 schien
    -- mir erstmal ausreichend zu sein. Wenn die Tabelle länger ist, wird
    -- hier jeweils das erste Element entfernt.
    while #avalonUI.chats[channel] &gt;= 500 do
      table.remove(avalonUI.chats[channel], 1)
    end

    -- Timestamp vor die Zeile und ab damit in die Tabelle:
    line = timestamp .. message --.. "\n"
    table.insert(avalonUI.chats[channel], line)

    -- Aufbereitet wird die Anzeige bei der Ausgabe. Dafür sorgt:
    raiseEvent("RefreshTabElement", channel)
  end  
end


-- Teilweise gab es Anzeigeprobleme im Tab - die neuen Zeilen wurden
-- ausgegeben, aber der Fokus rutschte nicht weiter runter, so dass
-- die neuen Zeilen unterhalb des unteren Randes standen. Und andere
-- (weniger eindeutige) Merkwürdigkeiten. Dabei fand das löschen des
-- Tabs nur mit "clearWindow()" statt. Mit der zusätzlichen Ausgabe
-- eines Leerzeichens scheint sich das Problem erledigt zu haben.
local clearTab = function(channel)
  debugc("&lt;magenta&gt;clearWindow: ".. channel .. "\n")    
  clearWindow(channel)
  avalonUI.tabElement.tabs[GUIModel.tabElement.currentTab.."console"]:echo(" ")
end



-- Wird ausgeführt, wenn per ATCP eine neue Kommunikation eingeht
-- und diese in die ChatTab-Tabelle geschrieben wurde (siehe oben).
function avalonUI.onRefreshTabElement(_, channel)

  local content = ""
  local lastdate = ""
  local date = ""
  local line = ""
  -- Wenn für den aktuell angezeigten Tab eine neue Nachricht eingeht ...
  if GUIModel.tabElement.currentTab == channel then
    debugc("Der TAB " .. channel .. " wird aktualisiert.")

    --... wird erstmal der alte Inhalt gelöscht.
    clearTab(channel)
    
    -- Dann wird für jede Zeile in der ChatTab-Tabelle ...
    for _,v in pairs(avalonUI.chats[channel]) do

      -- ... erstmal das Datum extrahiert. (Aus dem Timestamp am Anfang der Zeile.)
      date = string.gsub(v, "^%[(%d+%.%d+%.%d+) %- %d+:%d+:%d+%.%d+%]: .*$", "%1", 1)
      --content = ""
      
      -- Wenn der Tab noch leer ist, wird erstmal das Datum des ersten Eintrags ausgegeben.
      -- Und dann wieder bei jedem Datumswechsel. Dabei wird zusätzlich noch ein Leerzeichen
      -- eingefügt.
      if lastdate ~= date then
        if lastdate ~= "" then content = "\n" end
        content = content .. "\n~~~~~~~~~~~~~~~~~~~~ " .. date .. " ~~~~~~~~~~~~~~~~~~~~\n\n"
        lastdate = date
      end
      
      -- Die eigentliche Zeile besteht nur aus dem Zeitstempel und dem eigentlichen Text
      line = string.gsub(v, "^%[%d+%.%d+%.%d+ %- (%d+:%d+:%d+)%.%d+%]: (.*)$", "%1: %2", 1)
      content = content .. line .. "\n"

      -- Seit Mudlet 4.8 kann "echo()" nur noch 10k Zeichen auf einmal ausgeben. Hier wird
      -- deshalb nach 8k Zeichen der Content einmal ausgegeben (und dann geleert).
      if #content &gt; 8000 then
        avalonUI.tabElement.tabs[GUIModel.tabElement.currentTab.."console"]:echo(content)
        content = ""
      end
    end
    -- Zum Schluss wird noch der Rest vom Content ausgegeben, also alles unter 8k Zeichen.
    if content ~= "" then
      avalonUI.tabElement.tabs[GUIModel.tabElement.currentTab.."console"]:echo(content)
    end
  -- Wenn die Nachricht, die eingeht, NICHT für den aktuell angezeigten Tab ist, dann wird
  -- einfach nur der entsprechende Tab farbig markiert. Damit der User sieht, dass da noch
  -- ungelesene Nachrichten sind.
	else
    avalonUI.markTab(channel)
	end
end
registerAnonymousEventHandler("RefreshTabElement", "avalonUI.onRefreshTabElement")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createCounterModel</name>
				<packageName></packageName>
				<script>--createCounterModel

avalonUI.counter = avalonUI.counter or {}

avalonUI.counter = {
  {["Name"]="Session-EP", ["Groesse"]="EP", ["Basis"] = "Session"},
  {["Name"]="Arkanschild", ["Groesse"]="EP", ["Basis"] = "Arkanschild"},
  {["Name"]="Kampfdauer", ["Groesse"]="Zeit", ["Basis"] = "Kampf"},
  {["Name"]="EP-Verdoppelung", ["Groesse"]="EP", ["Basis"] = "EP-Verdoppelung"},
  {["Name"]="EP/Stunde", ["Groesse"]="EP", ["Basis"] = "Stunde"},
}

local schutzzauber = schutzzauber or {}
schutzzauber = {"Arkanschild", "Schild", "Kampfbeschwoerung", ""}

function avalonUI.createCounterModel()
  avalonUI.listOfCounter = avalonUI.listOfCounter or {}
  avalonUI.listOfCounter = {
    [1] = {["Name"]="EP", ["Groesse"]="EP", ["Basis"] = "EP", ["Basiswert"] = 0},
    [2] = {["Name"]="Session-EP", ["Groesse"]="EP", ["Basis"] = "Session", ["Basiswert"] = 0},
    [3] = {["Name"]="Bonusstunden-EP", ["Groesse"]="EP", ["Basis"] = "Bonusstunde", ["Basiswert"] = 0},
    [4] = {["Name"]="Schildzauber", ["Groesse"]="EP", ["Basis"] = "Schildzauber", ["Basiswert"] = 0},
  }
  
end


function avalonUI.recreateCounter()
	--debugc("func initCounter()")
  
  -- Alle Counter unsichtbar machen und Beschriftung löschen. Es gibt
  -- 6 Label-Elemente für Counter auf der Oberfläche, also (max) 6 Timer:
  for k = 1, 4, 1 do
    avalonUI["Counter"..k]:hide()
    avalonUI["Counter"..k]:echo("")
  end

  -- Counter-Anzeige neu aufbauen:
  avalonUI.refreshCounter()
end --function initCounter()


function avalonUI.refreshCounter()
	--debugc("function refreshCounter")
  
  for k, v in pairs(avalonUI.listOfCounter) do
    avalonUI["Counter"..k]:show()
    ---- mylabel:echo(string.format("&lt;span style='color: rgb(0,0,0)'&gt;Hello World&lt;/span&gt;", redv, greenv, bluev))
    ----avalonUI["Counter"..k]:echo("&lt;span style='color: rgb(0,0,0)'&gt;&lt;b&gt;&amp;nbsp;"..v["Name"]..": " .. tostring(tonumber(player.ep) - tonumber(player.sessionEP)) .. "&lt;/b&gt;&lt;/span&gt;")
    --avalonUI["Counter"..k]:echo("&lt;b&gt;&amp;nbsp;"..v["Name"]..": " .. tostring(tonumber(player.ep) - tonumber(player.sessionEP)) .. "&lt;/b&gt;")
    if k == 1 then avalonUI["Counter"..k]:echo("&lt;b&gt;" .. v["Name"] ..":&lt;/b&gt;" .. thousands(tonumber(player.ep))) end
    if k == 2 then avalonUI["Counter"..k]:echo("&lt;b&gt;".. v["Name"] ..":&lt;/b&gt; " .. thousands(tonumber(player.ep) - tonumber(player.sessionEP))) end
    if k == 3 then avalonUI["Counter"..k]:echo("&lt;b&gt;".. v["Name"] ..":&lt;/b&gt; " .. thousands(tonumber(player.bonusEP))) end
    if k == 4 then avalonUI["Counter"..k]:echo("&lt;b&gt;".. v["Name"] ..":&lt;/b&gt; " .. thousands(tonumber(player.schildEP))) end
  end
end

-- Das Problem mit dem SessionEP-Zähler ist, dass es im Grunde keine Möglichkeit gibt,
-- ein echtes "Login", also den Session-Start, zu erkennen. Man kann ein "reconnect"
-- an Hand des Strings "Verwende alten Koerper..." erkennen (und dann nur hoffen, dass
-- das immer zuverlässig ist), aber um einen echten login davon unterscheiden zu können,
-- müsste man zuverlässigere Daten haben. (ODER?)
-- Naja, man könnte bei sysConnection ein Flag "isLogin = true" setzen, und durch den Trigger auf
-- "Verwende alten Koerper..." könnte man das Flag auf "false" setzen. Das funktioniert vermutlich,
-- wenn WIRKLICH der Char-Name nicht vorher per ATCP kommt. Sollte gehen. TODO.
-- "\nSession-EP: " .. tostring(tonumber(player.ep) - tonumber(player.sessionEP)) .. "\n"

-- event == "AvalonEP"
function avalonUI.updateSessionEP(_, arg)
  debugc("Update SessionEP-Zaehler!")
  --cecho("&lt;magenta&gt;\nupdate Session-EP\n")
  --avalonUI["Counter1"]:echo("&lt;b&gt;&amp;nbsp;Session-EP: " .. tostring(tonumber(arg) - tonumber(player.sessionEP)) .. "&lt;/b&gt;")
  avalonUI["Counter1"]:echo("&lt;b&gt;EP:&amp;nbsp;&lt;/b&gt;" .. thousands(player.ep))
  avalonUI["Counter2"]:echo("&lt;b&gt;Session-EP:&amp;nbsp;&lt;/b&gt;" .. thousands(tonumber(arg) - tonumber(player.sessionEP)))
end
registerAnonymousEventHandler("AvalonEP", "avalonUI.updateSessionEP")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createInfoScreenModel</name>
				<packageName></packageName>
				<script>-----------------------------------------------------
-- Infobox rechts oben
-----------------------------------------------------
--[[
Die Infobox ist für Informationen, die der Spieler sich vielleicht etwas länger ansehen will als das im
(Kampf-)Scroll möglich ist. Dazu gehören zunächst Spielstand, Inventar und die Gruppeninformationen, außerdem
die Ausgabe von "ruebersicht" der Runenschmiede. Weiter sind natürlich denkbar und könnten dann auch
leicht hinzugefügt werden.
Die Default-Anzeige mit den Charakterinformationen war ursprünglich nur eine Übergangslösung, bis der
Info-Bereich richtig Implementiert ist. Die Werte in dieser Default-Anzeige haben allerdings die Eigenschaft,
dass sie per ATCP gesendet werden und deshalb aktualisierbar sind. Im Gegensatz zum Spielstand beispielsweise,
der eben nur eine Momentaufnahme ist und dann altert.


In der Infobox werden Informationen angezeigt, die wichtig sind und nicht im Scroll untergehen sollen.
Dazu gehören Spielstand, Inventar, Gruppeninformationen und die Ausgabe von "ruebersicht" der Runenschmiede.
Die Idee ist, dass das Spiel ja weiterhin im Hauptfenster stattfindet. Und das diese ganzen Informationen
ja auch altern. Es bringt also nichts, beispielsweise den Spielstand längere Zeit im Info-Bereich anzuzeigen.
Jedenfalls nicht, wenn die dort gezeigten Informationen nicht auch (automatisch) aktualisiert werden können.
Der Spieler muss also immer wieder diese Informationen abrufen und sollte auch nicht den Eindruck gewinnen,
dass Avalet ihm einen aktuellen Zustand anzeigen kann. (Also außer eben in dem Moment, wo die Information durch
den Spieler von Server abgerufen wird.) Deshalb werden die Informationen nur eine Zeit lang angezeigt. Und 
nach Ablauf dieser Zeit wieder durch den Default-Text ersetzt. Außer der Spieler ruft in dieser Zeit andere
Informationen ab, die in der Infobox angezeigt werden. Dann werden diese an die alten Daten angehängt und der
Timer, der auf die Default-Anzeige zurückschaltet, wird zurückgesetzt.

]]


function avalonUI.createInfoScreenModel()
  GUIModel.infobox = "\nWarte auf Daten..."
  GUIModel.infoBoxDefault = ""
  GUIModel.infoBoxBuffer = ""
  GUIModel.infoBoxTempTimerID = nil
end



function avalonUI.writeBufferToInfoBox(text)

end --avalonUI.writeBufferToInfoBox(text)


function avalonUI.updateInfoBoxDefault()

  local content = ""
	GUIModel.infoBoxDefault = "\n"
--	if avalonUI ~= nil then 
--		clearWindow("Infobox") 
--	end
	if player.vollername == nil then 
		return
	end
	if string.len(player.vollername) ~= 0 then
		content = content .. "&lt;b&gt;&lt;white&gt;In Avalon bist Du bekannt als\n\n" .. player.vollername .. "&lt;/b&gt;\n\n"
    if player.nation ~= nil and player.nation ~= "" then
 				content = content .. "Du stammst aus dem Volk der "..player.nation..".\n"
    end

		if string.len(player.gilde) ~= 0 then
			if player.gilde == "keine" then
				content = content .. "Du bist noch in keiner Gilde.\n"
			else
				if player.gilde == "Druiden" then
					content = content .. "Du bist in der " .. player.gilde .. "gilde.\n"
				elseif player.gilde == "Magier" then
					content = content .. "Du bist in der " .. player.gilde .. "gilde.\n"
				else
					content = content .. "Du bist in der Gilde der " .. player.gilde .. ".\n"
				end
			end
		end
		if string.len(player.zuenfte) == 0 then
			content = content .. "Du uebst noch keine Berufe aus.\n"
		else
			local zuenfte = {}
			for i in string.gmatch(player.zuenfte, "%w+") do
				table.insert(zuenfte, i)
			end			
			local str = ""
			for k,v in pairs(zuenfte) do
				if k == #zuenfte and k &gt; 1 then
					str = str .. " und "
				end
				str = str .. v
				if k &lt; #zuenfte - 1 then
					str = str .. ", "
				end
			end
			
			content = content .. "Du gehoerst den Zuenften " .. str .. " an.\n"
			--GUIModel.infobox = GUIModel.infobox .. "Deine Berufe sind: " .. player.zuenfte .. ".\n"
		end
  if string.len(player.alter) ~= 0 then
    -- Also ich habe keinen regulären Ausdruck gefunden, der Stunden und Minuten sowohl
    -- in der Mitte der Zeichenkette als auch am Anfang zuverlässig erkennt. Bestenfalls
    -- wurde dabei nur eine Ziffer übernommen (also "8 Minuten" statt "28 Minuten"). Deshalb
    -- die zweistufige Lösung. Wer da besser ist als ich --&gt; mail me! (Aber erst testen!)
    -- Testfälle:
    -- "38 Tage 40 Stunden 21 Minuten 41 Sekunden 3306101",
    -- "3 Tage 6 Stunden 2 Minuten 4 Sekunden 3306101",
    -- "6 Stunden 21 Minuten 41 Sekunden 3306101",
    -- "38 Tage 21 Minuten 41 Sekunden 3306101",
    -- "21 Minuten 41 Sekunden 3306101",
    -- "38 Tage 6 Stunden 41 Sekunden 3306101",
    local str = player.alter
    local tage = ""
    tage = string.gsub(str, "^(%d+%sTage?)%s.*", "%1", 1)
    if tage == str then
      tage = "0 Tage"
    end
    local stunden = ""
    stunden = string.gsub(str, ".*%s(%d+%sStunden?)%s.*", "%1", 1)
    if stunden == str then
      stunden = string.gsub(str, "^(%d+%sStunden?)%s.*", "%1", 1)
      if stunden == str then
        stunden = "0 Stunden"
      end
    end
    local minuten = ""
    minuten = string.gsub(str, ".*%s(%d+%sMinuten?)%s.*", "%1", 1)
    if minuten == str then
      minuten = string.gsub(str, "^(%d+%sMinuten?)%s.*", "%1", 1)
      if minuten == str then
        minuten = "0 Minuten"
      end
    end
    --local sekunden = ""
    --sekunden = string.gsub(str, ".*%s(%d+%sSekunden?)%s.*", "%1", 1)
    --if sekunden == str then
    --  sekunden = "0 Sekunden"
    --end
    
    str = tage .. " " .. stunden .. " und " .. minuten
    
    content = content .. "Du bist etwa " .. str .. " alt.\n"
    --GUIModel.infobox = GUIModel.infobox .. "Du bist " .. player.alter .. " alt\n"
  end
		if string.len(player.portfolio) ~= 0 then
			if (player.portfolio ~= "keines") then
				if player.portfolio == player.name then
					content = content .. "Du bist Erstie in Deinem Portfolio.\n\n"
				else
					content = content .. "Du bist Zweitie im Portfolio von " .. string.title(player.portfolio) .. ".\n\n"
				end
			end
		end
		if string.len(player.level) ~= 0 then
			content = content .. "Du bist Level " .. player.level .. "\n"
		end
--		if string.len(player.ep) ~= 0 then
--			GUIModel.infobox = GUIModel.infobox .. "Dafür hast du bisher " .. player.ep .. " Erfahrungspunkte gesammelt.\n\n"
--		end
		if string.len(player.gesinnung) ~= 0 then
			content = content .. "\nDeine Gesinnung ist " .. player.gesinnung .. ".\n\n"
		end
--		if string.len(player.hunger) ~= 0 then
--			content = content .. "Hunger:  " .. player.hunger .. "\n"
--		end
--		if string.len(player.durst) ~= 0 then
--			content = content .. "Durst:   " .. player.durst .. "\n"
--		end
--		if string.len(player.durst) ~= 0 then
--			content = content .. "Alkohol: " .. player.alk .. "\n"
--		end
--    if player.schutz ~= nil then
--      GUIModel.infobox = GUIModel.infobox .. "\nSchutz: " .. player.schutz .. "\n"
--    end
--    if player.istDunkel == "1" then
--      GUIModel.infobox = GUIModel.infobox .. "\nAufenthaltsort: &lt;zu dunkel&gt;\n"
--    else
--      GUIModel.infobox = GUIModel.infobox .. "\nAufenthaltsort: " .. player.avalonRoomID .. "\n"
--    end
    --GUIModel.infobox = GUIModel.infobox .. "\nAvalon-Zeit: " .. avalonUI.getAvalonTime() .. "\n"
    
    
   -- content = content .. "-- \n\n"
    
    
    if avalonUI.counter ~= nil then 

      for k, v in pairs(avalonUI.listOfCounter) do

        if k == 1 then content = content .. "&lt;b&gt;" .. v["Name"] ..":&lt;/b&gt;              " .. thousands(tonumber(player.ep)) .. "\n" end
        if k == 2 then content = content .. "&lt;b&gt;" .. v["Name"] ..":&lt;/b&gt;      " .. thousands(tonumber(player.ep) - tonumber(player.sessionEP)) .. "\n" end
        if k == 3 then content = content .. "&lt;b&gt;" .. v["Name"] ..":&lt;/b&gt; " .. thousands(tonumber(player.bonusEP)) .. "\n" end
        --if k == 4 then content = content .. "&lt;b&gt;" .. v["Name"] ..":&lt;/b&gt;    " .. thousands(tonumber(player.schildEP)) .. "\n" end
        if k == 4 then content = content .. "&lt;b&gt;" .. v["Name"] ..":&lt;/b&gt;    n/a\n" end
      end
    end
    
    content = content .. "&lt;b&gt;Lag-Koeffizient:&lt;/b&gt; n/a\n"
    
    content = content .. "\n(Diese Anzeige aufrufen mit 'cinfo')"
    
	else
		debugc("\nKeine Player-Daten vorhanden!\n")
		content = "\nWarte auf Daten...\n"
	end
  
  GUIModel.infoBoxDefault = content
  
end -- function avalonUI.updateInfoBoxDefault()


-- Diese Funktion wird immer ausgeführt, wenn per ATCP Daten eintreffen, die in der Infobox
-- im Defaulttext angezeigt werden.
function avalonUI.onRefreshInfobox(event, args)
-- Es kann passieren, dass diese Funktion aufgerufen wird, obwohl noch
-- kein Player-Objekt besteht. (Also obwohl der Player-Name noch nicht
-- per ATCP eingetroffen ist. Workaround: auf player.name testen.)
  if player.name ~= "" then
    -- Ich hab vergessen, warum ich das hier für nötig hielt... Auskommentiert deshalb      
    --writeDataToFS(characterFilePath, player, "w")
    -- Hier wird der Text für die Info-Box auf den aktuellen Stand gebracht:
    avalonUI.updateInfoBoxDefault()

    --avalonUI.infoScreen:echo(args)
    if GUIModel.infoBoxTempTimerID == nil then
      clearWindow("Infobox") 
      showWindow("Infobox")
      if avalonUI.runiInfoBox then
        avalonUI.runiInfoBox:hide()
      end
      avalonUI.infoScreen:cecho(GUIModel.infoBoxDefault)
    end
    --avalonUI.Health:setValue(tonumber(args[1]), tonumber(args[2]), "&lt;b&gt;" .. args[1] .. "/" .. args[2] .. "&lt;/b&gt;")
  end
end
registerAnonymousEventHandler("RefreshInfobox", "avalonUI.onRefreshInfobox")
--raiseEvent("RefreshInfobox", ???)

function avalonUI.onFlushInfoboxBuffer(event, args)

  -- Buffer in die Info-Box schreiben
  clearWindow("Infobox")
    showWindow("Infobox")
    if avalonUI.runiInfoBox ~= nil then
      avalonUI.runiInfoBox:hide()
    end
  avalonUI.infoScreen:cecho("&lt;white&gt;"..GUIModel.infoBoxBuffer.."\n")
  -- Buffer leeren
  GUIModel.infoBoxBuffer = ""
  -- Timer setzen, der nach 15 Sekunden wieder default herstellt
  -- Timer muss zurückgesetzt werden, wenn vor Ablauf dieser Zeit der Buffer wieder in die InfoBox geschrieben wird
  if GUIModel.infoBoxTempTimerID ~= nil then
    killTimer(GUIModel.infoBoxTempTimerID)
    --GUIModel.infoBoxTempTimerID=nil;
  end
  GUIModel.infoBoxTempTimerID = tempTimer(15, function() GUIModel.infoBoxTempTimerID=nil; raiseEvent("RefreshInfobox") end, false)

end
registerAnonymousEventHandler("FlushInfoboxBuffer", "avalonUI.onFlushInfoboxBuffer")
--raiseEvent("FlushInfoboxBuffer", ???)

function avalonUI.showInfoBoxDefault()

end

function avalonUI.showInfoBoxRuni()

end

function avalonUI.showInfoBoxInfo()

end

</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createGuildInfoBoxModel</name>
				<packageName></packageName>
				<script>function avalonUI.createGuildInfoBoxModel()

  GUIModel.guildInfoBoxModel = GUIModel.guildInfoBoxModel or {}
  
  avalonUI.infoScreenVisibility = infoScreenVisibility or true


  --if player.gilde == "Runenschmiede" then
    --avalonUI.createRuniInfoBoxModel()
  --  avalonUI.test()
  --else
  --  
  --end

end

function avalonUI.ruebersichtTEST()

  local ITEM = { "Langschwert", "Grossschild", "Helm", "Panzer", "Handschuhe", "Stiefel" }
  local RUNE_STATE = { "noch sehr gut", "noch gut", "noch ganz gut", "noch ausreichend", "kaum noch" }
  local ITEM_STATE = { "nicht", "sehr leicht", "leicht", "recht", "schwer", "sehr schwer" }
  local RUNE_CHARGE = { "positiv", "negativ", "neutral" } --Reihenfolge nicht verändern!
--math.random(1,6)

  local function getRunes()
    local str = ""

    str = str .. '"Rune1":{"zustand":"'.. RUNE_STATE[math.random(1,5)] ..'","ladung":"'.. RUNE_CHARGE[math.random(1,3)] ..'","name":"Rune1"}, '
    str = str .. '"Rune2":{"zustand":"'.. RUNE_STATE[math.random(1,5)] ..'","ladung":"'.. RUNE_CHARGE[math.random(1,3)] ..'","name":"Rune2"}, '
    str = str .. '"Rune3":{"zustand":"'.. RUNE_STATE[math.random(1,5)] ..'","ladung":"'.. RUNE_CHARGE[math.random(1,3)] ..'","name":"Rune3"}, '
    str = str .. '"Rune4":{"zustand":"'.. RUNE_STATE[math.random(1,5)] ..'","ladung":"'.. RUNE_CHARGE[math.random(1,3)] ..'","name":"Rune4"}, '
    str = str .. '"Rune5":{"zustand":"'.. RUNE_STATE[math.random(1,5)] ..'","ladung":"'.. RUNE_CHARGE[math.random(1,3)] ..'","name":"Rune5"}, '
    str = str .. '"Rune6":{"zustand":"'.. RUNE_STATE[math.random(1,5)] ..'","ladung":"'.. RUNE_CHARGE[math.random(1,3)] ..'","name":"Rune6"}, '
    str = str .. '"Rune7":{"zustand":"'.. RUNE_STATE[math.random(1,5)] ..'","ladung":"'.. RUNE_CHARGE[math.random(1,3)] ..'","name":"Rune7"}, '
    str = str .. '"Rune8":{"zustand":"'.. RUNE_STATE[math.random(1,5)] ..'","ladung":"'.. RUNE_CHARGE[math.random(1,3)] ..'","name":"Rune8"}'

    return str
  end

  ----jsonFormattedGuildInfo = '[{"typ":["Waffe"],"zustand":"nicht","runen":{"Zielrune":{"zustand":"noch sehr gut","ladung":"negativ","name":"Zielrune"},"Paraderune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Paraderune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Machtrune":{"zustand":"noch sehr gut","ladung":"negativ","name":"Machtrune"},"Kampfrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Kampfrune"}},"item":"Langschwert"},{"typ":["Waffe"],"zustand":"nicht","runen":{"Zielrune":{"zustand":"noch sehr gut","ladung":"negativ","name":"Zielrune"},"Paraderune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Paraderune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Machtrune":{"zustand":"noch sehr gut","ladung":"negativ","name":"Machtrune"},"Kampfrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Kampfrune"}},"item":"Grossschild"},{"typ":["Koerper"],"zustand":"nicht","runen":{"Schlangenrune":{"zustand":"noch sehr gut","ladung":"negativ","name":"Schlangenrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Panzerrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Panzerrune"},"Sturmrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Sturmrune"}},"item":"Silberpanzer"},{"typ":["Kopf"],"zustand":"nicht","runen":{"Staubrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Staubrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Panzerrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Panzerrune"}},"item":"Helm"},{"typ":["Bein"],"zustand":"nicht","runen":{"Staubrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Staubrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Panzerrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Panzerrune"}},"item":"Paar Stiefel"},{"typ":["Arm"],"zustand":"nicht","runen":{"Staubrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Staubrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Panzerrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Panzerrune"}},"item":"Paar Handschuhe"}]'

  jsonFormattedGuildInfo = ''
  jsonFormattedGuildInfo = jsonFormattedGuildInfo .. '{"items": ['
  jsonFormattedGuildInfo = jsonFormattedGuildInfo .. '{"typ":["Waffe"],"zustand":"'.. ITEM_STATE[math.random(1,6)] ..'","runen":{'..getRunes()..'},"item":"Langschwert"}, '
  jsonFormattedGuildInfo = jsonFormattedGuildInfo .. '{"typ":["Waffe"],"zustand":"'.. ITEM_STATE[math.random(1,6)] ..'","runen":{'..getRunes()..'},"item":"Grossschild"}, '
  jsonFormattedGuildInfo = jsonFormattedGuildInfo .. '{"typ":["Koerper"],"zustand":"'.. ITEM_STATE[math.random(1,6)] ..'","runen":{'..getRunes()..'},"item":"Silberpanzer"}, '
  jsonFormattedGuildInfo = jsonFormattedGuildInfo .. '{"typ":["Kopf"],"zustand":"'.. ITEM_STATE[math.random(1,6)] ..'","runen":{'..getRunes()..'},"item":"Helm"}, '
  jsonFormattedGuildInfo = jsonFormattedGuildInfo .. '{"typ":["Bein"],"zustand":"'.. ITEM_STATE[math.random(1,6)] ..'","runen":{'..getRunes()..'},"item":"Paar Stiefel"}, '
  jsonFormattedGuildInfo = jsonFormattedGuildInfo .. '{"typ":["Arm"],"zustand":"'.. ITEM_STATE[math.random(1,6)] ..'","runen":{'..getRunes()..'},"item":"Paar Handschuhe"}],'
  jsonFormattedGuildInfo = jsonFormattedGuildInfo .. '"ladung": "'..RUNE_CHARGE[math.random(1,2)]..'"}'

  --DIESE TESTDATEN ENTSPRECHEN NICHT DEM AKTUELLEN SCHEMA!
  --jsonFormattedGuildInfo = '[{"typ":["Waffe"],"zustand":"nicht","runen":{"Zielrune":{"zustand":"noch sehr gut","ladung":"negativ","name":"Zielrune"},"Paraderune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Paraderune"},"Todesrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Todesrune"},"Machtrune":{"zustand":"noch sehr gut","ladung":"negativ","name":"Machtrune"},"Kampfrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Kampfrune"}},"item":"Mithrilzweihaender"},{"typ":["Koerper"],"zustand":"nicht","runen":{"Schlangenrune":{"zustand":"noch sehr gut","ladung":"negativ","name":"Schlangenrune"},"Panzerrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Panzerrune"},"Sturmrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Sturmrune"}},"item":"Silberpanzer"},{"typ":["Kopf"],"zustand":"nicht","runen":{"Staubrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Staubrune"},"Panzerrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Panzerrune"}},"item":"Helm"},{"typ":["Bein"],"zustand":"nicht","runen":{"Staubrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Staubrune"},"Panzerrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Panzerrune"}},"item":"Paar Stiefel"},{"typ":["Arm"],"zustand":"nicht","runen":{"Staubrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Staubrune"},"Panzerrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Panzerrune"}},"item":"Paar Handschuhe"}]'
  --jsonFormattedGuildInfo = '[{"typ":["Waffe"],"zustand":"sehr leicht","runen":{"Flutrune":{"zustand":"noch gut","ladung":"neutral","name":"Flutrune"},"Eilrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Eilrune"}},"item":"Zwergenaxt"},{"typ":["Waffe"],"zustand":"sehr leicht","runen":{"Koboldrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Koboldrune"},"Eilrune":{"zustand":"noch gut","ladung":"neutral","name":"Eilrune"},"Funkenrune":{"zustand":"noch gut","ladung":"neutral","name":"Funkenrune"}},"item":"Zwergenaxt"},{"typ":["Kopf"],"zustand":"sehr leicht","runen":{},"item":"Bergwerkshelm"},{"typ":["Arm","Koerper"],"zustand":"sehr leicht","runen":{"Panzerrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Panzerrune"},"Eisrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Eisrune"}},"item":"Kettenmantel"},{"typ":["Bein"],"zustand":"sehr leicht","runen":{"Staubrune":{"zustand":"noch gut","ladung":"neutral","name":"Staubrune"},"Panzerrune":{"zustand":"noch gut","ladung":"neutral","name":"Panzerrune"}},"item":"Paar Stiefel"}]'
  --jsonFormattedGuildInfo = '[{"typ":["Waffe"],"zustand":"nicht","runen":{"Schlachtrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Schlachtrune"},"Eilrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Eilrune"}},"item":"Daemonenschwinge"},{"typ":["Arm"],"zustand":"sehr leicht","runen":{"Staubrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Staubrune"},"Panzerrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Panzerrune"}},"item":"Daemonenfaeuste"},{"typ":["Koerper"],"zustand":"sehr leicht","runen":{"Panzerrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Panzerrune"},"Staubrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Staubrune"},"Federrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Federrune"}},"item":"Daemonenpanzer"},{"typ":["Bein"],"zustand":"leicht","runen":{"Staubrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Staubrune"},"Panzerrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Panzerrune"}},"item":"Daemonenstiefel"},{"typ":["Kopf"],"zustand":"sehr leicht","runen":{"Staubrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Staubrune"},"Panzerrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Panzerrune"}},"item":"Daemonenhelm"}]'
  --jsonFormattedGuildInfo = '[{"typ":["Waffe"],"zustand":"sehr schwer","runen":{"Schlachtrune":{"zustand":"kaum noch","ladung":"neutral","name":"Schlachtrune"},"Eilrune":{"zustand":"noch ausreichend","ladung":"neutral","name":"Eilrune"}},"item":"Daemonenschwinge"},{"typ":["Arm"],"zustand":"schwer","runen":{"Staubrune":{"zustand":"noch ganz gut","ladung":"neutral","name":"Staubrune"},"Panzerrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Panzerrune"}},"item":"Daemonenfaeuste"},{"typ":["Koerper"],"zustand":"recht","runen":{"Panzerrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Panzerrune"},"Staubrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Staubrune"},"Federrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Federrune"}},"item":"Daemonenpanzer"},{"typ":["Bein"],"zustand":"leicht","runen":{"Staubrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Staubrune"},"Panzerrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Panzerrune"}},"item":"Daemonenstiefel"},{"typ":["Kopf"],"zustand":"sehr leicht","runen":{"Staubrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Staubrune"},"Panzerrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Panzerrune"}},"item":"Daemonenhelm"}]'
  --jsonFormattedGuildInfo = '[{"typ":["Schild"],"zustand":"sehr leicht","runen":{},"item":"Rundschild"},{"typ":["Waffe"],"zustand":"sehr leicht","runen":{"Flutrune":{"zustand":"noch gut","ladung":"neutral","name":"Flutrune"},"Eilrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Eilrune"}},"item":"Zwergenaxt"},{"typ":["Koerper"],"zustand":"sehr leicht","runen":{"Schlangenrune":{"zustand":"noch sehr gut","ladung":"negativ","name":"Schlangenrune"},"Panzerrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Panzerrune"},"Eisrune":{"zustand":"noch sehr gut","ladung":"positiv","name":"Eisrune"}},"item":"Silberharnisch"},{"typ":["Kopf"],"zustand":"sehr leicht","runen":{"Wallrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Wallrune"},"Nebelrune":{"zustand":"noch sehr gut","ladung":"neutral","name":"Nebelrune"}},"item":"Helm"},{"typ":["Bein"],"zustand":"sehr leicht","runen":{"Staubrune":{"zustand":"noch gut","ladung":"neutral","name":"Staubrune"},"Panzerrune":{"zustand":"noch gut","ladung":"neutral","name":"Panzerrune"}},"item":"Paar Stiefel"}]'

  --avalonGildenInfo = {}
  --avalonGildenInfo = yajl.to_value(jsonFormattedGuildInfo)
  --avalonUI.createRuniInfoBoxModel(avalonGildenInfo)

  raiseEvent("AvalonGildenInfo", jsonFormattedGuildInfo)

end

-- Hier wird zwischen der Anzeige der "ruebersicht"-Ausgabe und der
-- normalen InfoBox hin und her geschaltet.
function avalonUI.toggleInfoScreen()

  if avalonUI.infoScreenVisibility == true then

    avalonUI.infoScreenVisibility = false
    hideWindow("Infobox")
    avalonUI.runiInfoBox:show()

  elseif avalonUI.infoScreenVisibility == false then

    avalonUI.infoScreenVisibility = true
    showWindow("Infobox")
    avalonUI.runiInfoBox:hide()

  end

end

function avalonUI.showGuildInfoScreen(guildInfoScreenName)

    hideWindow("Infobox")
    avalonUI.runiInfoBox:show()

end --avalonUI.showGuildInfoScreen(guildInfoScreenName)

function avalonUI.processGuildInfo(arg)

  local avalonGildenInfo = {}
  local guildInfoScreenName = nil
  
  local jsonFormattedGuildInfo = arg

  if (player.gilde == "Runenschmiede") or (player.name == "rofhessa") or (player.name == "groundsel") then

    avalonGildenInfo = yajl.to_value(jsonFormattedGuildInfo)
    avalonUI.createRuniInfoBoxModel(avalonGildenInfo)
    GUIModel.runiInfoBoxModel = GUIModel.runiInfoBoxModel or avalonUI.buildRuniInfoScreen()
    guildInfoScreenName = "GUIModel.runiInfoScreenView"

  else
    cecho("&lt;magenta&gt;FEHLER: avalonGildenInfo per ATCP erhalten.\n")
  end
  
  --avalonUI.toggleInfoScreen()
  avalonUI.showGuildInfoScreen(guildInfoScreenName)

  if GUIModel.infoBoxTempTimerID ~= nil then
  --echo("kill timerID: "..GUIModel.infoBoxTempTimerID.."\n")
    killTimer(GUIModel.infoBoxTempTimerID)
    --GUIModel.infoBoxTempTimerID=nil;
  end
  GUIModel.infoBoxTempTimerID = tempTimer(30, function() GUIModel.infoBoxTempTimerID=nil; raiseEvent("RefreshInfobox") end, false)

end
registerAnonymousEventHandler("ProcessGuildInfo", "avalonUI.processGuildInfo")

--createRuniInfoBoxModel
function avalonUI.createRuniInfoBoxModel(avalonGildenInfo)

  local runiGuildInfo = avalonGildenInfo

  avalonUI.runiInfoBoxModel = avalonUI.runiInfoBoxModel or {}

  local RUNE_NOCH_SEHR_GUT = "noch sehr gut"
  local RUNE_NOCH_GUT = "noch gut"
  local RUNE_NOCH_GANZ_GUT = "noch ganz gut"
  local RUNE_NOCH_AUSREICHEND = "noch ausreichend"
  local RUNE_KAUM_NOCH = "kaum noch"
  
  local RUNE_COLOR = {
    [RUNE_NOCH_SEHR_GUT]    = "#00ff00",
    [RUNE_NOCH_GUT]         = "#00ff00",
    [RUNE_NOCH_GANZ_GUT]    = "#00b300",
    [RUNE_NOCH_AUSREICHEND] = "#ff3300",
    [RUNE_KAUM_NOCH]        = "#800000"
  }
  
  local BESCHAEDIGT_NICHT = "nicht"
  local BESCHAEDIGT_SEHR_LEICHT = "sehr leicht"
  local BESCHAEDIGT_LEICHT = "leicht"
  local BESCHAEDIGT_RECHT = "recht"
  local BESCHAEDIGT_SCHWER = "schwer"
  local BESCHAEDIGT_SEHR_SCHWER = "sehr schwer"
  --local BESCHAEDIGT_ZERBROCHEN = ""
  
  local ITEM_COLOR = {
    [BESCHAEDIGT_NICHT]       = "#00ff00",
    [BESCHAEDIGT_SEHR_LEICHT] = "#00ff00",
    [BESCHAEDIGT_LEICHT]      = "#00b300",
    [BESCHAEDIGT_RECHT]       = "#00b300",
    [BESCHAEDIGT_SCHWER]      = "#ff3300",
    [BESCHAEDIGT_SEHR_SCHWER] = "#800000"
  }
  
  local ITEM_TYPE_WEAPON = "Waffe"
  local ITEM_TYPE_SHIELD = "Schild"
  local ITEM_TYPE_HEAD = "Kopf"
  local ITEM_TYPE_BODY = "Koerper"
  local ITEM_TYPE_LEGS = "Bein"
  local ITEM_TYPE_ARMS = "Arm"
  
  local CHARGE_POSITIVE = "positiv"
  local CHARGE_NEGATIVE = "negativ"
  local CHARGE_NONE = "neutral"
  
  local CHARGE_SYMBOL = {
    [CHARGE_POSITIVE] = "&amp;#91;&amp;#x2002;&amp;#43;&amp;nbsp;&amp;#93;&amp;nbsp;",   --[ + ]
    [CHARGE_NEGATIVE] = "&amp;#91;&amp;nbsp;&amp;minus;&amp;nbsp;&amp;#93;&amp;nbsp;",   --[ - ] --&amp;#45;
    [CHARGE_NONE]     = "&amp;nbsp;"   --"&amp;#91;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;#93;&amp;nbsp;"   --[   ]
  }    

  local objItem = {
    iName = "",
    iID = "",
    iType = "",
    iState = "",
    iColor = "",
    iRunes = {}
  }
  
  local objRune = {
    rName  = "",
    rCharge = "",
    rChargeSymbol = "",
    rState = "",
    rColor = ""
  }
  
  GUIModel.guildInfoBoxModel["iWeapon"] = objItem
  GUIModel.guildInfoBoxModel["iShield"] = objItem
  GUIModel.guildInfoBoxModel["iHead"]   = objItem
  GUIModel.guildInfoBoxModel["iBody"]   = objItem
  GUIModel.guildInfoBoxModel["iLegs"]   = objItem
  GUIModel.guildInfoBoxModel["iArms"]   = objItem

  avalonUI.runiInfoBoxModel.HammerCharge = avalonUI.runiInfoBoxModel.HammerCharge or CHARGE_POSITIVE

  avalonUI.runiInfoBoxModel.HammerCharge = runiGuildInfo["ladung"]

  local weaponCounter = 0
  local item = nil
  local runen = nil
  local runes_pos = nil
  local runes_neg = nil
  local runes_neu = nil

  for _, v in pairs(runiGuildInfo["items"]) do

    for _, w in pairs (v["typ"]) do

      item = {}
  
      item.iName = v["item"]
      item.iID = v["id"]
      item.iType = w--v["typ"]
      item.iState = v["zustand"]
      item.iColor = ITEM_COLOR[v["zustand"]]
      
      runen = {}
      runes_pos = {}
      runes_neg = {}
      runes_neu = {}

      for _, x in pairs (v["runen"]) do

        local rune = {}
        rune.rName = x["name"]
        rune.rCharge = x["ladung"]
        rune.rChargeSymbol = CHARGE_SYMBOL[x["ladung"]]
        rune.rState = x["zustand"]
        rune.rColor = RUNE_COLOR[x["zustand"]]

        if rune.rCharge == CHARGE_POSITIVE then
          table.insert(runes_pos, rune)
        elseif rune.rCharge == CHARGE_NEGATIVE then
          table.insert(runes_neg, rune)
        else
          table.insert(runes_neu, rune)
        end 

        rune = nil
        
      end

      -- Die einzelnen Runen-Listen werden jetzt noch alphabetisch sortiert
      local sortMyRunes = function(a, b) return a["rName"] &lt; b["rName"] end
      table.sort(runes_pos, sortMyRunes)
      table.sort(runes_neg, sortMyRunes)
      table.sort(runes_neu, sortMyRunes)
      
      for _, y in pairs (runes_pos) do
        table.insert(runen, y)
      end
      runes_pos = {}
      
      for _, y in pairs (runes_neu) do
        table.insert(runen, y)
      end
      runes_neu = {}
        
      for _, y in pairs (runes_neg) do
        table.insert(runen, y)
      end
      runes_neg = {}
      
      item.iRunes = runen
      runen = {}

      if w == ITEM_TYPE_WEAPON then

        if weaponCounter == 0 then
        
          GUIModel.guildInfoBoxModel["iWeapon"] = item
          weaponCounter = 1
        elseif weaponCounter == 1 then
          GUIModel.guildInfoBoxModel["iShield"] = item
          weaponCounter = 2
        else
          cecho("&lt;magenta&gt;\nFEHLER in der Funktion avalonUI.createRuniInfoBoxModel() - Waffenzähler ist: "..weaponCounter.."/n")
        end
        
      elseif w == ITEM_TYPE_SHIELD then
        GUIModel.guildInfoBoxModel["iShield"] = item
      elseif w == ITEM_TYPE_HEAD then
        GUIModel.guildInfoBoxModel["iHead"] = item
      elseif w == ITEM_TYPE_BODY then
        GUIModel.guildInfoBoxModel["iBody"] = item
      elseif w == ITEM_TYPE_LEGS then
        GUIModel.guildInfoBoxModel["iLegs"] = item
      elseif w == ITEM_TYPE_ARMS then
        GUIModel.guildInfoBoxModel["iArms"] = item
      else
        cecho("&lt;magenta&gt;\nFEHLER in der Funktion avalonUI.createRuniInfoBoxModel() - Gegenstandstyp ist: "..w.."/n")
      end
      item = nil
      item = objItem
    end
  end
 
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createMapperModel</name>
				<packageName></packageName>
				<script>--createMapperModel()

function avalonUI.createMapperModel()

end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createAlertsModel</name>
				<packageName></packageName>
				<script>-- alertModel
-- Hier geht es um die Message-Boxen, die halbtransparent über dem Hauptfenster eingeblendet werden.
-- Diese Boxen sollen wichtige Informationen aus dem Scroll aufnehmen und hervorheben.
-- Dazu gehören die Informationes-Boxen, die Avalon sendet. Also wenn eine neue Stufe bzw. ein neues
-- Level erreicht wurde beispielsweise. Dazu gehört aber auch, wenn Ausrüstung kaputt geht oder überhaupt
-- alle mehr oder weniger dringenden Informationen. Für Runenschmiede werden hier Statusinformationen
-- zu den Runen hervorgehoben.

-- function avalonUI.createAlertsModel()
-- Initialisierung von allem hier.
function avalonUI.createAlertsModel()
  avalonUI.listOfAlerts = avalonUI.listOfAlerts or {}
end -- function avalonUI.createAlertModel()


function avalonUI.addAlert(name,pic,content,expired)
  table.insert(avalonUI.listOfAlerts, {["name"] = name, ["pic"] = pic, ["content"] = content, ["starttime"] = os.time(), ["expired"] = expired})
end

function avalonUI.updateAlert(name,pic,content,expired)

end


-- function sortListOfTimers()
-- Rückgabewert: die sortierte Timer-Liste als Tabelle
-- Hier wird die Liste mit den Timern vor der Ausgabe nach Laufzeit sortiert. Als erstes kommen dabei die
-- Timer ohne Laufzeit, also "permantente Timer". Was nicht heißt, dass die länger laufen müssen als die
-- "temporären Timer". Da die Liste der Timer auf der Oberfläche von UNTEN nach OBEN ausgegeben wird, stehen
-- die "permanenten Timer" dort also UNTEN!. Auch wenn sie hier die ersten in der sortierten Liste sein werden.
-- Durch die Sortierung nach Laufzeit ergibt sich bei den temporären Timern manchmal die Situation, dass 
-- ein weiter oben in der Ansicht stehender Timer (= geringe Restlaufzeit) noch einen längeren Fortschritts-
-- Balken hat als ein weiter unten stehender (= längere Laufzeit). Beispielsweise wird der Timer für 
-- "EP-Verdoppelung" mit einer Laufzeit von 1 Stunde und einer Restlaufzeit von 12 Minuten nur noch einen 
-- sehr kurzen Fortschrittsbalken haben, aber trotzdem noch länger laufen als ein frischer Arkanschild mit 
-- einer Laufzeit von 10 Minuten maximal. Ich fand das manchmal irritierend und hab überlegt, die Restlaufzeit
-- mit im Timer anzuzeigen. Aber eigentlich sind mir das zu viele (letztlich überflüssige) Informationen.
-- Diese Funktion wird jedesmal ausgeführt, wenn das UI-Element für die Timer aktualisiert wird. Also einmal
-- pro Sekunde derzeit.
function avalonUI.sortListOfAlerts()
	-- debugc("func sortListOfTimers()")
  
  local sortedListOfTimers = {}
  local remaining = 0
  
  for k, v in pairs(avalonUI.listOfTimers) do
		
    -- Wenn die "duration" auf "false" gesetzt ist, dann ist es ein Timer ohne Laufzeit, der die ganze
    -- Zeit mit vollem Fortschrittsbalken angezeigt wird. Und der durch einen Schluss-Trigger gelöscht
    -- werden muss. Sonst steht er bis zum Neustart von Mudlet in der Timer-Übersicht. (TODO!)
    if v["duration"] == "false" then
      
      -- Damit das mit dem sortieren der Liste klappt, werden hier etwas willkürlich die Werte für
      -- remaining und duration gesetzt. Wichtig ist, dass die Zahl größer ist als der am längsten
      -- laufende temporäre Timer. Das ist im Moment "EP-Verdoppelung" mit 3600 Sekunden.
      table.insert(sortedListOfTimers, {["name"] = v["name"], ["remaining"] = 60000, ["duration"] = 60000})

    -- Wenn "duration" NICHT false ist, ist es ein "temporärer Timer" mit abnehmendem Fortschrittsbalken.
    else
      
      -- Restlaufzeit frisch berechnen
      remaining = (tonumber(v["duration"]) - ((os.time() - v["starttime"])))

      -- Wenn der Timer aus irgendwelchen Gründen übrig geblieben ist, soll er trotzdem irgendwann 
      -- gelöscht werden. Gründe könnten sein, dass die Ausgabe des MUDs irgendwie durcheinander geraten
      -- ist und der Beenden-Trigger deshalb nicht gegriffen hat. Oder ein connection lost oder was auch
      -- immer. Einen konkreten Grund gab es nicht, das ist eine Vorsichtsmaßnahme.
      -- Ein temporärer Timer (mit einer Laufzeit) wird also gelöscht, wenn er 30 Sekunden oder mehr über
      -- seine Laufzeit ist. Unter sehr ungünstigen Umständen (starke lags) kann es sein, dass 30 Sekunden
      -- nicht reichen. Aber ich glaube, dass das nur extrem selten passieren kann.
      -- Wenn der aktuelle Timer abgelaufen ist, dann ist der Schleifendurchlauf damit ja auch beendet. 
      if remaining &lt;= -30 then
        avalonUI.removeTimer(v["name"])
      else
        table.insert(sortedListOfTimers, {["name"] = v["name"], ["remaining"] = remaining, ["duration"] = v["duration"]})
      end
    end
  end

  -- Die fertige Timer-Liste wird jetzt noch nach Laufzeit sortiert
  local sortMyTimers = function(a, b) return a["remaining"] &gt; b["remaining"] end
  table.sort(sortedListOfTimers, sortMyTimers)

  return sortedListOfTimers

end --function sortListOfTimers()


-- function findTimerByName(name)
-- Hier wird der KEY des Timers in der Timer-Liste an Hand seines Namens
-- ermittelt. Wenn kein Timer mit dem Namen zu finden ist, gibt die
-- Funktion nil zurück.
function avalonUI.findAlertByName(name)
	--debugc("findTimerByName\n")

  --[[Wenn der Name bspswse "Erdaura" lautet, dann muss gefunden werden:
  "Erdaura I", "Erdaura II", "Erdaura III".
  Analog dazu die anderen Auren. Und Schild I bis V]]
  
  --https://stackoverflow.com/questions/29072601/lua-string-gsub-with-a-hyphen
  --[[
  local function replace(str, what, with)
    what = string.gsub(what, "[%(%)%.%+%-%*%?%[%]%^%$%%]", "%%%1") -- escape pattern
    with = string.gsub(with, "[%%]", "%%%%") -- escape replacement
    return string.gsub(str, what, with)
  end
  
  result = replace(data, value_1, value_2)
  result = replace(date, "-", "%-")
  
  s = string.gsub("Lua is cute", "cute", "great")
  
  lua if string.find("EP-Verdoppelung", "EP%-Verdoppelung") then echo("true") else echo("false") end
  ]]
  --[[string.find funktioniert nicht mit Zeichen wie dem Bindestrich. Das führte zu Problemen bei dem 
  Timer für "EP-Verdoppelung".]]
  for k, v in pairs(avalonUI.listOfTimers) do
      ----if v["name"] == name then return k end
      --if string.find(v["name"], name) then return k end
      if string.find(v["name"], string.gsub(name, "%-", "%%-")) then return k end
      
  end
  return nil
end -- function findTimerByName(name)


-- Diese Funktion wird von den Triggern verwendet, die einen Timer erzeugen.
-- Der Timer wird hier der Tabelle "listOfTimer" hinzugefügt, anschließend
-- wird die Tabelle mit den sortierten Timern neu erzeugt und die Anzeige
-- auf der Oberfläche aktualisiert.
function avalonUI.registerAlert(name, duration, param)
  --debugc("\nregisterTimer\n")
  param = param or nil
  if param ~= nil then
    name = name .. " " .. param
  end
  if duration == false or duration == nil then
    duration = "false"
  end
  
  if name == "Schild" then
    if string.find(player.schutz, name .. " V") then
      name = name .. " V"
    elseif string.find(player.schutz, name .. " IV") then
      name = name .. " IV"
    elseif string.find(player.schutz, name .. " III") then
      name = name .. " III"
    elseif string.find(player.schutz, name .. " II") then
      name = name .. " II"
    elseif string.find(player.schutz, name .. " I") then
      name = name .. " I"
      duration = "180"
    end
  end
  
  if name == "Weissschild" or name == "Schwarzschild" then
    if string.find(player.schutz, name .. " II") then
      name = name .. " II"
    elseif string.find(player.schutz, name .. " I") then
      name = name .. " I"
    end
  end
  
  if name == "Erdaura" or name == "Feueraura" or name == "Lebensaura" or name == "Todesaura" or name == "Luftaura" or name == "Wasseraura" then
    if string.find(player.schutz, name .. " III") then
      name = name .. " III"
      duration = "1200"
    elseif string.find(player.schutz, name .. " II") then
      name = name .. " II"
    elseif string.find(player.schutz, name .. " I") then
      name = name .. " I"
    end
  end

  table.insert(avalonUI.listOfTimers, {["name"] = name, ["starttime"] = os.time(), ["duration"] = duration})

  raiseEvent("RecreateTimerView")
end



-- function removeTimer("Magiertrance")
-- Diese Funktion wird aufgerufen, wenn ein Timer gelöscht werden soll. Also wenn er 
-- abgelaufen ist (bei denen, die von selbst terminieren) oder wenn das Ereignis ausgelöst
-- wird, das den Timer beendet. (Das ist der häufigere Fall, weil sich die Anzeige da
-- letztlich nach dem MUD richtet. Wenn das MUD sagt, dass die KB aus ist, dann ist sie aus.
-- Viele Zauber sind ohnehin nicht sonderlich pünktlich, aber die Laufzeit kann sich auch 
-- durch lags verlängern. Teilweise ganz erheblich. Das "von selbst terminieren" ist deshalb
-- eigentlich unglücklich, geht aber manchmal nicht anders. Beispiel dafür ist die 
-- "EP-Verdoppelung", die vom MUD nicht abgekündigt wird.)
-- Speziell die Kleriker-Segen machen hier eine Sonderbehandlung notwendig, womit sich der
-- Parameter "param" begründet. Da diese Segen (Rüstungssegen, Waffensegen und Schildsegen)
-- die gleichen Texte ausgeben, und der Trigger deshalb nicht erkennen kann, mit welchem 
-- Zauber er es zu tun hat. Und da aber beim LÖSCHEN des Timers wichtig ist, nicht den falschen
-- zu löschen. Versucht der Trigger, den GEGENSTAND, auf den Gezaubert wird, aus dem getriggerten
-- Text auszulesen. Was auch eigentlich ganz gut gelingt, aber nicht immer schick ist. Dieser
-- Gegenstands-Name wird dann für den Namen des Timers verwendet. Es ergibt sich also sowas wie
-- "Segen: Langschwert" oder (schlimmstenfalls) "Segen: Paar Echsenlederhandschuhe". Wenn der Timer
-- dann später gelöscht werden soll, muss das mit diesem Namen geschehen. Und der steht hier im
-- Parameter "param". Diese Lösung ist nicht schön, und wenn die Götter mein flehentliches Bitten
-- erhören, bekommt Avalet hoffentlich künftig den Zauber per ATCP. Aber erstmal ist es jetzt so.
function avalonUI.removeAlert(name)
  -- debugc("removeTimer\n")

  key = avalonUI.findTimerByName(name)
  if key ~= nil then
    table.remove(avalonUI.listOfTimers, key)
  end
  
  -- Die Anzeige auf der Oberfläche erneuern:
  raiseEvent("RecreateTimerView")
end --function removeTimer(name)


function avalonUI.deregisterAlert(name, param)
  -- Der Parameter "param" ist optional und wird hier deshalb erstmal zuverlässig gemacht.
  -- Wenn ein param gegeben ist, wird er zum Teil des Namens.
  param = param or nil
  if param ~= nil then
    name = name .. " " .. param
  end

  avalonUI.removeTimer(name)
  raiseEvent("RecreateTimerView")
end


-- function recreateTimer()
-- Diese Funktion baut die Timer-Anzeige auf der Oberfläche neu auf. Das heißt,
-- sie macht erstmal alle Timer-Gauges unsichtbar, bevor sie die Funktion aufruft,
-- die neue Timer macht ("refreshTimer()"). Der Sinn ist, dass nicht bei jeder
-- Aktualisierung der Timer-Gauges diese erstmal unsichtbar gemacht werden. Nötig
-- ist das ja nur, wenn sich die Anzahl der Timer verändert.
function avalonUI.recreateAlerts()
	--debugc("func recreateTimer\n")
  
  -- Alle Timer unsichtbar machen und Beschriftung löschen. Es gibt
  -- 9 Gauge-Elemente auf der Oberfläche, also (max) 9 Timer:
  for k = 1, 9, 1 do
    hideWindow("avalonUI.Timer"..k.."_front")
    hideWindow("avalonUI.Timer"..k.."_back")	
    avalonUI["Timer"..k]:setText ("")
  end

  -- Timer-Anzeige neu aufbauen:
  avalonUI.refreshTimer()
end --function recreateTimer()


-- function refreshTimer()
-- Wird durch den Sekunden-Timer direkt aufgerufen
-- Wird bei anderen Gelegenheiten indirekt über "recreateTimer()" aufgerufen.
-- Diese Funktion aktualisiert die Anzeige der Timer auf der Oberfläche bzw.
-- sie sorgt überhaupt für eine Anzeige von Timern auf der Oberfläche.
-- Wenn sich die Anzahl der anzuzeigenden Timer nicht ändernt, müssen die Gauge-
-- Elemente vorher nicht unsichtbar gemacht werden. Wenn sich die Anzahl ändert,
-- wird "recreateTimer()" ausgeführt (und von dort dann diese Funktion).
function avalonUI.refreshAlerts()
	--debugc("func refreshTimer\n")

  -- gleich wieder aussteigen, wenn es gar keine Timer gibt:
  -- Hintergrund: bei einem Disconnect ist manchmal der TriggerTimer aktiv
  -- geblieben. Nach dem reconnect ist allerdings die Timer-Liste leer,
  -- so dass der Timer läuft, aber nichts angezeigt wird. Besser wäre
  -- vermutlich, die Timer vernünftig zu inititalisieren, also ggf. auch
  -- Timer weiterlaufen zu lassen. (EP-Verdoppelung war es hier, vielleicht
  -- weil der Timer nicht durch einen Trigger beendet wird.) TODO
  if #avalonUI.listOfTimers == nil or #avalonUI.listOfTimers == 0 then
      disableTimer("avaletTimersTimer")
  end
  
  -- Erstmal die Timer-Liste sortieren lassen:
	local sortedListOfTimers = avalonUI.sortListOfTimers()

	local timerSchriftfarbe = "white"
  
  for k, v in pairs(sortedListOfTimers) do
    showWindow("avalonUI.Timer"..k.."_front")
    showWindow("avalonUI.Timer"..k.."_back")		
    -- Der Wert des Gauge-Elements, das die Restzeit anzeigt, darf
    -- nicht kleiner als 1 werden, sonst kommt die Anzeige durcheinander.
    -- Außerdem wird die Schriftfarbe verändert:
    -- "fuchsia" für 0 Sekunden Restlaufzeit und alles drüber hinaus.
    -- "rot" für 30 bis 1 Sekunde Restlaufzeit.
    -- "gelb" für 60 bis 30 Sekunden Restlaufzeit.
    -- "weiß" immer sonst
    if v["remaining"] &lt; 1 then
      v["remaining"] = 1
      timerSchriftfarbe="fuchsia"
    elseif v["remaining"] &lt; 30 then
      timerSchriftfarbe="red"
    elseif v["remaining"] &lt; 60 then
      timerSchriftfarbe="yellow"
    else
      timerSchriftfarbe="white"
    end
    -- Wert des Timers setzen:
    avalonUI["Timer"..k]:setValue(tonumber(v["remaining"]), tonumber(v["duration"]), [[&lt;b&gt;&lt;font color="]]..timerSchriftfarbe..[["&gt;&amp;nbsp;]] .. v["name"] .. [[&lt;/b&gt;&lt;/font&gt;]])
  end
end


-- Hier wird der Sekunden-Timer, der die Timer jeweils neu
-- berechnen lässt, aktiviert bzw. deaktiviert.
function avalonUI.onRecreateAlertsView(event, args)
	--debugc("onRecreateTimerView\n")

  -- Warum auch immer die Anzahl der Elemente in listOfTimers = nil sein sollte...
  if #avalonUI.listOfTimers ~= nil then
    -- Wenn es Timer in der listOfTimers gibt...
    if #avalonUI.listOfTimers &gt; 0 then
      -- ... muss auch der Timer laufen, der einmal pro Sekunde die Timer-Anzeige
      -- auf der Oberfläche aktualisiert.
      enableTimer("avaletTimersTimer")
    else
      -- Ohne anzuzeigende Timer in der Liste kann der Aktualisierungs-Timer Pause machen
      disableTimer("avaletTimersTimer")
    end
  else
    disableTimer("avaletTimersTimer")
  end
  -- Schließlich wird noch die Oberfläche aktualisiert.
  avalonUI.recreateTimer()
end
--registerAnonymousEventHandler("RecreateTimerView", "avalonUI.onRecreateTimerView")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createTimerModel</name>
				<packageName></packageName>
				<script>-- timerModel
-- Hier geht es um die Daten, die unmittelbar auf der Oberfläche angezeigt werden.
-- Also um die Liste mit Timern.
-- Auf der Oberfläche gibt es immer (derzeit: 9) Timer-Gauges, die aber per default unsichtbar
-- sind und auch keinen Beschriftungstext enthalten. Diese "Timer-Slots" sind so sortiert, dass
-- der erste Slot UNTEN ist und der letzte OBEN. DIESE Sortierung findet also nicht hier statt,
-- sondern ist in der Oberfläche fest eingebaut. (Aber sortiert wird hier schon, nämlich nach
-- Restlaufzeit.)

-- function avalonUI.createTimerModel()
-- Initialisierung von allem hier.
function avalonUI.createTimerModel()
  avalonUI.listOfTimers = avalonUI.listOfTimers or {}
end -- function avalonUI.createTimerModel()


-- function sortListOfTimers()
-- Rückgabewert: die sortierte Timer-Liste als Tabelle
-- Hier wird die Liste mit den Timern vor der Ausgabe nach Laufzeit sortiert. Als erstes kommen dabei die
-- Timer ohne Laufzeit, also "permantente Timer". Was nicht heißt, dass die länger laufen müssen als die
-- "temporären Timer". Da die Liste der Timer auf der Oberfläche von UNTEN nach OBEN ausgegeben wird, stehen
-- die "permanenten Timer" dort also UNTEN!. Auch wenn sie hier die ersten in der sortierten Liste sein werden.
-- Durch die Sortierung nach Laufzeit ergibt sich bei den temporären Timern manchmal die Situation, dass 
-- ein weiter oben in der Ansicht stehender Timer (= geringe Restlaufzeit) noch einen längeren Fortschritts-
-- Balken hat als ein weiter unten stehender (= längere Laufzeit). Beispielsweise wird der Timer für 
-- "EP-Verdoppelung" mit einer Laufzeit von 1 Stunde und einer Restlaufzeit von 12 Minuten nur noch einen 
-- sehr kurzen Fortschrittsbalken haben, aber trotzdem noch länger laufen als ein frischer Arkanschild mit 
-- einer Laufzeit von 10 Minuten maximal. Ich fand das manchmal irritierend und hab überlegt, die Restlaufzeit
-- mit im Timer anzuzeigen. Aber eigentlich sind mir das zu viele (letztlich überflüssige) Informationen.
-- Diese Funktion wird jedesmal ausgeführt, wenn das UI-Element für die Timer aktualisiert wird. Also einmal
-- pro Sekunde derzeit.
function avalonUI.sortListOfTimers()
	-- debugc("func sortListOfTimers()")
  
  local sortedListOfTimers = {}
  local remaining = 0
  
  for k, v in pairs(avalonUI.listOfTimers) do
		
    -- Wenn die "duration" auf "false" gesetzt ist, dann ist es ein Timer ohne Laufzeit, der die ganze
    -- Zeit mit vollem Fortschrittsbalken angezeigt wird. Und der durch einen Schluss-Trigger gelöscht
    -- werden muss. Sonst steht er bis zum Neustart von Mudlet in der Timer-Übersicht. (TODO!)
    if v["duration"] == "false" then
      
      -- Damit das mit dem sortieren der Liste klappt, werden hier etwas willkürlich die Werte für
      -- remaining und duration gesetzt. Wichtig ist, dass die Zahl größer ist als der am längsten
      -- laufende temporäre Timer. Das ist im Moment "EP-Verdoppelung" mit 3600 Sekunden.
      table.insert(sortedListOfTimers, {["name"] = v["name"], ["remaining"] = 60000, ["duration"] = 60000})

    -- Wenn "duration" NICHT false ist, ist es ein "temporärer Timer" mit abnehmendem Fortschrittsbalken.
    else
      
      -- Restlaufzeit frisch berechnen
      remaining = (tonumber(v["duration"]) - ((os.time() - v["starttime"])))

      -- Wenn der Timer aus irgendwelchen Gründen übrig geblieben ist, soll er trotzdem irgendwann 
      -- gelöscht werden. Gründe könnten sein, dass die Ausgabe des MUDs irgendwie durcheinander geraten
      -- ist und der Beenden-Trigger deshalb nicht gegriffen hat. Oder ein connection lost oder was auch
      -- immer. Einen konkreten Grund gab es nicht, das ist eine Vorsichtsmaßnahme.
      -- Ein temporärer Timer (mit einer Laufzeit) wird also gelöscht, wenn er 30 Sekunden oder mehr über
      -- seine Laufzeit ist. Unter sehr ungünstigen Umständen (starke lags) kann es sein, dass 30 Sekunden
      -- nicht reichen. Aber ich glaube, dass das nur extrem selten passieren kann.
      -- Wenn der aktuelle Timer abgelaufen ist, dann ist der Schleifendurchlauf damit ja auch beendet. 
      if remaining &lt;= -30 then
        avalonUI.removeTimer(v["name"])
      else
        table.insert(sortedListOfTimers, {["name"] = v["name"], ["remaining"] = remaining, ["duration"] = v["duration"]})
      end
    end
  end

  -- Die fertige Timer-Liste wird jetzt noch nach Laufzeit sortiert
  local sortMyTimers = function(a, b) return a["remaining"] &gt; b["remaining"] end
  table.sort(sortedListOfTimers, sortMyTimers)

  return sortedListOfTimers

end --function sortListOfTimers()


-- function findTimerByName(name)
-- Hier wird der KEY des Timers in der Timer-Liste an Hand seines Namens
-- ermittelt. Wenn kein Timer mit dem Namen zu finden ist, gibt die
-- Funktion nil zurück.
function avalonUI.findTimerByName(name)
	--debugc("findTimerByName\n")

  --[[Wenn der Name bspswse "Erdaura" lautet, dann muss gefunden werden:
  "Erdaura I", "Erdaura II", "Erdaura III".
  Analog dazu die anderen Auren. Und Schild I bis V]]
  
  --https://stackoverflow.com/questions/29072601/lua-string-gsub-with-a-hyphen
  --[[
  local function replace(str, what, with)
    what = string.gsub(what, "[%(%)%.%+%-%*%?%[%]%^%$%%]", "%%%1") -- escape pattern
    with = string.gsub(with, "[%%]", "%%%%") -- escape replacement
    return string.gsub(str, what, with)
  end
  
  result = replace(data, value_1, value_2)
  result = replace(date, "-", "%-")
  
  s = string.gsub("Lua is cute", "cute", "great")
  
  lua if string.find("EP-Verdoppelung", "EP%-Verdoppelung") then echo("true") else echo("false") end
  ]]
  --[[string.find funktioniert nicht mit Zeichen wie dem Bindestrich. Das führte zu Problemen bei dem 
  Timer für "EP-Verdoppelung".]]
  for k, v in pairs(avalonUI.listOfTimers) do
      ----if v["name"] == name then return k end
      --if string.find(v["name"], name) then return k end
      if string.find(v["name"], string.gsub(name, "%-", "%%-")) then return k end
      
  end
  return nil
end -- function findTimerByName(name)


-- Diese Funktion wird von den Triggern verwendet, die einen Timer erzeugen.
-- Der Timer wird hier der Tabelle "listOfTimer" hinzugefügt, anschließend
-- wird die Tabelle mit den sortierten Timern neu erzeugt und die Anzeige
-- auf der Oberfläche aktualisiert.
function avalonUI.registerTimer(name, duration, param)
  --debugc("\nregisterTimer\n")
  param = param or nil
  if param ~= nil then
    name = name .. " " .. param
  end
  if duration == false or duration == nil then
    duration = "false"
  end
  
  if name == "Schild" then
    if string.find(player.schutz, name .. " V") then
      name = name .. " V"
    elseif string.find(player.schutz, name .. " IV") then
      name = name .. " IV"
    elseif string.find(player.schutz, name .. " III") then
      name = name .. " III"
    elseif string.find(player.schutz, name .. " II") then
      name = name .. " II"
    elseif string.find(player.schutz, name .. " I") then
      name = name .. " I"
      duration = "180"
    end
  end
  
  if name == "Weissschild" or name == "Schwarzschild" then
    if string.find(player.schutz, name .. " II") then
      name = name .. " II"
    elseif string.find(player.schutz, name .. " I") then
      name = name .. " I"
    end
  end
  
  if name == "Erdaura" or name == "Feueraura" or name == "Lebensaura" or name == "Todesaura" or name == "Luftaura" or name == "Wasseraura" then
    if string.find(player.schutz, name .. " III") then
      name = name .. " III"
      duration = "1200"
    elseif string.find(player.schutz, name .. " II") then
      name = name .. " II"
    elseif string.find(player.schutz, name .. " I") then
      name = name .. " I"
    end
  end

  table.insert(avalonUI.listOfTimers, {["name"] = name, ["starttime"] = os.time(), ["duration"] = duration})

  raiseEvent("RecreateTimerView")
end



-- function removeTimer("Magiertrance")
-- Diese Funktion wird aufgerufen, wenn ein Timer gelöscht werden soll. Also wenn er 
-- abgelaufen ist (bei denen, die von selbst terminieren) oder wenn das Ereignis ausgelöst
-- wird, das den Timer beendet. (Das ist der häufigere Fall, weil sich die Anzeige da
-- letztlich nach dem MUD richtet. Wenn das MUD sagt, dass die KB aus ist, dann ist sie aus.
-- Viele Zauber sind ohnehin nicht sonderlich pünktlich, aber die Laufzeit kann sich auch 
-- durch lags verlängern. Teilweise ganz erheblich. Das "von selbst terminieren" ist deshalb
-- eigentlich unglücklich, geht aber manchmal nicht anders. Beispiel dafür ist die 
-- "EP-Verdoppelung", die vom MUD nicht abgekündigt wird.)
-- Speziell die Kleriker-Segen machen hier eine Sonderbehandlung notwendig, womit sich der
-- Parameter "param" begründet. Da diese Segen (Rüstungssegen, Waffensegen und Schildsegen)
-- die gleichen Texte ausgeben, und der Trigger deshalb nicht erkennen kann, mit welchem 
-- Zauber er es zu tun hat. Und da aber beim LÖSCHEN des Timers wichtig ist, nicht den falschen
-- zu löschen. Versucht der Trigger, den GEGENSTAND, auf den Gezaubert wird, aus dem getriggerten
-- Text auszulesen. Was auch eigentlich ganz gut gelingt, aber nicht immer schick ist. Dieser
-- Gegenstands-Name wird dann für den Namen des Timers verwendet. Es ergibt sich also sowas wie
-- "Segen: Langschwert" oder (schlimmstenfalls) "Segen: Paar Echsenlederhandschuhe". Wenn der Timer
-- dann später gelöscht werden soll, muss das mit diesem Namen geschehen. Und der steht hier im
-- Parameter "param". Diese Lösung ist nicht schön, und wenn die Götter mein flehentliches Bitten
-- erhören, bekommt Avalet hoffentlich künftig den Zauber per ATCP. Aber erstmal ist es jetzt so.
function avalonUI.removeTimer(name)
  -- debugc("removeTimer\n")

  key = avalonUI.findTimerByName(name)
  if key ~= nil then
    table.remove(avalonUI.listOfTimers, key)
  end
  
  -- Die Anzeige auf der Oberfläche erneuern:
  raiseEvent("RecreateTimerView")
end --function removeTimer(name)


function avalonUI.deregisterTimer(name, param)
  -- Der Parameter "param" ist optional und wird hier deshalb erstmal zuverlässig gemacht.
  -- Wenn ein param gegeben ist, wird er zum Teil des Namens.
  param = param or nil
  if param ~= nil then
    name = name .. " " .. param
  end

  avalonUI.removeTimer(name)
  raiseEvent("RecreateTimerView")
end


-- function recreateTimer()
-- Diese Funktion baut die Timer-Anzeige auf der Oberfläche neu auf. Das heißt,
-- sie macht erstmal alle Timer-Gauges unsichtbar, bevor sie die Funktion aufruft,
-- die neue Timer macht ("refreshTimer()"). Der Sinn ist, dass nicht bei jeder
-- Aktualisierung der Timer-Gauges diese erstmal unsichtbar gemacht werden. Nötig
-- ist das ja nur, wenn sich die Anzahl der Timer verändert.
function avalonUI.recreateTimer()
	--debugc("func recreateTimer\n")
  
  -- Alle Timer unsichtbar machen und Beschriftung löschen. Es gibt
  -- 9 Gauge-Elemente auf der Oberfläche, also (max) 9 Timer:
  for k = 1, 9, 1 do
    hideWindow("avalonUI.Timer"..k.."_front")
    hideWindow("avalonUI.Timer"..k.."_back")	
    avalonUI["Timer"..k]:setText ("")
  end

  -- Timer-Anzeige neu aufbauen:
  avalonUI.refreshTimer()
end --function recreateTimer()


-- function refreshTimer()
-- Wird durch den Sekunden-Timer direkt aufgerufen
-- Wird bei anderen Gelegenheiten indirekt über "recreateTimer()" aufgerufen.
-- Diese Funktion aktualisiert die Anzeige der Timer auf der Oberfläche bzw.
-- sie sorgt überhaupt für eine Anzeige von Timern auf der Oberfläche.
-- Wenn sich die Anzahl der anzuzeigenden Timer nicht ändernt, müssen die Gauge-
-- Elemente vorher nicht unsichtbar gemacht werden. Wenn sich die Anzahl ändert,
-- wird "recreateTimer()" ausgeführt (und von dort dann diese Funktion).
function avalonUI.refreshTimer()
	--debugc("func refreshTimer\n")

  -- gleich wieder aussteigen, wenn es gar keine Timer gibt:
  -- Hintergrund: bei einem Disconnect ist manchmal der TriggerTimer aktiv
  -- geblieben. Nach dem reconnect ist allerdings die Timer-Liste leer,
  -- so dass der Timer läuft, aber nichts angezeigt wird. Besser wäre
  -- vermutlich, die Timer vernünftig zu inititalisieren, also ggf. auch
  -- Timer weiterlaufen zu lassen. (EP-Verdoppelung war es hier, vielleicht
  -- weil der Timer nicht durch einen Trigger beendet wird.) TODO
  if #avalonUI.listOfTimers == nil or #avalonUI.listOfTimers == 0 then
      disableTimer("avaletTimersTimer")
  end
  
  -- Erstmal die Timer-Liste sortieren lassen:
	local sortedListOfTimers = avalonUI.sortListOfTimers()

	local timerSchriftfarbe = "white"
  
  for k, v in pairs(sortedListOfTimers) do
    showWindow("avalonUI.Timer"..k.."_front")
    showWindow("avalonUI.Timer"..k.."_back")		
    -- Der Wert des Gauge-Elements, das die Restzeit anzeigt, darf
    -- nicht kleiner als 1 werden, sonst kommt die Anzeige durcheinander.
    -- Außerdem wird die Schriftfarbe verändert:
    -- "fuchsia" für 0 Sekunden Restlaufzeit und alles drüber hinaus.
    -- "rot" für 30 bis 1 Sekunde Restlaufzeit.
    -- "gelb" für 60 bis 30 Sekunden Restlaufzeit.
    -- "weiß" immer sonst
    if v["remaining"] &lt; 1 then
      v["remaining"] = 1
      timerSchriftfarbe="fuchsia"
    elseif v["remaining"] &lt; 30 then
      timerSchriftfarbe="red"
    elseif v["remaining"] &lt; 60 then
      timerSchriftfarbe="yellow"
    else
      timerSchriftfarbe="white"
    end
    -- Wert des Timers setzen:
    avalonUI["Timer"..k]:setValue(tonumber(v["remaining"]), tonumber(v["duration"]), [[&lt;b&gt;&lt;font color="]]..timerSchriftfarbe..[["&gt;&amp;nbsp;]] .. v["name"] .. [[&lt;/b&gt;&lt;/font&gt;]])
  end
end


-- Hier wird der Sekunden-Timer, der die Timer jeweils neu
-- berechnen lässt, aktiviert bzw. deaktiviert.
function avalonUI.onRecreateTimerView(event, args)
	--debugc("onRecreateTimerView\n")

  -- Warum auch immer die Anzahl der Elemente in listOfTimers = nil sein sollte...
  if #avalonUI.listOfTimers ~= nil then
    -- Wenn es Timer in der listOfTimers gibt...
    if #avalonUI.listOfTimers &gt; 0 then
      -- ... muss auch der Timer laufen, der einmal pro Sekunde die Timer-Anzeige
      -- auf der Oberfläche aktualisiert.
      enableTimer("avaletTimersTimer")
    else
      -- Ohne anzuzeigende Timer in der Liste kann der Aktualisierungs-Timer Pause machen
      disableTimer("avaletTimersTimer")
    end
  else
    disableTimer("avaletTimersTimer")
  end
  -- Schließlich wird noch die Oberfläche aktualisiert.
  avalonUI.recreateTimer()
end
registerAnonymousEventHandler("RecreateTimerView", "avalonUI.onRecreateTimerView")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createHDAModel</name>
				<packageName></packageName>
				<script>-- Hunger-/Durst-/Alkohol-Anzeige (HDA)
-- Die meisten Völker haben 7 unterschiedliche Hunger-Meldungen. Oger und Hobbits haben 13.
-- Die Meldung mit dem Index 1, das ist die "ist völlig gesättigt"-Meldung, soll auf der
-- Oberfläche nicht extra angezeigt werden. Die restlichen Meldungen müssen in den auf der
-- Oberfläche zu sehenden 6 Kästchen angezeigt werden. (Später gibts vielleicht  mal
-- halbe Kästchen, aber erstmal noch nicht.)
-- Zuordnung also:
-- Index Oger/Hobbits | Index andere | Kästchen
--        1                   1           keins
--        2- 3                2           1 (grün)
--        4- 5                3           2 (gelb)
--        6- 7                4           3 (gelb)
--        8- 9                5           4 (gelb)(?)
--       10-11                6           5 (rot)
--       12-13                7           6 (rot)
-- Formel also für Oger und Hobbits: math.ceil((Index + 1) / 2)


local HUNGER_TEXT = {
  "Du hast ein unangenehmes Voellegefuehl.",
  "Du hast ausreichend gegessen.",
  "Dein Magen knurrt.",
  "Du verspuerst Hunger.",
  "Dir wird fast schlecht vor Hunger.",
  "Deine Gedanken kreisen nur noch um Deinen Hunger.",
  "Wenn Du jetzt nicht bald was zwischen die Zaehne bekommst ..."
}

-- Hunger-Meldungen für Hobbits.
-- Im MUD ist einer mehrzeilig, und zwar der hier:
-- "Wenn Du nicht langsam etwas isst, wirst Du Deine Vorfahren begruessen"
-- "koennen."
local HUNGER_HOBBIT_TEXT = {
  "Dein Bauch steht dick und rund von Dir ab.",
  "Ein Exxe waere jetzt schon explodiert, aber Du bist gerade mal satt.",
  "Dein Bauch ist schon recht prall.",
  "Du bist schon ein bisschen satt.",
  "Ein Mensch waere jetzt zwar satt, aber Du kannst noch 'ne Menge vertragen.",
  "Du hast gerade mal ausreichend gegessen.",
  "Dein Magen verlangt nach einer Zwischenmahlzeit.",
  "Du koenntest jetzt schon gut etwas zu beissen vertragen.",
  "Du hast das Gefuehl, das letzte Essen waere bereits eine Woche her.",
  "Du kannst Dich kaum auf den Beinen halten vor Hunger.",
  "Ein gefuellter Ochse waere jetzt noch zu wenig zum Essen.",
  "Du hast das Gefuehl, ein riesiges Loch im Bauch zu haben.",
  "Wenn Du nicht langsam etwas isst, wirst Du Deine Vorfahren begruessen koennen."
}


-- Hungermeldungen Oger
-- Texte mit Umbruch:
-- "Dein prall gefuellter, riesiger Ogerbauch ist Dein ganzer Stolz."
-- "Du fuehlst Dich satt und gluecklich, ganz so wie Fleissig-"
-- "Oger es verdient."
-- "Ein wenig Platz ist in Deinem Bauch schon noch, aber "
-- "dieses seltsame Knurren ist verschwunden. Fressen aus Leidenschaft "
-- "ist nun angesagt."
-- "Mit ausreichend vollem Magen kannst Du Dich wieder auf "
-- "andere Dinge als die Nahrungsbeschaffung konzentrieren - auf "
-- "das Toeten aus Spass zum Beispiel.
-- "Ein wenig Lust auf Naschen haettest Du ja schon, ob Du irgendwo "
-- "ein leichtes Opfer findest? Das schwarze Buch ist eine gute "
-- "Speisekarte."
-- "Wirklich Hunger hast Du nicht mehr, aber so ein paar kleine "
-- "Orks wuerden Dir noch munden."
-- "Langsam wird es wieder Zeit fuer einen kleinen Snack wie "
-- "zum Beispiel eine Kuh oder ein Schaf - sonst faellst Du noch "
-- "vom Fleisch!"
-- "Dein Magen knurrt in regelmaessigen Abstaenden, sehr zur "
-- "Beunruhigung Deiner Umgebung."
-- "Dein Bauch fuehlt sich leer und hungrig an. Jetzt wird es "
-- "langsam Zeit fuer eine kleinere Zwischenmahlzeit. Ein Elefant "
-- "waere jetzt lecker?"
-- "So hungrig faellt Dir das Denken schwer. Noch schwerer, "
-- "als ohnehin schon."
-- "Wenn Du jetzt nicht bald ein Orkdorf leernaschst..."
-- "So hungrig wie Du bist, wirst Du zur ernsten Gefahr "
-- "fuer Deine Umgebung."
-- "Kurz vor dem Verhungern treibt Dich nur noch ein "
-- "Gedanke an, die Suche nach Fressen!"

local HUNGER_OGER_TEXT = {
	"Dein prall gefuellter, riesiger Ogerbauch ist Dein ganzer Stolz.",
	"Du fuehlst Dich satt und gluecklich, ganz so wie Fleissig-Oger es verdient.",
	"Ein wenig Platz ist in Deinem Bauch schon noch, aber dieses seltsame Knurren ist verschwunden. Fressen aus Leidenschaft ist nun angesagt.",
	"Mit ausreichend vollem Magen kannst Du Dich wieder auf andere Dinge als die Nahrungsbeschaffung konzentrieren - auf das Toeten aus Spass zum Beispiel.",
	"Ein wenig Lust auf Naschen haettest Du ja schon, ob Du irgendwo ein leichtes Opfer findest? Das schwarze Buch ist eine gute Speisekarte.",
	"Wirklich Hunger hast Du nicht mehr, aber so ein paar kleine Orks wuerden Dir noch munden.",
	"Langsam wird es wieder Zeit fuer einen kleinen Snack wie zum Beispiel eine Kuh oder ein Schaf - sonst faellst Du noch vom Fleisch!",
	"Dein Magen knurrt in regelmaessigen Abstaenden, sehr zur Beunruhigung Deiner Umgebung.",
	"Dein Bauch fuehlt sich leer und hungrig an. Jetzt wird es langsam Zeit fuer eine kleinere Zwischenmahlzeit. Ein Elefant waere jetzt lecker?",
	"So hungrig faellt Dir das Denken schwer. Noch schwerer, als ohnehin schon.",
	"Wenn Du jetzt nicht bald ein Orkdorf leernaschst...",
	"So hungrig wie Du bist, wirst Du zur ernsten Gefahr fuer Deine Umgebung.",
	"Kurz vor dem Verhungern treibt Dich nur noch ein Gedanke an, die Suche nach Fressen!",
}



local DURST_TEXT = {
  "Es schwappt und gluckert in Deinem Bauch.",
  "Du hast ausreichend getrunken.",
  "Du hast ein trockenes Gefuehl in der Kehle.", 
  "Du bist durstig.", 
  "Deine Zunge klebt Dir am Gaumen.",       
  "Du kannst vor Durst kaum noch klar denken.",
  "Wenn Du Dir jetzt nicht bald was zwischen die Kiemen kippst ..."
}

local ALKOHOL_TEXT = {
  "Du bist nuechtern.",
  "Du bist wieder nuechtern.",
  "Du bist angeheitert.",
  "Du hast einen Schwips.", 
  "Du bist betrunken.", 
  "Du hast einen maechtigen Rausch.",
  "Du bist sternhagelvoll.",
  "Die Welt dreht sich um Dich."
}

local function getIndexOf(t,val)
  for k,v in ipairs(t) do 
      if v == val then return k end
  end
  return 0
end


function avalonUI.createHDAModel()
  
  avalonUI.hungerIndex = 0
  avalonUI.durstIndex = 0
  avalonUI.alkIndex = 0
  
  --avalonUI.hungerIndex = getIndexOf(HUNGER_TEXT, player.hunger)
  --avalonUI.durstIndex = getIndexOf(DURST_TEXT, player.durst)
  --avalonUI.alkIndex = getIndexOf(ALKOHOL_TEXT, player.alk)
  
  raiseEvent("RefreshHDA")
  
end

function avalonUI.onRefreshHDA()
  
  avalonUI.hungerIndex = getIndexOf(HUNGER_TEXT, player.hunger)
  if avalonUI.hungerIndex == 0 then
    avalonUI.hungerIndex = getIndexOf(HUNGER_HOBBIT_TEXT, player.hunger)
    if avalonUI.hungerIndex ~= 0 then avalonUI.hungerIndex = math.ceil((avalonUI.hungerIndex + 1) / 2) end
  end
  if avalonUI.hungerIndex == 0 then
    avalonUI.hungerIndex = getIndexOf(HUNGER_OGER_TEXT, player.hunger)
    if avalonUI.hungerIndex ~= 0 then avalonUI.hungerIndex = math.ceil((avalonUI.hungerIndex + 1) / 2) end
  end
  avalonUI.durstIndex = getIndexOf(DURST_TEXT, player.durst)
  avalonUI.alkIndex = getIndexOf(ALKOHOL_TEXT, player.alk)
  
  avalonUI.buildHDA()

end
registerAnonymousEventHandler("RefreshHDA", "avalonUI.onRefreshHDA")
--raiseEvent("RefreshHDA", ???)</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createTopMenuModel</name>
				<packageName></packageName>
				<script>-- TopMenu: Das Menü oberhalb des Hauptfensters

-- function avalonUI.createTopMenuModel()
-- Erzeugt die Daten, die dann als Menü oberhalb des Hauptfensters angezeigt werden.
-- Das Zahnrad (für das Einstellungen-Menü) wird (zur Zeit noch) in der View hinzugefügt.
function avalonUI.createTopMenuModel()
  -- Menü-Label dürfen nicht in einem Container sein, deshalb sind die 
  -- Top-Level-Einträge direkt auf der Oberfläche positioniert.
  GUIModel.TopMenuEntries = {}
  --cecho("&lt;magenta&gt;TopMenuEntries\n")
  function addTopMenuEntry(label, position, childs)
  	--TODO: validierung der Parameter (insbesondere der childs)
  	table.insert(GUIModel.TopMenuEntries,position,{label,childs})
  end
  
  -- Dummy-Menü:
  --addTopMenuEntry("Top1", 1, {{"Child1", 1, "label1", "luafun", {"a1","a2","a3"}}, {"Child2", 2, "label2", "luafun",{"a12","a22","a32"}},{"Child3", 1, "label3","luafun",{"a31", "a32", "a33"}}})
  --addTopMenuEntry("Top2", 2, {{"Child1", 1, "label1", "luafun", {"a1","a2","a3"}}, {"Child2", 2, "label2", "luafun",{"a12","a22","a32"}},{"Child3", 1, "label3", "luafun",{"a31", "a32", "a33"}}})
  --addTopMenuEntry("Top1a", 1, {{"Child1", 1, "label1", "luafun", {"a1","a2","a3"}}, {"Child2", 2, "label2", "luafun",{"a12","a22","a32"}},{"Child3", 1, "label3", "luafun",{"a31", "a32", "a33"}}})
  
  -- Muster zum Hinzufügen eines Menüs:
  --addTopMenuEntry(
  --	"Top1", 
  --	1, 
  --	{
  --		{"childName1", 1, "childBeschriftung1", "luafun", {"a1","a2","a3"}}, 
  --		{"childName2", 2, "childBeschriftung2", "luafun", {"a1","a2","a3"}}, 
  --		{"childName1a", 1, "childBeschriftung1a", "luafun", {"a1","a2","a3"}}
  --	}
  --)

end -- function avalonUI.createTopMenuModel()</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createGaugeModel</name>
				<packageName></packageName>
				<script>--createGaugeModel()


function avalonUI.createGaugeModel()

end


--------------------------------------------------------------------------------
-- Refresh Event Handler
--------------------------------------------------------------------------------


function avalonUI.onRefreshHealthBar(event, args)
	-- Das Gauge-Element wird bei einem "current value" von 0 vollständig
	-- gefüllt angezeigt. Und ich hab keine Ahnung, was bei einem negativen
	-- Wert geschehen würde. Deshalb wird hier jeder Wert unter 1 auf 1
	-- gesetzt. In dem Text auf dem Gauge muss aber natürlich der wirkliche
	-- Wert stehen, deshalb die unterschiedliche Behandlung hier.
	local currentValue = args[1]
	if currentValue &lt; 1 then
		currentValue = 1
	end
	
	local percent = -1 --math.ceil((100 / args[2]) * args[1])
  if args[1] == args[2] then
    percent = 100
  elseif args[1] == 0 then
    percent = 0
  else 
    percent = math.floor((100 / args[2]) * args[1])
  end
	
	avalonUI.Health:setValue(tonumber(currentValue), tonumber(args[2]), "&lt;b&gt;&lt;center&gt;" .. args[1] .. "/" .. args[2] .. "&lt;/center&gt;&lt;/br&gt;&lt;center&gt;TP&lt;/center&gt;&lt;/br&gt;&lt;center&gt;("..percent.."%)&lt;/center&gt;&lt;/b&gt;")
	-- avalonUI.Health:setValue(100,100,[[&lt;b&gt;&lt;center&gt;999/999&lt;/center&gt;&lt;/br&gt;&lt;center&gt;TP&lt;/center&gt;&lt;/b&gt;]])
	-- [[&lt;b&gt;&lt;font color="]]..timerSchriftfarbe..[["&gt;&amp;nbsp;]] .. v["name"] .. [[&lt;/b&gt;&lt;/font&gt;]]
end
registerAnonymousEventHandler("RefreshHealthBar", "avalonUI.onRefreshHealthBar")


function avalonUI.onRefreshEnduranceBar(event, args)
	-- Das Gauge-Element wird bei einem "current value" von 0 vollständig
	-- gefüllt angezeigt. Und ich hab keine Ahnung, was bei einem negativen
	-- Wert geschehen würde. Deshalb wird hier jeder Wert unter 1 auf 1
	-- gesetzt. In dem Text auf dem Gauge muss aber natürlich der wirkliche
	-- Wert stehen, deshalb die unterschiedliche Behandlung hier.
	local currentValue = args[1]
	if currentValue &lt; 1 then
		currentValue = 1
	end
	
	local percent = -1 --math.ceil((100 / args[2]) * args[1])
  if args[1] == args[2] then
    percent = 100
  elseif args[1] == 0 then
    percent = 0
  else
    percent = math.floor((100 / args[2]) * args[1])
  end
	
	avalonUI.Endurance:setValue(tonumber(currentValue), tonumber(args[2]), "&lt;b&gt;&lt;center&gt;" .. tostring(args[1]) .. "/" .. tostring(args[2]) .. "&lt;/center&gt;&lt;/br&gt;&lt;center&gt;AP&lt;/center&gt;&lt;/br&gt;&lt;center&gt;("..percent.."%)&lt;/center&gt;&lt;/b&gt;")
end
registerAnonymousEventHandler("RefreshEnduranceBar", "avalonUI.onRefreshEnduranceBar")


function avalonUI.onRefreshSpellpointsBar(event, args)
	-- Das Gauge-Element wird bei einem "current value" von 0 vollständig
	-- gefüllt angezeigt. Und ich hab keine Ahnung, was bei einem negativen
	-- Wert geschehen würde. Deshalb wird hier jeder Wert unter 1 auf 1
	-- gesetzt. In dem Text auf dem Gauge muss aber natürlich der wirkliche
	-- Wert stehen, deshalb die unterschiedliche Behandlung hier.
	local currentValue = args[1]
	if currentValue &lt; 1 then
		currentValue = 1
	end
	
  local percent = -1 --math.ceil((100 / args[2]) * args[1])
  if args[1] == args[2] then
    percent = 100
  elseif args[1] == 0 then
    percent = 0
  else 
    percent = math.floor((100 / args[2]) * args[1])
  end
	
	avalonUI.Spellpoints:setValue(tonumber(currentValue), tonumber(args[2]), "&lt;b&gt;&lt;center&gt;" .. args[1] .. "/" .. args[2] .. "&lt;/center&gt;&lt;/br&gt;&lt;center&gt;ZP&lt;/center&gt;&lt;/br&gt;&lt;center&gt;("..percent.."%)&lt;/center&gt;&lt;/b&gt;")
end
registerAnonymousEventHandler("RefreshSpellpointsBar", "avalonUI.onRefreshSpellpointsBar")


function avalonUI.onRefreshManaBar(event, args)
	-- Das Gauge-Element wird bei einem "current value" von 0 vollständig
	-- gefüllt angezeigt. Und ich hab keine Ahnung, was bei einem negativen
	-- Wert geschehen würde. Deshalb wird hier jeder Wert unter 1 auf 1
	-- gesetzt. In dem Text auf dem Gauge muss aber natürlich der wirkliche
	-- Wert stehen, deshalb die unterschiedliche Behandlung hier.
	local currentValue = args[1]
	if currentValue &lt; 1 then
		currentValue = 1
	end
	
	local percent = -1 --math.ceil((100 / args[2]) * args[1])
  if args[1] == args[2] then
    percent = 100
  elseif args[1] == 0 then
    percent = 0
  else
    percent = math.floor((100 / args[2]) * args[1])
  end
	
	avalonUI.Mana:setValue(tonumber(currentValue), tonumber(args[2]), "&lt;b&gt;&lt;center&gt;" .. args[1] .. "/" .. args[2] .. " Mana ("..percent.."%)&lt;/center&gt;&lt;/b&gt;")
end
registerAnonymousEventHandler("RefreshManaBar", "avalonUI.onRefreshManaBar")


-- Der Tick-Timer
-- ... versucht anzuzeigen, wann es wieder einen Schub TP, ZP und AP gibt. Das ist alle 42 Sekunden der Fall.
-- Da es aber auch aus anderen Gründen diese Punkte geben kann - Tränke, Honig -, muss  irgendwie sicher gestellt
-- sein, dass der Tick-Timer dadurch nicht durcheinander gerät. Schwierigkeit ist auch, dass es diese Punkte
-- natürlich nur gibt, wenn Punkte fehlen.
-- Vielleicht den Tick-Timer nur laufen lassen, wenn die Punkte nicht alle auf MAX stehen.</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createSettingsModel</name>
				<packageName></packageName>
				<script>--createSettingsModel

function avalonUI.createSettingsModel()
  -- Generelle Variablen für das Tab-Element
  GUIModel.settingsElement = GUIModel.settingsElement or {
    tabs = {"Diverses", "Chat-Tabs", "Farben", "Über Avalet"},
  }
  -- Speichert das aktuell ausgewählte Element:
  GUIModel.settingsElement.currentTab = GUIModel.settingsElement.currentTab or GUIModel.settingsElement.tabs[1]
  
  for k,v in pairs(GUIModel.tabElement.tabs) do
  
    avalonUI.chats[v] = {}
    
  end
  
  GUIModel.settingsElement.timerGaugeDirection = "goofy" --or ""

end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createIGMapModel</name>
				<packageName></packageName>
				<script>

avalonUI.IGMapModel = avalonUI.IGMapModel or {}

function avalonUI.createIGMapModel()

  avalonUI.IGMapModel.room = ""
  
  avalonUI.IGMapModel.igmap = ""
  
  avalonUI.IGMapModel.avalonRoomInv = ""

end

function avalonUI.refreshIGMapModel(room, igmap, inv)

  if room then avalonUI.IGMapModel.room = room end
  if igmap then avalonUI.IGMapModel.igmap = igmap end
  if inv then avalonUI.IGMapModel.avalonRoomInv = inv end

  

end


-- Diese Funktion wird immer ausgeführt, wenn per ATCP Daten eintreffen, die in der Infobox
-- im Defaulttext angezeigt werden.
function avalonUI.onRefreshIngameMap(event, args)
  
  avalonUI.IGMapModel.room = avalonUI.IGMapModel.room or ""
  avalonUI.IGMapModel.avalonRoomInv = avalonUI.IGMapModel.avalonRoomInv or ""

  avalonUI.Box41a:echo("&lt;center&gt;"..avalonUI.IGMapModel.room.."&lt;/center&gt;")
  avalonUI.Box41c:echo("&lt;center&gt;"..avalonUI.IGMapModel.avalonRoomInv.."&lt;/center&gt;")
--[[  
  if player.istDunkel == "1" then
    GUIModel.infobox = GUIModel.infobox .. "\nAufenthaltsort: &lt;zu dunkel&gt;\n"
  else
    GUIModel.infobox = GUIModel.infobox .. "\nAufenthaltsort: " .. player.avalonRoomID .. "\n"
  end
]]

end
registerAnonymousEventHandler("RefreshIngameMap", "avalonUI.onRefreshIngameMap")

--  raiseEvent("RefreshIngameMap", arg)


-- Der ATCP-Wert "avalon.inv" enthält den Rauminhalt. Dazu gehören Spieler ebenso wie
-- Gegner, Möbel und anderes. Dieser Wert wird nicht automatisch gesendet sondern muss
-- aktiv angefragt werden. Hier wird der Wert dann verarbeitet.
function avalonUI.onProcessAvalonInv(event, args)
  --[[Bespielwert:  
  hier avalon/spieler/rofhessa "Ruad Rofhessa", avalon/wesen/cb2c195b91d1addd4ea6d40422e12ef7 "Putzteufelchen", avalon/objekt/21d7dc3e612dc0c3547cceebb151e889 "Briefkasten"
  
  komma-separiert, nur am ende ist kein komma
  
  vorgehen:
  "hier " entfernen
  rest am komma zerlegen
  jede einheit einzelnd verarbeiten
]]

  local arg = args
  local objs = {}
  local objType
  local objIID
  local objName

  -- erstmal das führende "hier " abtrennen
  arg = string.gsub(arg, "hier (.*)", "%1")

  -- den Rest in die einzelnen Objekte zerlegen
  for i in string.gmatch(arg, "[^,]+") do

    for objIID, objName in string.gmatch(i, '([^"]+)["]([^"]+)["]') do
      --echo("\nName: "..name)
      
      objType = string.gsub(objIID, "avalon/([^/]+)/.+", "%1")
      
      table.insert(objs, {["Type"]=objType, ["IID"]=objIID, ["Name"]=objName})
      
    end

  end
--[[  
table.fixed {table-layout:fixed; width:90px;}/*Setting the table width is important!*/
table.fixed td {overflow:hidden;}/*Hide text outside the cell.*/
table.fixed td:nth-of-type(1) {width:20px;}/*Setting the width of column 1.*/
table.fixed td:nth-of-type(2) {width:30px;}/*Setting the width of column 2.*/
 ]] 
  local str = "&lt;div style='vertical-align: top; text-align: left'&gt;&lt;table style='table-layout:fixed;width:90%'&gt;&lt;tr&gt;"
  local word
  
  local strSpieler = ""
  local strWesen = ""
  local strObject = ""
  local strSonstiges = ""
  
  for k,v in pairs(objs) do
    if v["Type"] == "spieler" then
      strSpieler = strSpieler..v["Name"].."&lt;br&gt;"
    elseif v["Type"] == "wesen" then
      strWesen = strWesen..v["Name"].."&lt;br&gt;"
    elseif v["Type"] == "objekt" then
      strObject = strObject..v["Name"].."&lt;br&gt;"
    else
      strSonstiges = strSonstiges..v["Name"].."&lt;br&gt;"
    end
  end
  
  str = str .. "&lt;td style='overflow:hidden;width:40%;padding-right:15px;'&gt;" .. strSpieler .. strWesen .. "&lt;/td&gt;"
  str = str .. "&lt;td style='overflow:hidden;width:40%'&gt;" .. strObject .. strSonstiges .. "&lt;/td&gt;"
  
--  str = str .. "&lt;td style='max-width: 20pt; padding-right: 15px;table-layout:fixed;overflow:hidden;'&gt;" .. strSpieler .. strWesen .. "&lt;/td&gt;"
--  str = str .. "&lt;td style='width: 20%table-layout:fixed;overflow:hidden;'&gt;" .. strObject .. strSonstiges .. "&lt;/td&gt;"
  --[[
  &lt;table style="width:100%"&gt;
  &lt;tr&gt;
    &lt;th&gt;Firstname&lt;/th&gt;
    &lt;th&gt;Lastname&lt;/th&gt;
    &lt;th&gt;Age&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Jill&lt;/td&gt;
    &lt;td&gt;Smith&lt;/td&gt;
    &lt;td&gt;50&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;Eve&lt;/td&gt;
    &lt;td&gt;Jackson&lt;/td&gt;
    &lt;td&gt;94&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
]]
  --for word in string.gmatch(arg, '%s["]([^"]+)["]') do str = str .. word .. "&lt;br&gt;" end
  str = str .."&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;"
  
  avalonUI.IGMapModel.avalonRoomInv = str

  raiseEvent("RefreshIngameMap", arg)


end
registerAnonymousEventHandler("ProcessAvalonInv", "avalonUI.onProcessAvalonInv")


</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>View</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>buildUI</name>
				<packageName></packageName>
				<script>function avalonUI.buildUI()
  --avalonUI.buildBoxes()
  avalonUI.buildInfoScreen()
  --avalonUI.buildGuildInfo()
  --avalonUI.buildMapper()
  avalonUI.buildChat()
  avalonUI.buildTopBar()
  avalonUI.buildCounter()
  avalonUI.buildTimer()
  avalonUI.buildHDA()
  raiseEvent("RefreshHDA")
  
  --Hier wird der "Info-Bereich" wieder nach vorn gestellt, damit er die Karte überlagert
  GUIframe.activate("Charakter")
  
  avalonUI.buildSettingsDialog()
  
  GUIframe.disable("top")
  GUIframe.disable("bottom")
  GUIframe.disable("right")
  GUIframe.disable("left")
end

function unlockUI()
  --GUIframe.enable("top")
  --GUIframe.enable("bottom")
  GUIframe.enable("right")
  GUIframe.enable("left")
  avalonUI.buildChat()
  raiseEvent("RecreateTimerView")
end

function lockUI()
  GUIframe.disable("top")
  GUIframe.disable("bottom")
  GUIframe.disable("right")
  GUIframe.disable("left")
  avalonUI.buildChat()
  raiseEvent("RecreateTimerView")
end


-- Diese Funktion wird durch den "sysInstall"-Event aufgerufen, also bei jedem
-- Neustart von Mudlet. Hier wird Avalet initialisiert. Eine weitere Funktion,
-- die beim "sysInstall"-Event aufgerufen wird, steht weiter unten.
function avalonUI.UIInstalled(_, name)
  if name ~= "Avalet" then
    return
  else
    player = avalonUI.initCharacter()
    avalonUI.initTimer()
    
    GUIModel = GUIModel or {}
    avalonUI.createInfoScreenModel()
    avalonUI.createGuildInfoBoxModel()
    avalonUI.createChatModel()
    avalonUI.createTopMenuModel()
    --avalonUI.createMapperModel()
    avalonUI.createTimerModel()
    avalonUI.createHDAModel()
    avalonUI.createIGMapModel()
    avalonUI.createCounterModel()
    avalonUI.createGaugeModel()  

    avalonUI.createSettingsModel()  
    
    avalonUI.buildUI()
    --tempTimer(0, [[avalonUI.updateChar()]])
  end
end
registerAnonymousEventHandler("sysInstall", "avalonUI.UIInstalled")


</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildBoxes</name>
				<packageName></packageName>
				<script>----------------------------------------
-- Boxes
-- Die Boxen definieren die entgültige Unterteilung der Oberfläche. Es gibt also eine Boxen
-- für die Elemente, die TP, ZP, AP und Mana anzeigen. (Links unten.) Eine weitere für die 
-- Timer links in der Mitte. Eine weitere für das Karten-Widget links oben. Eine für die
-- Charakterinformationen rechts oben. Und eine für das Tab-Element rechts unten.
-- Im Bereich oben in der Mitte gibt es keine Box. Der Grund ist oben bei den Backgrounds 
-- dokumentiert.
-- Die Boxen haben hauptsächlich den Zweck, einen (derzeit weißen) Rahmen um die Bereiche 
-- anzeigen zu können. Ansonsten sind sie Container für weitere Elemente, die die dort
-- sichtbaren Informationen anzeigen.
----------------------------------------
-- wird nicht verwendet!
function avalonUI.buildBoxes()
  -- Box1 ist das Element rechts oben, in dem die Charakterinformationen ausgegeben werden.
  avalonUI.Box1 = Geyser.Label:new({
  	name = "avalonUI.Box1",
  	x = 0, y = 0,
  	width = "100%",
  	height = "50%",
  })
  avalonUI.Box1:setStyleSheet(avalonUI.CSS.boxCSS:getCSS())
  --avalonUI.Box1:echo("&lt;center&gt;avalonUI.Box1")
  GUIframe.addWindow(avalonUI.Box1, 'Box1', 'topright')
  
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildChat</name>
				<packageName></packageName>
				<script>--------------------------------------------
--- Tabs-Element rechts unten
-------------------------------------------
function avalonUI.buildChat()

  -- Box2: In diesem Bereich wird das Tabulatoren-Element rechts unten angezeigt.
  avalonUI.Box2 = Geyser.Label:new({
  	name = "avalonUI.Box2",
  	x = 0, y = "50%",
  	width = "100%",-- 50%
  	height = "50%",
  })--, avalonUI.Right)
  avalonUI.Box2:setStyleSheet(avalonUI.CSS.boxCSS:getCSS())
  GUIframe.addWindow(avalonUI.Box2, "Chat", "bottomright", true)

  
  avalonUI.tabElement = {}
  -- Container, der alles andere enthält. Container sind unsichtbar, deshalb kein Stylesheet
  avalonUI.tabElement.Container = Geyser.Container:new({
    name = "avalonUI.tabElement.Container",
    x = "3%", y = "3%",
    width = "94%",
    height = "94%",
  }, avalonUI.Box2)

  -- die Kopfzeile des Tab-Elements, also da wo die Tabs sind
  avalonUI.tabElement.Header = Geyser.HBox:new({
    name = "avalonUI.tabElement.Header",
    x = 0, y = 0,
    width = "100%",
    height = "10%",
  }, avalonUI.tabElement.Container)


  -- Der Körper des Tab-Elements, also da wo der Inhalt steht.
  -- Der Container für jeden Tab-Inhalt
  avalonUI.tabElement.Footer = Geyser.Label:new({
    name = "avalonUI.tabElement.Footer",
    x = 0, y = "10%",
    width = "100%",
    height = "90%",
  }, avalonUI.tabElement.Container)
  avalonUI.tabElement.Footer:setStyleSheet(avalonUI.CSS.tabElementFooterCSS:getCSS())


  -- Each window actually has two labels. One for the light blue background,
  -- and another for the dark blue center. This will create that dark blue center. 
  avalonUI.tabElement.Center = Geyser.Label:new({
    name = "avalonUI.tabElement.Center",
    x = 0, y = 0,
    width = "100%",
    height = "100%",
  }, avalonUI.tabElement.Footer)
  avalonUI.tabElement.Center:setStyleSheet(avalonUI.CSS.tabElementCenterCSS:getCSS())


  -- Hier werden die Tabs und die Seiten dazu erzeugt.
  avalonUI.tabElement.tabs = {}

	for k, v in pairs(GUIModel.tabElement.tabs) do
	
		if avalonUI.tabElement.tabs[v.."tab"] == nil then

			-- Erzeugt einen Tab für jeden Eintrag in der Menu-Liste
			avalonUI.tabElement.tabs[v.."tab"] = Geyser.Label:new({
				name = "avalonUI.tabElement.tabs."..v.."tab",
			  }, avalonUI.tabElement.Header)
			avalonUI.tabElement.tabs[v.."tab"]:setFontSize(avalonUI.chatTabFontSize)	  
			avalonUI.tabElement.tabs[v.."tab"]:setStyleSheet(avalonUI.CSS.MenuTabCSS:getCSS())
			avalonUI.tabElement.tabs[v.."tab"]:echo("&lt;center&gt;"..v)

			-- We need our tabs to do stuff when clicked, so we'll assign it 
     -- a callback function, avalonUI.tabElement.tabs.click, which we'll create later on.
     -- Our tab name is the argument. 
			avalonUI.tabElement.tabs[v.."tab"]:setClickCallback("avalonUI.tabElementOnClick", v)

			-- Now we create the windows that appear when each tab is clicked.
     -- Each window has two labels, one atop the other. The first, which we'll create here,
     -- has rounded edges on its bottom. 
			avalonUI.tabElement.tabs[v] = Geyser.Label:new({
				name = "avalonUI.tabElement.tabs."..v,
				x = 0, y = 0,
				width = "100%",
				height = "100%",
			  }, avalonUI.tabElement.Footer)
			avalonUI.tabElement.tabs[v]:setStyleSheet(avalonUI.CSS.tabElementAtopCSS:getCSS())
			-- The second label serves as the window's center and has rounded edges on all sides. 
     -- And a margin of 5px from it's parent, the label we just created. When adding stuff
     -- to your windows, this is the label you'll want to use. avalonUI.tabElement.tabs.&lt;tabname&gt;center
			avalonUI.tabElement.tabs[v.."center"] = Geyser.Label:new({
				name = "avalonUI.tabElement.tabs."..v.."center",
				x = 0, y = 0,
				width = "100%",
				height = "100%",
			  }, avalonUI.tabElement.tabs[v])
			avalonUI.tabElement.tabs[v.."center"]:setStyleSheet(avalonUI.CSS.tabElementCenterTabCSS:getCSS())

			--------
			-- Inhalte der Tabs
			-- Alle Tabs enthalten eine Mini-Console.
			-- Bei den Kanal-Tabs wird dort die Ausgabe der entsprechenden Kanäle gesammelt angezeigt.
			-- Bei anderen Tabs gibt es andere Inhalte.
			-- Jede Minikonsole ist ansprechbar über ... ???
			avalonUI.tabElement.tabs[v.."console"] = Geyser.MiniConsole:new({
				name=string.title(v),
				x="2%", y="2%",
				width = "98%",
				height = "96%",
				autoWrap = true,
				color = "black",
				scrollBar = true,--false,
				fontSize = avalonUI.chatFontSize,
			}, avalonUI.tabElement.tabs[v.."center"])
			debugc("&lt;magenta&gt;Consolen-Name: "..string.title(v).."\n")
			--setWindowWrap(string.title(v), 56) --wirkt nicht wegen "autowrap=true"
      --setWindowWrapIndent(string.title(v), 3) --wirkte auch ohne autowrap nicht.
			--avalonUI.infoScreen:setColor("black") -- give it a nice black background
			--avalonUI.infoScreen:setFont("Bitstream Vera Sans Mono")
      if avalonUI.font ~= "main" then
        avalonUI.tabElement.tabs[v.."console"]:setFont(avalonUI.font)
      else
        avalonUI.tabElement.tabs[v.."console"]:setFont(getFont("main"))
      end      
			--clearWindow("avalonUI.tabElement.tabs." .. v .. "console")
		--	avalonUI.tabElement.tabs[v.."console"]:echo(GUIModel.tabElement["chat"..v])
			avalonUI.tabElement.tabs[v.."console"]:echo(v)

			-- Finally, we hide all the windows and end the for loop.
			avalonUI.tabElement.tabs[v]:hide()

		end -- if nil
	end  -- for

  raiseEvent("RefreshTabElement", GUIModel.tabElement.currentTab)
  --avalonUI.tabElement.tabs[GUIModel.tabElement.currentTab]:show()
  avalonUI.tabElementOnClick(GUIModel.tabElement.currentTab)

end


-- The last step is to create our callback function for when a tab is clicked.
-- This will hide that tab that is stored in menu.current, set menu.current to
-- the clicked tab, and then show the menu.current tab. 
function avalonUI.tabElementOnClick(tab)
	-- Das hier funktioniert nur, wenn die Tab-Beschriftung dem Channel
	-- entspricht, also dem Namen der Datei, in die die Inhalte des
	-- Tabs vorher geschrieben wurden. Minus dem .txt
--avalonUI.tabElement.tabs[tab.."tab"]:setFontSize(avalonUI.chatTabFontSize)  
  avalonUI.tabElement.tabs[GUIModel.tabElement.currentTab.."tab"]:setStyleSheet(avalonUI.CSS.MenuTabCSS:getCSS())
	avalonUI.tabElement.tabs[GUIModel.tabElement.currentTab]:hide()
	GUIModel.tabElement.currentTab = tab
	--refreshTabElement(tab)
  --echo("TAB: " .. tab .. "\n")
  raiseEvent("RefreshTabElement", tab)
  avalonUI.tabElement.tabs[tab.."tab"]:setStyleSheet(avalonUI.CSS.MenuTabCurrentCSS:getCSS())
  avalonUI.tabElement.tabs[GUIModel.tabElement.currentTab]:show()
end

function avalonUI.markTab(tab)
  --Manche Kanäle haben keinen Tab, der wäre dann hier "nil" (gebrüll z.b.)
  if avalonUI.tabElement.tabs[tab.."tab"] == nil then
    debugc("\n\nTab zum Markieren ist nil: "..tab.."\n\n")
  elseif avalonUI.CSS.MenuTabMarkedCSS == nil then
    debugc("\n\nCSS zum Markieren ist nil: "..tab.."\n\n")
  else
    avalonUI.tabElement.tabs[tab.."tab"]:setStyleSheet(avalonUI.CSS.MenuTabMarkedCSS:getCSS())
  end
  
  --avalonUI.tabElement.tabs[tab.."tab"]:setStyleSheet(avalonUI.CSS.MenuTabMarkedCSS:getCSS())

end


</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildCounter</name>
				<packageName></packageName>
				<script>function avalonUI.buildCounter()

  -- avalonUI.Box4a ist der gesamte Bereich links oben. Er enthält die Uhr und die Ingame-Map.
  -- Die Namensgebenden "Counter" sind umgezogen und stehen jetzt im Info-Bereich (rechts oben).
  -- Da ich die Oberfläche ohnehin neu aufbauen will, spare ich mir das umbenennen und so.
  -- Der gesamte Bereich (also die Box hier) ist ein Container, in dem dann die Unterbereiche
  -- jeweils ein Label haben. Und darin dann weitere Elemente. 
  avalonUI.Box4a = Geyser.Container:new({
  	name = "avalonUI.Box4a",
  	x = "0%", y = "0%",
  	width = "100%",
  	height = "50%",
  })--, avalonUI.Box5a)
  GUIframe.addWindow(avalonUI.Box4a, "Zaehler", "topleft")  

  -- Box für DateTime (?)
  avalonUI.Box42 = Geyser.Label:new({
    name = "DateTime",
    x = "0%", y = "0%",
    width = "100%",
    height = "14%",
  }, avalonUI.Box4a)
  avalonUI.Box42:setStyleSheet(avalonUI.CSS.boxCSS:getCSS())

  -- Box für Zähler
  -- Diese Box wird ausgeblendet und mit der Ingame-Map überlagert.
  -- Ich lasse sie hier drin, weil sie von anderen Programmteilen
  -- verwendet wird und ich mir im Moment nicht die Arbeit machen
  -- will, alles zu überarbeiten. TODO: Später entfernen.
  avalonUI.Box4 = Geyser.Label:new({
    name = "avalonUI.Box4",
    x = "0%", y = "10%",
    width = "100%",
    height = "30%",
  }, avalonUI.Box4a)
  avalonUI.Box4:setStyleSheet(avalonUI.CSS.boxCSS:getCSS())
  --GUIframe.addWindow(avalonUI.Box4, "Zaehler", "topleft")
  avalonUI.Box4:hide()

  -- Box für Ingame-Map
  avalonUI.Box41 = Geyser.Label:new({
    name = "avalonUI.Box41",
    x = "0%", y = "14%",--40
    width = "100%",
    height = "86%",
  }, avalonUI.Box4a)
  avalonUI.Box41:setStyleSheet(avalonUI.CSS.boxCSS:getCSS())

  -- Ausgabelabel für Position (?)
  avalonUI.Box41a = Geyser.Label:new({
    name = "avalonUI.Box41a",
    x = "6%", y = "6%",
    width = "90%",
    height = "7%",
    color = "black",
  }, avalonUI.Box41)
  avalonUI.Box41a:setFontSize(avalonUI.infoBoxFontSize)
  avalonUI.Box41a:setStyleSheet([[
    qproperty-alignment: 'AlignHCenter | AlignVCenter';
  ]])
  --avalonUI.Box41a:setStyleSheet(avalonUI.CSS.boxCSS:getCSS())
--  avalonUI.Box41a:echo("RoomID")
--[[  
  --Bereich für die Map selbst.
  avalonUI.Box41b = Geyser.MiniConsole:new({
      name = "IGMap", 
      --x="50%-"..tostring(3*mapCaptureLen).."c", y="50%", 
      x="15%", y="14%", 
      width = "20c", height = "11c"
    }, avalonUI.Box41)
  avalonUI.Box41b:clear()
  avalonUI.Box41b:echo("+------------------+\n|..................|\n|..................|\n|..................|\n|..................|\n|..................|\n|..................|\n|..................|\n|..................|\n|..................|\n+------------------+")
]]
  -- Ausgabelabel für Room-Inv
  avalonUI.Box41c = Geyser.Label:new({
    name = "avalonUI.Box41c",
    x = "6%", y = "72%",
    width = "88%",
    height = "23%",
    color = "black",
  }, avalonUI.Box41)
  avalonUI.Box41c:setStyleSheet([[
    qproperty-alignment: 'AlignLeft | AlignTop';
  ]])
  avalonUI.Box41c:setFontSize((avalonUI.infoBoxFontSize-1))
--  avalonUI.Box41c:echo("Room-Inv")
  --avalonUI.Box41c:setStyleSheet(avalonUI.CSS.boxCSS:getCSS())

---------------------------------------------------------------------------
  -- Gauges für die Timer
  -- Hier werden (derzeit) 9 Gauge-Elemente für die Timer erzeugt und positioniert.
  -- in der Funktion "recreateTimer" werden die Timer dann alle unsichtbar und
  -- nur die benötigten werden wieder sichtbar und mit Werten beschrieben.
  -- Eigentlich war geplant, die Timer dynamischer zu gestalten, so dass es auch
  -- mehr als neun werden könnten. (Der Rest sollte dann etwas zusammen rücken.)
  -- Aber es scheint nicht möglich zu sein, einmal erzeugte Gauge-Elemente wieder
  -- zu löschen. (Auf nil setzen wirkt jedenfalls nicht.) Deshalb die statische
  -- Lösung und das unsichtbar machen.
  ---------------------------------------------------------------------------
  
  for k = 1, 4, 1 do
    avalonUI["Counter"..k] = Geyser.Label:new({
      name = "avalonUI.Counter"..k,
      x = "3%", y = (4 + (k-1)*20).."%",
      width="94%", height="25%",
    }, avalonUI.Box4)
    avalonUI["Counter"..k]:setStyleSheet(avalonUI.CSS.counterCSS:getCSS())
    avalonUI["Counter"..k]:setFontSize(10)
    avalonUI["Counter"..k]:hide()
  end

  --avalonUI["Counter1"]:echo("&lt;b&gt;&amp;nbsp;Session-EP: 782392&amp;nbsp;")
  --avalonUI["Counter2"]:echo("&lt;b&gt;&amp;nbsp;EP/EP-Verdoppelung: 662958&amp;nbsp;")
  --avalonUI["Counter3"]:echo("&lt;b&gt;&amp;nbsp;EP letzte Stunde: 731294&amp;nbsp;&lt;/b&gt;")
  --avalonUI["Counter4"]:echo("&lt;b&gt;&amp;nbsp;EP/Arkanschild: 43392&amp;nbsp;&lt;/b&gt;&lt;\ br&gt;&amp;nbsp;letzter Wert: 41625&amp;nbsp;")
  --avalonUI["Counter5"]:echo("&lt;b&gt;&amp;nbsp;Kampfdauer: 232s&amp;nbsp;&lt;/b&gt;&lt;\ br&gt;&amp;nbsp;letzter Wert: 376s&amp;nbsp;")

  avalonUI.recreateCounter()

end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildInfoScreen</name>
				<packageName></packageName>
				<script>-----------------------------------------------------
-- Charakter-Informationen rechts oben
-----------------------------------------------------

function avalonUI.buildInfoScreen()

  -- InfoScreenBox ist das Element rechts oben, in dem die Charakterinformationen ausgegeben werden.
  avalonUI.InfoScreenBox = Geyser.Label:new({
  	name = "InfoScreenBox",
  	x=0, y=0, width="100%", height="50%",
  })
  avalonUI.InfoScreenBox:setStyleSheet(avalonUI.CSS.boxCSS:getCSS())
  GUIframe.addWindow(avalonUI.InfoScreenBox, "Charakter", "topright")

--avalonUI.InfoScreenBoxLabel = Geyser.Label:new({
--  name = "avalonUI.InfoScreenBoxLabel",
--  x = "80%", y = "92%",
--  width = "20%", height = "8%",
--  fgColor = "black",
--  color = "SeaGreen",
--  message = [[&lt;center&gt;Standardansicht: "char"&lt;/center&gt;]]
--}, avalonUI.InfoScreenBox)
--avalonUI.InfoScreenBoxLabel:setFontSize(10)

  -- Dieses Element wird für die normale Ausgabe benutzt. Also für Ausgabe
  -- des Default-Textes und für die Anzeige von Spielstand, Inventar,
  -- Gruppen-Informationen und ähnlichem Generell ist es das richtige Element
  -- für alles, was direkt aus dem Hauptfenster übernommen wird. Oder für alles,
  -- was reiner Text ist. Für die Anzeige der Runenschmiede-Informationen, die
  -- grafisch (und auch funktional) etwas aufgehübscht wurde, gibt es ein extra
  -- Element 
  avalonUI.infoScreen = Geyser.MiniConsole:new({
    name="Infobox",
    x="3%", y="3%", width="94%", height="94%",
    autoWrap = false,--true,
    color = "black",
    scrollBar = false,
    fontSize = (avalonUI.infoBoxFontSize),
  }, avalonUI.InfoScreenBox)
  --avalonUI.infoScreen:setColor("black")
  --avalonUI.infoScreen:fg("red")
  --avalonUI.infobox:setFont("Bitstream Vera Sans Mono")
  if avalonUI.font ~= "main" then
    avalonUI.infoScreen:setFont(avalonUI.font)
  else
    avalonUI.infoScreen:setFont(getFont("main"))
  end
  
  setWindowWrap("Infobox", 79)
  clearWindow("Infobox")
 --[[ 
  -- Wenn der Spieler schon Runenschmied ist, dann kann
  -- hier auch gleich die Infobox für "ruebersicht" erzeugt werden.
  if player.gilde == "Runenschmied" then
    avalonUI.buildRuniInfoScreen()
  elseif player.name == "rofhessa" then
    -- nur für debug, kann später weg
    avalonUI.buildRuniInfoScreen()
    --avalonUI.buildGuildRuniInfo()
  else
    -- nix  
  end
]]
end





-- Hier wird die Box erzeugt, die für die Ausgabe von "ruebersicht" der
-- Runenschmiede vorgesehen ist. Sie wird nur für Runenschmiede erzeugt
-- und sofort unsichtbar gemacht. Wenn der Runenschmied "ruebersicht"
-- eingibt, sendet das MUD per ATCP die Antwort, die Box wird sichtbar
-- gemacht (und die normale InfoBox unsichtbar) und der Runi-Kram wird
-- angezeigt. Gibt der Spieler dann seinen nächsten Befehl ein, der zur
-- Ausgabe von irgendwas in der InfoBox führt, wird dieses Fenster wieder
-- unsichtbar gemacht, das normale InfoBox-Fenster sichtbar, und die Info
-- wird da angezeigt.
function avalonUI.buildRuniInfoScreen()

  GUIModel.runiInfoBoxModel = {}

--  local i = nil --Hilfsvariable für Rüstungsteil bzw.Waffe/Schild&lt;
  
  local imageFolderPath = getMudletHomeDir().."/Avalet/imgs/"
  
  local placeholder = imageFolderPath.."missingImage.png"
  
  local imageHead = imageFolderPath.."head-white.png"
  local imageBody = imageFolderPath.."body-white.png"
  local imageArms = imageFolderPath.."arms-white.png"
  local imageLegs = imageFolderPath.."legs-white.png"
  local imageWeapon = imageFolderPath.."weapon-white.png"
  local imageShield = imageFolderPath.."shield-white.png"
  
  local ITEM_TYPE_WEAPON = "Weapon"
  local ITEM_TYPE_SHIELD = "Shield"
  local ITEM_TYPE_HEAD = "Head"
  local ITEM_TYPE_BODY = "Body"
  local ITEM_TYPE_LEGS = "Legs"
  local ITEM_TYPE_ARMS = "Arms"
  
  local xPosLeft = 0
  local xPosMiddle = "33%"
  local xPosRight = "66%"
  local yPosTop = 0
  local yPosBottom = "45%"
  
  local CHARGE_POSITIVE = "positiv"
  local CHARGE_NEGATIVE = "negativ"
  local CHARGE_NONE = "neutral"
  
  local chargeColor = ""
  if avalonUI.runiInfoBoxModel.HammerCharge == CHARGE_POSITIVE then
    chargeColor = "rgba(0,0,255,0.5)"--"blue"
  elseif avalonUI.runiInfoBoxModel.HammerCharge == CHARGE_NEGATIVE then
    chargeColor = "rgba(255,0,0,0.5)"--"red"
  end

--  local dimension = 100 --Ausdehnung des Symbolbildes der Items, jeweils x und y

--  path = imageFolderPath..imageHead
--  path = path:gsub("[\\/]", "/")
  placeholder = placeholder:gsub("[\\/]", "/")
  
  imageHead = imageHead:gsub("[\\/]", "/")
  imageBody = imageBody:gsub("[\\/]", "/")
  imageArms = imageArms:gsub("[\\/]", "/")
  imageLegs = imageLegs:gsub("[\\/]", "/")
  imageWeapon = imageWeapon:gsub("[\\/]", "/")
  imageShield = imageShield:gsub("[\\/]", "/")
  
  if not (io.exists(placeholder)) then
    cecho("&lt;magenta&gt;Fehler in der RuniInfoBox: Platzhalterbild fehlt.\n")
  else
    if not (io.exists(imageHead)) then imageHead = placeholder end
    if not (io.exists(imageBody)) then imageBody  = placeholder end
    if not (io.exists(imageArms)) then imageArms  = placeholder end
    if not (io.exists(imageLegs)) then imageLegs  = placeholder end
    if not (io.exists(imageWeapon)) then imageWeapon  = placeholder end
    if not (io.exists(imageShield)) then imageShield  = placeholder end
  end

  -- Die Funktion getItemSymbolLabel erzeugt ein Label, in dem ein Bild des Items liegt.
  -- Dieses Bild bildet dann den Hintergrund zu dem Text des Items. Derzeit ist das Bild
  -- nicht an das Item angepasst, sondern nur ein Symbol für Waffe, Schild, Helm, Körper-
  -- panzer, Handschuhe und Stiefel. Wenn in der Übersicht zwei Waffen auftauchen, dann
  -- wird die erste hier mit einem Waffensymbol hinterlegt sein, die Zweite mit einem
  -- Schild.
  local function getItemSymbolLabel(itemType, image, posX, posY, parent)
  
    local symbol = nil

    symbol = Geyser.Label:new({
        name = "RuniInfobox_"..itemType.."Symbol",
        x=posX,y=posY,width="33%",height="45%",
      }, avalonUI.runiInfoBox)
      --setBackgroundColor("RuniInfobox_"..itemType.."Symbol", 0, 0, 0, 10)
      symbol:setStyleSheet([[
            background-image: url("]]..image..[[");
            background-repeat: no-repeat;
            background-position: center;
      ]])
    
    return symbol
    
  end

  -- Die Funktion getItemTextLabel erzeugt ein Label, in dem der Text des Items steht. 
  local function getItemTextLabel(itemType, item, posX, posY, parent)

    local label = nil
    
    local iType = itemType--item.iType
    local iName = item.iName
    local iColor = item.iColor
    local iRunes = item.iRunes
    
    label = Geyser.Label:new({
      name = "RuniInfobox_"..iType.."Text",
      x=posX,y=posY,width="33%",height="45%",
      --vertical-align="top",
    }, avalonUI.runiInfoBox)
    setBackgroundColor("RuniInfobox_"..iType.."Text", 0, 0, 0, 220)--210 zu viel, 240 fast nicht zu sehen
    label:setStyleSheet([[qproperty-alignment: 'AlignTop';padding-left: '20px'; margin: '0px';]])

    local itemText = ""
    itemText = itemText..[[&lt;p&gt;&lt;div style="font-size:16px;margin-bottom:6px"&gt;&lt;b&gt;&lt;font color="]]..iColor..[["&gt;]]..iName..[[&lt;/font&gt;&lt;/b&gt;&lt;/div&gt;]]
    itemText = itemText..[[&lt;div style="font-size:14px"&gt;&lt;b&gt;&lt;table&gt;]]
    if iRunes ~= nil then
      for _, k in pairs(iRunes) do

        local fontColor = nil
      
        if k.rCharge == avalonUI.runiInfoBoxModel.HammerCharge or k.rCharge == CHARGE_NONE then
          fontRuneColor = k.rColor
          fontSymbColor = 'white'
        else
          fontRuneColor = 'grey'
          fontSymbColor = 'grey'
        end
        
        itemText = itemText..[[
          &lt;tr &gt;            
            &lt;td style="text-align: center; color: ]]..fontSymbColor..[[;"&gt;]]..k.rChargeSymbol..[[&lt;/td&gt;
            &lt;td style="background-color: ]]         ..fontRuneColor..[[;"&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
            &lt;td style="text-align: left; color: ]]..fontRuneColor..[[;"&gt;]]..k.rName..[[&lt;/td&gt;
          &lt;/tr&gt;
        ]]
--[==[

      
        local cellColor = nil
      
        if k.rCharge == avalonUI.runiInfoBoxModel.HammerCharge or k.rCharge == CHARGE_NONE then
          cellColor = ' style="background-color: '..chargeColor..';"'
        else 
          cellColor = ''
        end
      
        itemText = itemText..[[&lt;tr&gt;&lt;td style="text-align: center;"]]..cellColor..[[&gt;]]..k.rChargeSymbol..[[&lt;/td&gt;&lt;td&gt;&lt;font color="]]..k.rColor..[["&gt;]]..k.rName..[[&lt;/td&gt;&lt;/tr&gt;&lt;/font&gt;]]
]==]
      end --for
    end --if
    itemText = itemText..[[&lt;/table&gt;&lt;/b&gt;&lt;/div&gt;&lt;/p&gt;]]
    label:echo("")
    label:echo(itemText)

    return label
  end
 
  -- Die Funktion getItemTextAndImage erzeugt ein Label, in dem der Text zum Item steht und in dem das
  -- Symbolbild zum Item als Hintergrundbild angelegt ist. Da hier keine Transparenz für das Bild
  -- erzeugt werden kann, müsste man hier vielleicht ein anderes (von sich aus teil-transparentes) Bild
  -- hinterlegen. Oder irgendwie sonst den "weisser Adler auf weissem Grund"-Effekt vermeiden. Hab ich
  -- nicht weiter verfolgt, aber vielleicht in Zukunft mal. Diese Funktion wird also nicht benutzt.
  local function getItemTextAndImage(itemType, item, posX, posY, image)

    local label = nil
    
    local iType = itemType
    local iName = item.iName
    local iColor = item.iColor
    local iRunes = item.iRunes

    label = Geyser.Label:new({
      name = "RuniInfoBox_"..iType,
      x=posX,y=posY,width="33%",height="50%",
      --vertical-align="top",
    }, avalonUI.runiInfoBox)
    setBackgroundColor("RuniInfoBox_"..iType, 0, 0, 0, 220)--210 zu viel, 240 fast nicht zu sehen
    label:setStyleSheet([[
      qproperty-alignment: 'AlignTop';
      padding: '20px'; 
      margin: '0px';
      background: url("]]..image..[[");
      background-repeat: no-repeat;
      background-size: 300px 300px;
    ]])
 
    local itemText = ""
    itemText = itemText..[[&lt;p&gt;&lt;div style="font-size:16px;"&gt;&lt;b&gt;&lt;font color="]]..iColor..[["&gt;]]..iName..[[&lt;/font&gt;&lt;/b&gt;&lt;/div&gt;]]
    itemText = itemText..[[&lt;div style="font-size:14px"&gt;&lt;b&gt;&lt;table bgcolor=#CCFFFF&gt;]]
    if iRunes ~= nil then
      for _, k in pairs(iRunes) do
        itemText = itemText..[[&lt;tr&gt;&lt;td&gt;]]..k.rChargeSymbol..[[&lt;/td&gt;&lt;td&gt;&lt;font color="]]..k.rColor..[["&gt;]]..k.rName..[[&lt;/td&gt;&lt;/tr&gt;&lt;/font&gt;]]
      end --for
    end --if
    itemText = itemText..[[&lt;/table&gt;&lt;/b&gt;&lt;/div&gt;&lt;/p&gt;]]
    label:echo("")
    label:echo(itemText)

    return label
  end
 
  -- Hauptcontainer
  avalonUI.runiInfoBox = Geyser.Container:new({
    name = "RuniInfoBox",
    x="3%", y="3%", width="94%", height="94%",
  }, avalonUI.InfoScreenBox)
  avalonUI.runiInfoBox:hide()
  
  -- Derzeit werden im Runi-Infoscreen Bilder von den Items im Hintergrund hinter dem Text zu den Items angezeigt.
  -- Da es keine Möglichkeit gibt, in Background-Image in einem Label transparent zu machen, liegen hier zwei
  -- Label übereinander. Im hinten liegenden ist das Bild als border-image, im Label davor der Text. So gehts.
  -- Label für Waffe
  avalonUI.runiInfoBox_weaponSymbol = getItemSymbolLabel(ITEM_TYPE_WEAPON, imageWeapon, xPosLeft, yPosTop)
  avalonUI.runiInfoBox_weaponText = getItemTextLabel(ITEM_TYPE_WEAPON, GUIModel.guildInfoBoxModel["iWeapon"], xPosLeft, yPosTop)
  --avalonUI.runiInfoBox_Weapon = getItemTextAndImage(ITEM_TYPE_WEAPON, GUIModel.guildInfoBoxModel["iWeapon"], xPosLeft, yPosTop, imageWeapon)
  
  -- Label für Schild
  avalonUI.runiInfoBox_shieldSymbol = getItemSymbolLabel(ITEM_TYPE_SHIELD, imageShield, xPosLeft, yPosBottom)
  avalonUI.runiInfoBox_shieldText = getItemTextLabel(ITEM_TYPE_SHIELD, GUIModel.guildInfoBoxModel["iShield"], xPosLeft, yPosBottom)
  --avalonUI.runiInfoBox_Shield = getItemTextAndImage(ITEM_TYPE_SHIELD, GUIModel.guildInfoBoxModel["iShield"], xPosLeft, yPosBottom, imageShield)

  -- Label für Helm
  avalonUI.runiInfoBox_headSymbol = getItemSymbolLabel(ITEM_TYPE_HEAD, imageHead, xPosMiddle, yPosTop)
  avalonUI.runiInfoBox_headText = getItemTextLabel(ITEM_TYPE_HEAD, GUIModel.guildInfoBoxModel["iHead"], xPosMiddle, yPosTop)
  --avalonUI.runiInfoBox_Head = getItemTextAndImage(ITEM_TYPE_HEAD, GUIModel.guildInfoBoxModel["iHead"], xPosMiddle, yPosTop, imageHead)

  -- Label für Körperpanzer
  avalonUI.runiInfoBox_bodySymbol = getItemSymbolLabel(ITEM_TYPE_BODY, imageBody, xPosMiddle, yPosBottom)
  avalonUI.runiInfoBox_bodyText = getItemTextLabel(ITEM_TYPE_BODY, GUIModel.guildInfoBoxModel["iBody"], xPosMiddle, yPosBottom)
  --avalonUI.runiInfoBox_Body = getItemTextAndImage(ITEM_TYPE_BODY, GUIModel.guildInfoBoxModel["iBody"], xPosMiddle, yPosBottom, imageBody)

  -- Label für Handschuhe
  avalonUI.runiGuildBox_armsSymbol = getItemSymbolLabel(ITEM_TYPE_ARMS, imageArms, xPosRight, yPosTop)
  avalonUI.runiGuildBox_armsText = getItemTextLabel(ITEM_TYPE_ARMS, GUIModel.guildInfoBoxModel["iArms"], xPosRight, yPosTop)
  --avalonUI.runiInfoBox_Arms = getItemTextAndImage(ITEM_TYPE_ARMS, GUIModel.guildInfoBoxModel["iArms"], xPosRight, yPosTop, imageArms)

  -- Label für Stiefel
  avalonUI.runiGuildBox_legsSymbol = getItemSymbolLabel(ITEM_TYPE_LEGS, imageLegs, xPosRight, yPosBottom)
  avalonUI.runiGuildBox_legsText = getItemTextLabel(ITEM_TYPE_LEGS, GUIModel.guildInfoBoxModel["iLegs"], xPosRight, yPosBottom)
  --avalonUI.runiInfoBox_Leges = getItemTextAndImage(ITEM_TYPE_LEGS, GUIModel.guildInfoBoxModel["iLegs"], xPosRight, yPosBottom, imageLegs)

  -- Label für die Aufladung des Hammers
  avalonUI.runiGuildBox_Charge = Geyser.Label:new({
      name = "RuniInfobox_Charge",
      x=0,y="90%",width="100%",height="10%",
    }, avalonUI.runiInfoBox)
    setBackgroundColor("RuniInfobox_Charge", 0, 0, 0, 200)
    avalonUI.runiGuildBox_Charge:setFontSize(avalonUI.infoBoxFontSize)
--    avalonUI.runiGuildBox_Charge:setStyleSheet([[  background-color: ]]..chargeColor..[[;]])
    --avalonUI.runiGuildBox_Charge:setStyleSheet([[  background-color: rgba(255,0,0,0.2);]])
--    avalonUI.runiGuildBox_Charge:echo("Aktuelle Ladung des Schmiedehammers: "..avalonUI.runiInfoBoxModel.HammerCharge)
    avalonUI.runiGuildBox_Charge:echo(avalonUI.runiInfoBoxModel.HammerCharge.." geladene Runen sind aktiv")
    --RuniInfobox_Charge:echo("blablabla")

end --avalonUI.buildRuniInfoScreen()




--[=[
function avalonUI.buildGuildRuniInfo()  
  
  local imageFolderPath = getMudletHomeDir().."/Avalet/"
  
  local placeholder = imageFolderPath.."missingImage.png"
  
  local imageHead = imageFolderPath.."head-white.png"
  local imageBody = imageFolderPath.."body-white.png"
  local imageArms = imageFolderPath.."arms-white.png"
  local imageLegs = imageFolderPath.."legs-white.png"
  local imageWeapon = imageFolderPath.."weapon-white.png"
  local imageShield = imageFolderPath.."shield-white.png"
  
  local ITEM_TYPE_WEAPON = "Weapon"
  local ITEM_TYPE_SHIELD = "Shield"
  local ITEM_TYPE_HEAD = "Head"
  local ITEM_TYPE_BODY = "Body"
  local ITEM_TYPE_LEGS = "Legs"
  local ITEM_TYPE_ARMS = "Arms"
  
  local dimension = 100 --Ausdehnung des Symbolbildes der Items, jeweils x und y

--  path = imageFolderPath..imageHead
--  path = path:gsub("[\\/]", "/")
  placeholder = placeholder:gsub("[\\/]", "/")
  
  imageHead = imageHead:gsub("[\\/]", "/")
  imageBody = imageBody:gsub("[\\/]", "/")
  imageArms = imageArms:gsub("[\\/]", "/")
  imageLegs = imageLegs:gsub("[\\/]", "/")
  imageWeapon = imageWeapon:gsub("[\\/]", "/")
  imageShield = imageShield:gsub("[\\/]", "/")
  
  if not (io.exists(placeholder)) then
    cecho("&lt;magenta&gt;Fehler in der RuniInfoBox: Platzhalterbild fehlt.\n")
  else
    if not (io.exists(imageHead)) then imageHead = placeholder end
    if not (io.exists(imageBody)) then imageBody  = placeholder end
    if not (io.exists(imageArms)) then imageArms  = placeholder end
    if not (io.exists(imageLegs)) then imageLegs  = placeholder end
    if not (io.exists(imageWeapon)) then imageWeapon  = placeholder end
    if not (io.exists(imageShield)) then imageShield  = placeholder end
  end

  -- Die Info-Box der Runis besteht aus einem Container, der im oberen Bereich des Hauptfenstes liegt.
  -- In dem Hauptcontainer gibt es ein Label, damit der Container formatiert werden kann. Insbesondere
  -- bekommt er auf diesem Weg den halbtransparenten Hintergrund.
  -- In diesem Haupt-Container gibt es drei weitere Container, die jeweils die ganze Höhe und ein drittel
  -- der Breite des Haupt-Containers einnehmen.
  -- Innerhalb dieser Teil-Container liegen Label, die einmal das Item-Symbol enthalten. Und dann auch
  -- Label, die die Informationen enthalten. Als formatierten Text. Es gibt also dann ZWEI Label für jedes
  -- Item: Head, Body, Arms, Legs, Weapon, Shield

  -- Hauptcontainer
  avalonUI.runiGuildBox_mainContainer = Geyser.Container:new({
    name = "avalonUI.runiGuildBox_mainContainer",
    x="3%", y="3%", width="94%", height="94%",
  }, avalonUI.Box14)--14
  avalonUI.runiGuildBox_mainContainer:hide()
  
  local i = nil --Hilfsvariable für Rüstungsteil bzw.Waffe/Schild&lt;
  
  -- Der linke Sub-Container:
  avalonUI.runiGuildBox_innerLeftContainer = Geyser.Container:new({
    name = "avalonUI.runiGuildBox_innerLeftContainer",
    x=0, y=0, width="33%", height="100%",
  }, avalonUI.runiGuildBox_mainContainer)

  -- Der mittlere Sub-Container
  avalonUI.runiGuildBox_innerCenterContainer = Geyser.Container:new({
    name = "avalonUI.runiGuildBox_innerCenterContainer",
    x="33%", y=0, width="33%", height="100%",
  }, avalonUI.runiGuildBox_mainContainer)

  -- Der rechte Sub-Container
  avalonUI.runiGuildBox_innerRightContainer = Geyser.Container:new({
    name = "avalonUI.runiGuildBox_innerRightContainer",
    x="66%", y=0, width="33%", height="100%",
  }, avalonUI.runiGuildBox_mainContainer)

--[[
  local offsetX = "10%"             --default: 0
  local offsetY_TOP = "10%"         --default: 0
  local offsetY_BOTTOM = "60%"      --default: "50%"
  local width = "80%"              --default: "100%" minus zwei mal offsetX
  local height = "30%"              --default: "50%" minus zwei mal offsetY_TOP
]]



  local function itemSymbolLabel(itemType, image, posX, posY, parent)
  
    local symbol = nil

    symbol = Geyser.Label:new({
        name = "avalonUI.runiGuildBox_"..itemType.."Symbol",
        x=posX,y=posY,width="100%",height="50%",
      }, avalonUI[parent])
      --setBackgroundColor("avalonUI.runiGuildBox_"..itemType.."Symbol", 0, 0, 0, 10)
      symbol:setStyleSheet([[
        border-image: url("]]..image..[[");
        padding: '0px';
        margin: '40px';
      ]])
    
    return symbol
    
  end

  local function getItemTextLabel(itemType, item, posX, posY, parent)

    local label = nil
    
    local iType = itemType--item.iType
    local iName = item.iName
    local iColor = item.iColor
    local iRunes = item.iRunes

    label = Geyser.Label:new({
      name = "avalonUI.runiGuildBox_"..iType.."Text",
      x=posX,y=posY,width="100%",height="50%",
      --vertical-align="top",
    }, avalonUI[parent])
    setBackgroundColor("avalonUI.runiGuildBox_"..iType.."Text", 0, 0, 0, 220)--210 zu viel, 240 fast nicht zu sehen
    label:setStyleSheet([[qproperty-alignment: 'AlignTop';padding: '20px'; margin: '0px';]])

    local itemText = ""
    itemText = itemText..[[&lt;p&gt;&lt;div style="font-size:16px;"&gt;&lt;b&gt;&lt;font color="]]..iColor..[["&gt;]]..iName..[[&lt;/font&gt;&lt;/b&gt;&lt;/div&gt;]]
    itemText = itemText..[[&lt;div style="font-size:14px"&gt;&lt;b&gt;&lt;table&gt;]]
    if iRunes ~= nil then
      for _, k in pairs(iRunes) do
        itemText = itemText..[[&lt;tr&gt;&lt;td&gt;]]..k.rChargeSymbol..[[&lt;/td&gt;&lt;td&gt;&lt;font color="]]..k.rColor..[["&gt;]]..k.rName..[[&lt;/td&gt;&lt;/tr&gt;&lt;/font&gt;]]
      end --for
    end --if
    itemText = itemText..[[&lt;/table&gt;&lt;/b&gt;&lt;/div&gt;&lt;/p&gt;]]
    label:echo("")
    label:echo(itemText)

    return label
  end
  
  -- Label für Waffe
  avalonUI.runiGuildBox_weaponSymbol = itemSymbolLabel(ITEM_TYPE_WEAPON, imageWeapon, 0, 0, "runiGuildBox_innerLeftContainer")
  avalonUI.runiGuildBox_weaponText = getItemTextLabel(ITEM_TYPE_WEAPON, GUIModel.guildInfoBoxModel["iWeapon"], 0, 0, "runiGuildBox_innerLeftContainer")

  -- Label für Schild
  avalonUI.runiGuildBox_shieldSymbol = itemSymbolLabel(ITEM_TYPE_SHIELD, imageShield, 0, "50%", "runiGuildBox_innerLeftContainer")
  avalonUI.runiGuildBox_shieldText = getItemTextLabel(ITEM_TYPE_SHIELD, GUIModel.guildInfoBoxModel["iShield"], 0, "50%", "runiGuildBox_innerLeftContainer")

  -- Label für Helm
  avalonUI.runiGuildBox_headSymbol = itemSymbolLabel(ITEM_TYPE_HEAD, imageHead, 0, 0, "runiGuildBox_innerCenterContainer")
  avalonUI.runiGuildBox_headText = getItemTextLabel(ITEM_TYPE_HEAD, GUIModel.guildInfoBoxModel["iHead"], 0, 0, "runiGuildBox_innerCenterContainer")

  -- Label für Körperpanzer
  avalonUI.runiGuildBox_bodySymbol = itemSymbolLabel(ITEM_TYPE_BODY, imageBody, 0, "50%", "runiGuildBox_innerCenterContainer")
  avalonUI.runiGuildBox_bodyText = getItemTextLabel(ITEM_TYPE_BODY, GUIModel.guildInfoBoxModel["iBody"], 0, "50%", "runiGuildBox_innerCenterContainer")

  -- Label für Handschuhe
  avalonUI.runiGuildBox_armsSymbol = itemSymbolLabel(ITEM_TYPE_ARMS, imageArms, 0, 0, "runiGuildBox_innerRightContainer")
  avalonUI.runiGuildBox_armsText = getItemTextLabel(ITEM_TYPE_ARMS, GUIModel.guildInfoBoxModel["iArms"], 0, 0, "runiGuildBox_innerRightContainer")

  -- Label für Stiefel
  avalonUI.runiGuildBox_legsSymbol = itemSymbolLabel(ITEM_TYPE_LEGS, imageLegs, 0, "50%", "runiGuildBox_innerRightContainer")
  avalonUI.runiGuildBox_legsText = getItemTextLabel(ITEM_TYPE_LEGS, GUIModel.guildInfoBoxModel["iLegs"], 0, "50%", "runiGuildBox_innerRightContainer")

end
]=]
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildMapper</name>
				<packageName></packageName>
				<script>function avalonUI.buildMapper()

  avalonUI.Box44 = Geyser.Label:new({
    name = "avalonUI.Box44",
    x = 0, y = 0,
    width = "100%",
    height = "50%",
  })--, avalonUI.Left)
  avalonUI.Box44:setStyleSheet(avalonUI.CSS.boxCSS:getCSS())
--  GUIframe.addWindow(avalonUI.Box4, "Map", "topleft")
  GUIframe.addWindow(avalonUI.Box44, "Karte", "topright")

  
  ----------------------------------------
  -- Mapper (Karte) links oben
  ----------------------------------------
  
  avalonUI.Mapper = Geyser.Mapper:new({ 
  	name = "Mapper",
  	x = "5%", y = "5%", 
  	width = "90%", 
  	height = "90%"
  }, avalonUI.Box44)

end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildTimer</name>
				<packageName></packageName>
				<script>function avalonUI.buildTimer()
  
  -- Box5 enthält die Fortschrittsbalken, mit denen die Timer angezeigt werden. Links in 
  -- der Mitte. Box5 ist kein Label-Element, sondern ein Container, und die sind unsichtbar(?)
  -- Deshalb geht das hier mit dem weißen Rahmen nicht. Lösung ist, hier noch ein Label
  -- zu nehmen, dort dann den Container drin, und in dem dann die Gauges.
  avalonUI.Box5c = Geyser.Container:new({
  	name = "avalonUI.Box5c",
  	x = "0%", y = "0%",
  	width = "100%",
  	height = "100%",
  })--, avalonUI.Box5a)
  --avalonUI.Box5:setStyleSheet(avalonUI.CSS.BoxCSS:getCSS())
  GUIframe.addWindow(avalonUI.Box5c, "Timer", "bottomleft")  


  -- Box für die Timer
  avalonUI.Box5a = Geyser.Label:new({
  	name = "avalonUI.Box5a",
  	x = "0%", y = "0%",
  	width = "85%",
  	height = "60%",
  }, avalonUI.Box5c)--, avalonUI.Left)
  avalonUI.Box5a:setStyleSheet(avalonUI.CSS.boxCSS:getCSS())
  --GUIframe.addWindow(avalonUI.Box5a, "Timer", "bottomleft")  


--  avalonUI.Box5 = Geyser.Container:new({
--  	name = "avalonUI.Box5",
--  	x = "2%", y = "0%",
--  	width = "98%",
--  	height = "100%",
--  }, avalonUI.Box5a)
--  --avalonUI.Box5:setStyleSheet(avalonUI.CSS.BoxCSS:getCSS())

  -- Box7 enthält die Fortschrittsbalken, mit denen TP, AP, ZP und Mana angezeigt werden. Links
  -- unten. Box7 ist auch kein Label-Element, sondern ein Container, deshalb gilt auch hier,
  -- was oben bei Box5 dokumentiert ist. Auch ein TODO.
  avalonUI.Box7 = Geyser.Container:new({
    name = "avalonUI.Box7",
    x = "0%", y = "60%",
    width = "100%",
    height = "40%",
  }, avalonUI.Box5c)
  --avalonUI.Box7:setStyleSheet(avalonUI.BoxCSS:getCSS())
  
  ---------------------------------------------------------------------------
  -- Gauges für die Timer
  -- Hier werden (derzeit) 9 Gauge-Elemente für die Timer erzeugt und positioniert.
  -- in der Funktion "recreateTimer" werden die Timer dann alle unsichtbar und
  -- nur die benötigten werden wieder sichtbar und mit Werten beschrieben.
  -- Eigentlich war geplant, die Timer dynamischer zu gestalten, so dass es auch
  -- mehr als neun werden könnten. (Der Rest sollte dann etwas zusammen rücken.)
  -- Aber es scheint nicht möglich zu sein, einmal erzeugte Gauge-Elemente wieder
  -- zu löschen. (Auf nil setzen wirkt jedenfalls nicht.) Deshalb die statische
  -- Lösung und das unsichtbar machen.
  ---------------------------------------------------------------------------
  
  for k = 1, 9, 1 do
  	avalonUI["Timer"..k] = Geyser.Gauge:new({
  		name = "avalonUI.Timer"..k,
  		x = "5%", y = (100-(k*10)-5).."%",
  		width="90%", height="9%",
  		orientation = avalonUI.timerOrientation, --"goofy"
  	}, avalonUI.Box5a)
  	avalonUI["Timer"..k].back:setStyleSheet(avalonUI.CSS.GaugeBackCSS:getCSS())
  	avalonUI.CSS.GaugeFrontCSS:set("background-color", avalonUI.GaugeFrontColorTimer)
  	avalonUI["Timer"..k].front:setStyleSheet(avalonUI.CSS.GaugeFrontCSS:getCSS())
  	avalonUI["Timer"..k]:setValue(600, 600, "")
  end
  
  avalonUI.recreateTimer()
  
  
  -----------------------------------
  -- Gauges für Tick, TP, AP, ZP und Mana
  -----------------------------------
  
  avalonUI.Tick = Geyser.Gauge:new({
    name = "avalonUI.Tick",
    x = "2%", y = "0%",
    width="96%", height="3%",
  }, avalonUI.Box7)
  avalonUI.Tick.back:setStyleSheet(avalonUI.CSS.GaugeBackCSS:getCSS())
  avalonUI.CSS.GaugeFrontCSS:set("background-color", avalonUI.GaugeFrontColorMana)
  avalonUI.Tick.front:setStyleSheet(avalonUI.CSS.GaugeFrontCSS:getCSS())
  avalonUI.Tick.text:setFontSize(9)
  avalonUI.Tick:setValue(9999,9999, [[]])
  avalonUI.Tick.text:setToolTip("Tick-Timer (comming soon)", "10")


  avalonUI.Health = Geyser.Gauge:new({
    name = "avalonUI.Health",
    x = "2%", y = "6%",
    width="30%", height="70%",
    orientation="vertical",
  }, avalonUI.Box7)
  avalonUI.Health.back:setStyleSheet(avalonUI.CSS.GaugeBackCSS:getCSS())
  avalonUI.CSS.GaugeFrontCSS:set("background-color", avalonUI.GaugeFrontColorTP)
  avalonUI.Health.front:setStyleSheet(avalonUI.CSS.GaugeFrontCSS:getCSS())
  avalonUI.Health.text:setStyleSheet(avalonUI.CSS.GaugeTextCSS:getCSS())
  avalonUI.Health.text:setFontSize(9)	
  avalonUI.Health:setValue(100,100,[[&lt;b&gt;&lt;center&gt;TP&lt;/center&gt;&lt;/b&gt;]])

  
  avalonUI.Endurance = Geyser.Gauge:new({
    name = "avalonUI.Endurance",
    x = "35%", y = "5%",
    width="30%", height="70%",
    orientation="vertical",
  }, avalonUI.Box7)
  avalonUI.Endurance.back:setStyleSheet(avalonUI.CSS.GaugeBackCSS:getCSS())
  avalonUI.CSS.GaugeFrontCSS:set("background-color", avalonUI.GaugeFrontColorAP)
  avalonUI.Endurance.front:setStyleSheet(avalonUI.CSS.GaugeFrontCSS:getCSS())
  avalonUI.Endurance.text:setStyleSheet(avalonUI.CSS.GaugeTextCSS:getCSS())
  avalonUI.Endurance.text:setFontSize(9)
  avalonUI.Endurance:setValue(100,100,[[&lt;b&gt;&lt;center&gt;AP&lt;/center&gt;&lt;/b&gt;]])
  
  
  avalonUI.Spellpoints = Geyser.Gauge:new({
    name = "avalonUI.Spellpoints",
    x = "68%", y = "5%",
    width="30%", height="70%",
    orientation="vertical",
  }, avalonUI.Box7)
  avalonUI.Spellpoints.back:setStyleSheet(avalonUI.CSS.GaugeBackCSS:getCSS())
  avalonUI.CSS.GaugeFrontCSS:set("background-color", avalonUI.GaugeFrontColorZP)
  avalonUI.Spellpoints.front:setStyleSheet(avalonUI.CSS.GaugeFrontCSS:getCSS())
  avalonUI.Spellpoints.text:setStyleSheet(avalonUI.CSS.GaugeTextCSS:getCSS())
  avalonUI.Spellpoints.text:setFontSize(9)
  avalonUI.Spellpoints:setValue(100,100, [[&lt;b&gt;&lt;center&gt;ZP&lt;/center&gt;&lt;/b&gt;]])

  
  avalonUI.Mana = Geyser.Gauge:new({
    name = "avalonUI.Mana",
    x = "2%", y = "78%",
    width="96%", height="20%",
  }, avalonUI.Box7)
  avalonUI.Mana.back:setStyleSheet(avalonUI.CSS.GaugeBackCSS:getCSS())
  avalonUI.CSS.GaugeFrontCSS:set("background-color", avalonUI.GaugeFrontColorMana)
  avalonUI.Mana.front:setStyleSheet(avalonUI.CSS.GaugeFrontCSS:getCSS())
  avalonUI.Mana.text:setFontSize(9)
  avalonUI.Mana:setValue(9999,9999, [[&lt;b&gt;&lt;center&gt;Mana&lt;/center&gt;&lt;/b&gt;]])

end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildHDA</name>
				<packageName></packageName>
				<script>function avalonUI.buildHDA()

  -- Box für die Hunger/Durst/Alk/etc-Anzeige
  avalonUI.Box5b = Geyser.Container:new({
  	name = "avalonUI.Box5b",
  	x = "80%", y = "0%",
  	width = "20%",
  	height = "60%",
  }, avalonUI.Box5c)--, avalonUI.Left)
  --avalonUI.Box5b:setStyleSheet(avalonUI.CSS.boxCSS:getCSS())


  local imageFolderPath = getMudletHomeDir().."/Avalet/imgs/"
  
  local imgFightNone = imageFolderPath.."sword-clash-white.svg"--"under_attack.png"
  local imgFightUnderAttack = imageFolderPath.."sword-clash-magenta.svg"--"under_attack.png"
  local imgDisease = imageFolderPath.."poison-bottle-grey.svg"
  --local imgDiseaseNone = imageFolderPath.."poison-bottle-white.svg"
  --local imgDiseaseAvoidDeath = imageFolderPath.."poison-bottle-magenta.svg"
  imgFightNone = imgFightNone:gsub("[\\/]", "/")
  imgFightUnderAttack = imgFightUnderAttack:gsub("[\\/]", "/")
  imgDisease = imgDisease:gsub("[\\/]", "/")
  --imgDiseaseNone = imgDiseaseNone:gsub("[\\/]", "/")
  --imgDiseaseAvoidDeath = imgDiseaseAvoidDeath:gsub("[\\/]", "/")
  
  --if not (io.exists(imgFightNone)) then cecho("&lt;magenta&gt;Bild 1 fehlt: "..imgFightNone.."\n") end
  --if not (io.exists(imgFightUnderAttack)) then cecho("&lt;magenta&gt;Bild 2 fehlt: "..imgFightUnderAttack.."\n") end
  --if not (io.exists(imgDisease)) then cecho("&lt;magenta&gt;Bild 3 fehlt: "..imgDisease.."\n") end
  
  -- Inhalt der Box für die Hunger/Durst/Alk/etc-Anzeige
  -- Icon für "im Kampf"
  avalonUI.Box5b1 = Geyser.Label:new({
  	name = "avalonUI.Box5b1",
  	x="20%", y="4%", width="60%",	height="15%",
  }, avalonUI.Box5b)--, avalonUI.Left)
  
  if player.kampf ~= "0" and player.kampf ~= "1" then player.kampf = "0" end
  
  if player.kampf == "0" then
  --echo("kampf ist null")
    avalonUI.Box5b1:setStyleSheet(avalonUI.CSS.HDABlankCSS:getCSS()..[[;border-image: url("]]..imgFightNone..[[");]])
  else
    avalonUI.Box5b1:setStyleSheet(avalonUI.CSS.HDABlankCSS:getCSS()..[[;border-image: url("]]..imgFightUnderAttack..[[");]])
  end
 
  -- Icon für "Vergiftet/verflucht/erkrankt"
  avalonUI.Box5b2 = Geyser.Label:new({
  	name = "avalonUI.Box5b2",
  	x="20%", y="20%", width="60%",	height="15%",
  }, avalonUI.Box5b)--, avalonUI.Left)
  avalonUI.Box5b2:setToolTip("Krankheiten, Gifte, Flüche (funktioniert noch nicht)", "12")
  avalonUI.Box5b2:setStyleSheet(avalonUI.CSS.HDABlankCSS:getCSS())
  avalonUI.Box5b2:setStyleSheet("QLabel{"..avalonUI.CSS.HDABlankCSS:getCSS()..[[;border-image: url("]]..imgDisease..[[");} QToolTip{"..avalonUI.CSS.boxCSS:getCSS()..";color:white;}]])
  
--  "QLabel{"..avalonUI.CSS.HDACSS:getCSS().."}QToolTip{"..avalonUI.CSS.boxCSS:getCSS()..";color:white;}"
  
--  if player.fluch == 0 and player.krankheit == 0 and player.vergiftung == 0 then
--    avalonUI.Box5b2:setStyleSheet(avalonUI.CSS.HDABlankCSS:getCSS()..[[;border-image: url("]]..imgDiseaseNone..[[");]])
--  else
--    avalonUI.Box5b2:setStyleSheet(avalonUI.CSS.HDABlankCSS:getCSS()..[[;border-image: url("]]..imgDiseaseAvoidDeath..[[");]])
--  end
 
--[[
  avalonUI.Box5b3 = Geyser.Label:new({
  	name = "avalonUI.Box5b3",
  	x="20%", y="30%", width="60%",	height="10%",
  }, avalonUI.Box5b)--, avalonUI.Left)
  avalonUI.Box5b3:setStyleSheet(avalonUI.CSS.HDABlankCSS:getCSS())
]]
  --Box für die HDA-Anzeige
  avalonUI.Box5b4 = Geyser.Container:new({
  	name = "avalonUI.Box5b4",
  	x="20%", y="37%", width="60%", height="70%",
  }, avalonUI.Box5b)--, avalonUI.Left)
  --avalonUI.Box5b3:setStyleSheet(avalonUI.CSS.boxCSS:getCSS())

  avalonUI.Box5b4_11 = Geyser.Label:new({
  	name = "avalonUI.Box5b4_11",
  	x="0%", y="0%", width="33%", height="12%",
    color="black",
    fgcolor="white",
    message="&lt;center&gt;&lt;b&gt;H&lt;/b&gt;&lt;/center&gt;",
  }, avalonUI.Box5b4)--, avalonUI.Left)
  avalonUI.Box5b4_21 = Geyser.Label:new({
  	name = "avalonUI.Box5b4_21",
  	x="33%", y="0%", width="33%", height="12%",
    color="black",
    fgcolor="white",
    message="&lt;center&gt;&lt;b&gt;D&lt;/b&gt;&lt;/center&gt;",
  }, avalonUI.Box5b4)--, avalonUI.Left)
  avalonUI.Box5b4_31 = Geyser.Label:new({
  	name = "avalonUI.Box5b4_31",
  	x="66%", y="0%", width="33%", height="12%",
    color="black",
    fgcolor="white",
    message="&lt;center&gt;&lt;b&gt;A&lt;/b&gt;&lt;/center&gt;",
  }, avalonUI.Box5b4)--, avalonUI.Left)

  for k = 1, 6, 1 do

    --Hunger-Anzeige
    avalonUI["HDA_H"..k] = Geyser.Label:new({
    	name = "HDA_H"..k,
    	x="0%", y=(k*12).."%", width="33%", height="12%",
    }, avalonUI.Box5b4)--, avalonUI.Left)
    if avalonUI.hungerIndex &lt;= 1 then
      --avalonUI["HDA_H"..k]:setStyleSheet(avalonUI.CSS.HDABlankCSS:getCSS())
      avalonUI.CSS.HDACSS:set("background-color", "rgb(0,0,0)")
    elseif avalonUI.hungerIndex &gt; k then
      if avalonUI.hungerIndex &lt;=2 then
        --avalonUI["HDA_H"..k]:setStyleSheet(avalonUI.CSS.HDAGreenCSS:getCSS())
        avalonUI.CSS.HDACSS:set("background-color", "rgb(0,255,0)")
      elseif avalonUI.hungerIndex &lt;= 4 then
        --avalonUI["HDA_H"..k]:setStyleSheet(avalonUI.CSS.HDAYellowCSS:getCSS())
        avalonUI.CSS.HDACSS:set("background-color", "rgb(255,255,0)")
      else
        --avalonUI["HDA_H"..k]:setStyleSheet(avalonUI.CSS.HDARedCSS:getCSS())
        avalonUI.CSS.HDACSS:set("background-color", "rgb(255,0,0)")
      end
      --avalonUI["HDA_H"..k]:setStyleSheet(avalonUI.CSS.HDARedCSS:getCSS())
    else   
      --avalonUI["HDA_H"..k]:setStyleSheet(avalonUI.CSS.HDABlankCSS:getCSS())
      avalonUI.CSS.HDACSS:set("background-color", "rgb(0,0,0)")
    end
    avalonUI.CSS.HDACSS:set("border-color", "rgb(255,255,255)")
    avalonUI["HDA_H"..k]:setToolTip("Hunger: "..player.hunger.."\nDurst:    "..player.durst.."\nAlkohol: "..player.alk, "12")
    avalonUI["HDA_H"..k]:setStyleSheet("QLabel{"..avalonUI.CSS.HDACSS:getCSS().."}QToolTip{"..avalonUI.CSS.boxCSS:getCSS()..";color:white;}")

    --Durst-Anzeige    
    avalonUI["HDA_D"..k] = Geyser.Label:new({
    	name = "HDA_D"..k,
    	x="33%", y=(k*12).."%", width="33%", height="12%",
    }, avalonUI.Box5b4)
    if avalonUI.durstIndex &lt;= 1 then
      --avalonUI["HDA_D"..k]:setStyleSheet(avalonUI.CSS.HDABlankCSS:getCSS())
      avalonUI.CSS.HDACSS:set("background-color", "rgb(0,0,0)")
    elseif avalonUI.durstIndex &gt; k then
      if avalonUI.durstIndex &lt;=2 then
        --avalonUI["HDA_D"..k]:setStyleSheet(avalonUI.CSS.HDAGreenCSS:getCSS())
        avalonUI.CSS.HDACSS:set("background-color", "rgb(0,255,0)")
      elseif avalonUI.durstIndex &lt;= 4 then
        --avalonUI["HDA_D"..k]:setStyleSheet(avalonUI.CSS.HDAYellowCSS:getCSS())
        avalonUI.CSS.HDACSS:set("background-color", "rgb(255,255,0)")
      else
        --avalonUI["HDA_D"..k]:setStyleSheet(avalonUI.CSS.HDARedCSS:getCSS())
        avalonUI.CSS.HDACSS:set("background-color", "rgb(255,0,0)")
      end
      --avalonUI["HDA_D"..k]:setStyleSheet(avalonUI.CSS.HDARedCSS:getCSS())
    else   
      --avalonUI["HDA_D"..k]:setStyleSheet(avalonUI.CSS.HDABlankCSS:getCSS())
      avalonUI.CSS.HDACSS:set("background-color", "rgb(0,0,0)")
    end
    avalonUI.CSS.HDACSS:set("border-color", "rgb(255,255,255)")
    avalonUI["HDA_D"..k]:setToolTip("Hunger: "..player.hunger.."\nDurst:    "..player.durst.."\nAlkohol: "..player.alk, "12")
    avalonUI["HDA_D"..k]:setStyleSheet("QLabel{"..avalonUI.CSS.HDACSS:getCSS().."} QToolTip{"..avalonUI.CSS.boxCSS:getCSS()..";color:white;}")
    
    -- Alkohol-Anzeige:
    avalonUI["HDA_A"..k] = Geyser.Label:new({
    	name = "HDA_A"..k,
    	x="66%", y=(k*12).."%", width="33%", height="12%",
    }, avalonUI.Box5b4)--, avalonUI.Left)
    --avalonUI["HDA_A"..k]:setStyleSheet(avalonUI.CSS.HDARedCSS:getCSS())
    if (avalonUI.alkIndex-1) &lt;= 1 then
      --avalonUI["HDA_A"..k]:setStyleSheet(avalonUI.CSS.HDABlankCSS:getCSS())
      avalonUI.CSS.HDACSS:set("background-color", "rgb(0,0,0)")
    elseif (avalonUI.alkIndex-1) &gt; k then
      if (avalonUI.alkIndex-1) &gt;=5 then
        --avalonUI["HDA_A"..k]:setStyleSheet(avalonUI.CSS.HDARedCSS:getCSS())
        avalonUI.CSS.HDACSS:set("background-color", "rgb(255,0,0)")
      elseif (avalonUI.alkIndex-1) &gt;= 2 then
        --avalonUI["HDA_A"..k]:setStyleSheet(avalonUI.CSS.HDAYellowCSS:getCSS())
        avalonUI.CSS.HDACSS:set("background-color", "rgb(255,255,0)")
      else
        --avalonUI["HDA_A"..k]:setStyleSheet(avalonUI.CSS.HDABlankCSS:getCSS())
        avalonUI.CSS.HDACSS:set("background-color", "rgb(0,0,0)")
      end
      --avalonUI["HDA_A"..k]:setStyleSheet(avalonUI.CSS.HDAGreenCSS:getCSS())
    else   
      --avalonUI["HDA_A"..k]:setStyleSheet(avalonUI.CSS.HDABlankCSS:getCSS())
      avalonUI.CSS.HDACSS:set("background-color", "rgb(0,0,0)")
    end
    avalonUI["HDA_A"..k]:setToolTip("Hunger: "..player.hunger.."\nDurst:    "..player.durst.."\nAlkohol: "..player.alk, "12")
    --avalonUI["HDA_A"..k]:setStyleSheet("QToolTip{background: yellow; color: blue; border:none;}")
    if player.hangover then
      avalonUI.CSS.HDACSS:set("border-color", "rgb(255,0,255)")
    else
      avalonUI.CSS.HDACSS:set("border-color", "rgb(255,255,255)")
    end
    --avalonUI["HDA_A"..k]:setStyleSheet(avalonUI.CSS.HDACSS:getCSS())
    avalonUI["HDA_A"..k]:setStyleSheet("QLabel{"..avalonUI.CSS.HDACSS:getCSS().."}QToolTip{"..avalonUI.CSS.boxCSS:getCSS()..";color:white;}")

  end

end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildAlerts</name>
				<packageName></packageName>
				<script>-- Alerts
-- "Alerts" sind eigentlich eher "Message Boxen", die halbtransparent oben auf dem Hauptfenster erzeugt werden.
-- Diese Boxen sollen Informationen für den Spieler hervorheben. Zu diesen Informationen zählen auch Level- und
-- Stufen-UPs. Aber auch Statusinformationen zum Zustand der Ausrüstung. Für Runenschmiede wird hier eine
-- Box zu jedem Ausrüstungsgegenstand generiert, der beschädigt ist oder der eine beschädigte Rune enthält.
-- Die Boxen verschwinden durch anklicken oder nach einer festgelegten Zeit.
-- Messageboxen müssen aktualisiert werdne können. Dazu müssen sie wiederfindbar sein.
function avalonUI.buildAlerts()
  

end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildTopMenu</name>
				<packageName></packageName>
				<script>-- Top-Menü
-- Menü-Label dürfen nicht in einem Container sein, deshalb sind die 
-- Top-Level-Einträge direkt auf der Oberfläche positioniert.

function avalonUI.buildTopBar()

  avalonUI.topBar = Geyser.Label:new({
    name = "avalonUI.topBar",
    x = "15%", y = "0%",
    width = "50%",
    height = "7%",
    --nestable = true,
  })
  avalonUI.topBar:setStyleSheet(avalonUI.CSS.boxCSS:getCSS())
  GUIframe.addWindow(avalonUI.topBar, "TopBar", "top")

	d = 0
	for k, v in ipairs(GUIModel.TopMenuEntries) do

		avalonUI["TopMenu"..v[1]] = Geyser.Label:new({ 
			name = "TopMenu"..v[1], 
			x = tostring(17+d*10).."%", 
			y = "1.5%" , 
			width = 200,
			height = 35,
			nestable = true,
		})
		avalonUI["TopMenu"..v[1]]:setStyleSheet(avalonUI.CSS.MenuLabelCSS:getCSS())
		avalonUI["TopMenu"..v[1]]:setFontSize(12)
		avalonUI["TopMenu"..v[1]]:echo(v[1])
		--GUI["TopMenu"..v[1]]:echo([[&lt;p style="font-size:22px"&gt;&lt;b&gt;&lt;font color="white"&gt;]]..v[1])
		--setLabelClickCallback( "TopMenuOptions", "ClickTopMenuPreferences")
		--setLabelClickCallback(labelName, luaFunctionName, [any arguments])
		local subMenuEntries = {}
		for k2, v2 in ipairs(v[2]) do
			-- erstmal sortierte table der sub-entries bauen
			table.insert(subMenuEntries, v2[2], {v2[1], v2[3], v2[4], v2[5]}) -- tabelle, position, {name, message, luafunct, args}
		end
		for k3, v3 in ipairs(subMenuEntries) do
			avalonUI["TopMenu"..v[1]..v3[1]] = avalonUI["TopMenu"..v[1]]:addChild({
				name = "TopMenu"..v[1]..v3[1],
				height = 50,
				width = 100, 
				flyOut=true,
				layoutDir="BV", 
				message=v3[2]
			})
			avalonUI["TopMenu"..v[1]..v3[1]]:setStyleSheet(avalonUI.CSS.MenuLabelCSS:getCSS())
			--TopMenuOptions[i]:setStyleSheet(LabelCSS:getCSS())
			--setLabelClickCallback( "TopMenuOptions"..i, "ClickTopMenuCallback","tDir[i]","bla bla")
			--setLabelClickCallback(labelName, luaFunctionName, [any arguments])
		end

		--if v[5] then
		--	for i=1,#v[5] do
		--		echo ("arg["..i.."] = "..v[5][i].."\n")
		--	end
		--end
		d = d+1
	end
    
--[=[  
  -------------------------
  -- Menü "Options"
  -------------------------
  -- wird hier extra hinzugefügt.
  -- Menü-Label dürfen nicht in einem Container sein, deshalb sind die Top-Level-Einträge direkt auf der Oberfläche positioniert.
  avalonUI.TopMenuOptions= Geyser.Label:new({ 
  	name = "TopMenuOptions", 
  	x = "62%", 
  	y = "1.5%" , 
  	width = 35,
  	height = 30,
  	nestable = true,
  })
  avalonUI.TopMenuOptions:setStyleSheet(avalonUI.CSS.MenuLabelCSS:getCSS())
  avalonUI.TopMenuOptions:setFontSize(12)
  avalonUI.TopMenuOptions:setCursor("PointingHand")
  avalonUI.TopMenuOptions:echo([[&amp;#9881;]])
  --avalonUI.TopMenuOptions:echo([[&lt;p style="font-size:22px"&gt;&lt;b&gt;&lt;font color="white"&gt;&amp;#9881;]])
  --setLabelClickCallback( "TopMenuOptions", "ClickTopMenuPreferences")
  setLabelClickCallback( "TopMenuOptions", "avalonUI.showSettingsDialog")
  --setLabelClickCallback(labelName, luaFunctionName, [any arguments])
]=]  
  --i = 1
  --avalonUI.TopMenuOptions[i] = avalonUI.TopMenuOptions:addChild({
  --	name = "TopMenuOptions"..i,
  --	height = 50,
  --	width = 100, 
  --	flyOut=true,
  --	layoutDir="BV", 
  --	message="comming soon"
  --})
  --avalonUI.TopMenuOptions[i]:setStyleSheet(avalonUI.CSS.MenuLabelCSS:getCSS())
  ----setLabelClickCallback( "TopMenuOptions"..i, "ClickTopMenuCallback","tDir[i]","bla bla")
  ----setLabelClickCallback(labelName, luaFunctionName, [any arguments])

end</script>
				<eventHandlerList />
			</Script>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>SettingsDialog</name>
				<packageName></packageName>
				<script>--SettingsDialog
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>buildSettingsDialog</name>
					<packageName></packageName>
					<script>-- buildSettings
-- Also das UI für die Settings zu machen war wirklich kein Spaß. Die Elemente, die
-- Mudlet dafür bereit stellt, sind mehr als dürftig. Kann aber auch sein, dass ich
-- einfach eine falsche Vorstellung entwickelt hab, wie das aussehen soll. Statt mehr
-- über Mudlet zu wissen und das dann einfach so zu machen, wie es vllt. gedacht ist.
-- Jedenfalls tuts mir für jede/n leid, die/der sich hier einarbeiten muss.
-- Ach ja: möglicherweise wäre eine bessere Lösung gewesen, eine Miniconsole zu verwenden,
-- und das Menü dann irgendwie mit anklickbarem Text zu machen. Die Anleitung dafür hab
-- ich wohl gesehen. Aber ich bin mit den Formatierungsmöglichkeiten nicht zurecht gekommen.
-- Also mit den anscheinend nicht vorhandenen Formatierungsmöglichkeiten. Und weil auch
-- keine Unicode-Zeichen dargestellt wurden, hab ich das nicht weiter verfolgt. Das 
-- wäre aber vielleicht ein vielversprechender Ansatz. 


-- Die Tabs, zu denen hinzugefügt werden muss:
-- avalonUI.settings.Diversescenter
-- avalonUI.settings.Chats-Tabscenter
-- avalonUI.settings.Farbencenter
-- avalonUI.settings.Über Avaletcenter


function avalonUI.buildSettingsDialog()

--  settingsDialogWindow = Geyser.UserWindow:new({
--    name = "settingsDialogWindow",
--    titleText ="Einstellungen", -- only available since Mudlet 4.8+
--    x = "20%", y="20%",
--    width="30%", height ="40%"
--  })
--  settingsDialogWindow:disableAutoDock()

  mainWidth, mainHeight = getMainWindowSize()
  
  posX = 0
  posX = mainWidth/2 - avalonUI.settingsSettings.width/2
  posY = 0
  posY = mainHeight/2 - avalonUI.settingsSettings.height/2
  
  avalonUI.settingsDialogWindow = avalonUI.settingsWindow or Adjustable.Container:new({name="avalonUI.settingsDialogWindow"})
  --avalonUI.settingsDialogWindow:setTitle("Einstellungen")       -- "Titel" ist per default grün
  avalonUI.settingsDialogWindow:setTitle("Einstellungen","white") -- Hier ist der Titel weiß
  avalonUI.settingsDialogWindow:resize(avalonUI.settingsSettings.width, avalonUI.settingsSettings.height)
  avalonUI.settingsDialogWindow:move(posX, posY)
  avalonUI.settingsDialogWindow:setFontSize(14)

  avalonUI.settings.createTabbedLayer()
  avalonUI.settings.addTabs()

-- avalonUI.settings.Diversescenter
-- avalonUI.settings.Chats-Tabscenter
-- avalonUI.settings.Farbencenter
-- avalonUI.settings.Über Avaletcenter

  --cecho("&amp;lt;magenta&amp;gt;\n1\n")
--  avalonUI.createSettingsTabs()
  --cecho("&amp;lt;magenta&amp;gt;\n2\n")
  avalonUI.buildGeneralSettings()
  --cecho("&amp;lt;magenta&amp;gt;\n3\n")
  avalonUI.buildChatTabSettings()
  --cecho("&amp;lt;magenta&amp;gt;\n4\n")
--  avalonUI.buildColorSettings()
  --cecho("&amp;lt;magenta&amp;gt;\n5\n")
--  avalonUI.buildAboutSettings()
  --cecho("&amp;lt;magenta&amp;gt;\n6\n")
  
  --avalonUI.settings[v]:hide()
  
  avalonUI.hideSettingsDialog()

end

function avalonUI.settings.createTabbedLayer()

  avalonUI.settingsHeader = Geyser.HBox:new({
    name = "avalonUI.settingsHeader",
    x = "1%", y = "2%",
    width = "98%",
    height = "8%",
  }, avalonUI.settingsDialogWindow)

  
  avalonUI.settingsFooter = avalonUI.settingsFooter or Geyser.Label:new({
    name = "avalonUI.settingsFooter",
    x = "1%", y = "10%",
    width = "98%",
    height = "90%",
    color = "red"
  }, avalonUI.settingsDialogWindow)
  --avalonUI.tabElement.Footer:setStyleSheet(avalonUI.CSS.tabElementFooterCSS:getCSS())
  avalonUI.settingsFooter:setStyleSheet(avalonUI.CSS.tabElementFooterCSS:getCSS())

end


function avalonUI.settings.addTabs()

  for k,v in pairs(avalonUI.settingsSettings.tabs) do

    -- Hier werden die einzelnen Tabs erzeugt. ...
    avalonUI.settings[v.."tab"] = avalonUI.settings[v.."tab"] or Geyser.Label:new({
      name = "avalonUI.settings."..v.."tab",
    })
    avalonUI.settingsHeader:add(avalonUI.settings[v.."tab"])
    avalonUI.settings[v.."tab"]:setFontSize(avalonUI.chatTabFontSize)	  
    avalonUI.settings[v.."tab"]:setStyleSheet(avalonUI.CSS.MenuTabCSS:getCSS())
    avalonUI.settings[v.."tab"]:echo("&lt;center&gt;"..v)
    avalonUI.settings[v.."tab"]:setCursor("PointingHand")
    avalonUI.settings[v.."tab"]:setClickCallback("avalonUI.settingsClick",v)
    
    -- ... Und zu jedem Tab noch ein Label für den Inhalt.  
    avalonUI.settings[v] = avalonUI.settings[v] or Geyser.Label:new({
      name = "avalonUI.settings."..v,
      x = 0, y = 0, width = "100%", height = "100%",
    }, avalonUI.settingsFooter)
    avalonUI.settings[v]:setStyleSheet(avalonUI.CSS.tabElementAtopCSS:getCSS())

    avalonUI.settings[v]:hide()

  end
  --avalonUI.settingsHeader:show() 
end


function avalonUI.toggleSettingsDialogVisibility()
  if avalonUI.settingsSettings.isSettingsDialogVisible then
    avalonUI.settingsSettings.isSettingsDialogVisible = false
    settingsDialogWindow:hide()
  else
    avalonUI.settingsSettings.isSettingsDialogVisible = true
    settingsDialogWindow:show()
  end
end

function avalonUI.showSettingsDialog()
  avalonUI.settingsSettings.isSettingsDialogVisible = true
  avalonUI.settingsDialogWindow:show()
end

function avalonUI.hideSettingsDialog()
  avalonUI.settingsSettings.isSettingsDialogVisible = false
  avalonUI.settingsDialogWindow:hide()
end

function avalonUI.settingsClick(tab)
--GUIModel.settingsElement.tabs
  avalonUI.settings[GUIModel.settingsElement.currentTab]:hide()
  --settingsSettings.current:hide()
  GUIModel.settingsElement.currentTab = tab
  --settingsSettings.current:show()
  avalonUI.settings[GUIModel.settingsElement.currentTab]:show()
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tabGeneral</name>
					<packageName></packageName>
					<script>--tabGeneral

function avalonUI.buildGeneralSettings()

--  titleLabel = Geyser.Label:new({
--    x=0, y=15, height=30, width="100%", 
--    color="red", 
--    message="&lt;b&gt;&lt;center&gt;Aenderungen werden erst nach Neustart von Mudlet uebernommen!&lt;/center&gt;&lt;/b&gt;"
--  }, avalonUI.settings["Diverses"])
--  titleLabel:setFontSize(12)
----  titleLabel:echo("&lt;b&gt;&lt;center&gt;Änderungen werden erst nach Neustart von Mudlet übernommen!&lt;/center&gt;&lt;/b&gt;")
  
  contentGeneralSettings = Geyser.VBox:new({x="2%", y="2%", height=300, width="96%", color="white"}, avalonUI.settings["Diverses"])
  
  titleTimer = Geyser.Label:new({height="60%", width="100%", color="black", message="&lt;b&gt;Timer&lt;/b&gt;"}, contentGeneralSettings)-- avalonUI.settings["Diverses"])
  titleTimer:setFontSize(12)

  textTimer = Geyser.Label:new({height=10, width="100%", color="black", message = "Aenderungen werden erst durch einen Neustart von Mudlet wirksam."}, contentGeneralSettings)
  textTimer:setFontSize(11)

  choiceFancyTimer = Geyser.Label:new({height = 20, width = "100%", color = "black", message = [[&amp;#9678;]] .. "&amp;nbsp;&lt;i&gt;fancy Rückschritts&lt;/i&gt;balken ODER"}, contentGeneralSettings)-- avalonUI.settings["Diverses"])
  choiceFancyTimer:setFontSize(11)
  choiceFancyTimer:setCursor("PointingHand")
  --choiceFancyTimer:setClickCallback("avalonUI.settingsClick",v)
  choiceUnfancyTimer = Geyser.Label:new({height = 20, width = "100%", color = "black", message = [[&amp;#9711;]] .. " langweiliger Fortschrittsbalken"}, contentGeneralSettings)-- avalonUI.settings["Diverses"])
  choiceUnfancyTimer:setFontSize(11)
  choiceUnfancyTimer:setCursor("PointingHand")
  --choiceUnfancyTimer:setClickCallback("avalonUI.settingsClick",v)

  spacer = Geyser.Label:new({height=10, width="100%", color="black"}, contentGeneralSettings)

  titleLockUI = Geyser.Label:new({height=40, width="100%", color="black", message="&lt;b&gt;Oberfläche sperren&lt;/b&gt;"}, contentGeneralSettings)-- avalonUI.settings["Diverses"])
  titleLockUI:setFontSize(12)

  textLockUI = Geyser.Label:new({height=10, width="100%", color="black", message = "Aenderungen werden durch einen Neustart zurückgesetzt."}, contentGeneralSettings)
  textLockUI:setFontSize(11)

  checkboxLockUI = Geyser.Label:new({height = 20, width = "100%", color = "black", message = [[&amp;#9745;]] .. "&amp;nbsp;Seitenbereich der Oberfläche sperren."}, contentGeneralSettings)-- avalonUI.settings["Diverses"])
  checkboxLockUI:setFontSize(11)
  checkboxLockUI:setCursor("PointingHand")
  --checkboxLockUI:setClickCallback("avalonUI.settingsClick",v)


--  generalLabel = Geyser.Label:new({x=0, y=400, height=100, width="100%", color="white"}, avalonUI.settings["Diverses"])
--  generalLabel:setFontSize(11)
--  local settings = ""
--  settings = settings .. "&amp;lt;center&amp;gt;&amp;lt;b&amp;gt;Änderungen machen einen Neustart von Mudlet notwendig!&amp;lt;/b&amp;gt;&amp;lt;/center&amp;gt;&amp;lt;br&amp;gt;"
--  --settings = settings .. [[&amp;amp;#9744;]] .. " leere Checkbox&amp;lt;br&amp;gt;"
--  --settings = settings .. [[&amp;amp;#9745;]] .. " Checkbox mit Haken&amp;lt;br&amp;gt;"
--  --settings = settings .. [[&amp;amp;#9746;]] .. " Checkbox mit Kreuz&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;"
--  settings = settings .. "&amp;lt;br&amp;gt;&amp;lt;b&amp;gt;Timer&amp;lt;/b&amp;gt;&amp;lt;br&amp;gt;"
--  settings = settings .. [[&amp;amp;#9678;]] .. " &amp;lt;i&amp;gt;fancy Rückschritts&amp;lt;/i&amp;gt;balken ODER&amp;lt;br&amp;gt;"
--  settings = settings .. [[&amp;amp;#9711;]] .. " langweiliger Fortschrittsbalken&amp;lt;br&amp;gt;"
-- settings = settings .. "&amp;lt;br&amp;gt;&amp;lt;b&amp;gt;Diverses&amp;lt;/b&amp;gt;&amp;lt;br&amp;gt;"
--  settings = settings .. [[&amp;amp;#128306;]] .. "Lock/unlock UI" .. [[&amp;amp;#128307;]] .. "&amp;lt;br&amp;gt;"
--  --testLabel:echo([[&amp;amp;#9745;]] .. " Timer mit &amp;lt;i&amp;gt;fancy Rückschritts&amp;lt;/i&amp;gt;balken")
--  generalLabel:echo(settings)
end

</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tabChats</name>
					<packageName></packageName>
					<script>--tabChats

-- avalonUI.settings.Diversescenter
-- avalonUI.settings.Chats-Tabscenter
-- avalonUI.settings.Farbencenter
-- avalonUI.settings.Über Avaletcenter
function avalonUI.buildChatTabSettings()

  avalonUI.chatTabContainer = avalonUI.chatTabContainer or Geyser.Container:new({
    name = "avalonUI.chatTabContainer",
    x = 0, y = 0,
    width = "100%",
    height = "100%",
  }, avalonUI.settings["Chats-Tabs"])
  -- der muss noch irgendwo hinzugefügt werden

  avalonUI.chatTabHeader = Geyser.Label:new({
    name = "avalonUI.chatTabHeader",
    x = "0%", y = "0%", width = "100%", height = "10%",
  }, avalonUI.chatTabContainer)
  avalonUI.chatTabHeader:echo("ChatTab-Konfiguratione")

  avalonUI.chatTabContent = Geyser.Container:new({
    name = "avalonUI.chatTabContent",
    x = "0%", y = "10%", width = "100%", height = "90%",
  }, avalonUI.chatTabContainer)
  avalonUI.chatTabContentRowCheckbox = Geyser.VBox:new({
    name = "avalonUI.chatTabContentRowCheckbox",
    x = 0, y = 0, width = 20, height = "100%",
  }, avalonUI.chatTabContent)
  avalonUI.chatTabContentRowOneDown = Geyser.VBox:new({
    name = "avalonUI.chatTabContentRowOneDown",
    x = 25, y = 0, width = 20, height = "100%",
  }, avalonUI.chatTabContent)
  avalonUI.chatTabContentRowOneUp = Geyser.VBox:new({
    name = "avalonUI.chatTabContentRowOneUp",
    x = 45, y = 0, width = 20, height = "100%",
  }, avalonUI.chatTabContent)
  avalonUI.chatTabContentName = Geyser.VBox:new({
    name = "avalonUI.chatTabContentName",
    x = 70, y = 0, width = 450, height = "100%",
  }, avalonUI.chatTabContent)
  
  --Reden, Sagen, Laber, Neuling, Gruppe, Volk, Gilde, Zuenfte, Schwafel, Tod, Sammeltab (außerdem: Monster, Gebruell, Logout, Raetsel, Spiele, Statue)
  local test = test or {"Reden", "Sagen", "Laber", "Neuling", "Gruppe", "Volk", "Gilde", "Zuenfte", "Schwafel", "Tod", "Sammeltab", "Monster", "Gebruell", "Logout", "Raetsel", "Spiele", "Statue"}
--  local test = test or {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"}
  
  local fontsize = 12
  
  for k,v in pairs(test) do

    avalonUI["test"..k.."Checkbox"] = Geyser.Label:new({
      name = "avalonUI.test"..k.."Checkbox",
      x = 0, y = ((k-1)*10), width = 10, height = 10,
      fgColor="white",
      color="black",
      message=[[&amp;#9745;]]
    }, avalonUI.chatTabContentRowCheckbox)
    avalonUI["test"..k.."Checkbox"]:setFontSize(fontsize)
    avalonUI["test"..k.."Checkbox"]:setCursor("PointingHand")
    avalonUI["test"..k.."OneDown"] = Geyser.Label:new({
      name = "avalonUI.test"..k.."OneDown",
      x = 20, y = ((k-1)*10), width = 10, height = 10,
      fgColor="white",
      color="black",
      message=[[&lt;b&gt;&amp;#9661;&lt;/b&gt;]]
    }, avalonUI.chatTabContentRowOneDown)
    avalonUI["test"..k.."OneDown"]:setFontSize(fontsize)
    avalonUI["test"..k.."OneDown"]:setCursor("PointingHand")
    avalonUI["test"..k.."OneUp"] = Geyser.Label:new({
      name = "avalonUI.test"..k.."OneUp",
      x = 40, y = ((k-1)*10), width = 10, height = 10,
      fgColor="white",
      color="black",
      message=[[&lt;b&gt;&amp;#9651;&lt;/b&gt;]]
    }, avalonUI.chatTabContentRowOneUp)
    avalonUI["test"..k.."OneUp"]:setFontSize(fontsize)
    avalonUI["test"..k.."OneUp"]:setCursor("PointingHand")
    avalonUI["test"..k.."Label"] = Geyser.Label:new({
      name = "avalonUI.test"..k.."Label",
      x = 60, y = ((k-1)*10), width = "90%", height = 10,
      fgColor="white",
      color="black",
      message="&amp;nbsp;Reden &amp;#127760;"
    }, avalonUI.chatTabContentName)
    avalonUI["test"..k.."Label"]:setFontSize(fontsize)
    --avalonUI["test"..k.."Label"]:setCursor("PointingHand")
  
  end
  
  avalonUI.chatTabFooter = Geyser.Label:new({
    name = "avalonUI.chatTabFooter",
    x = "0%", y = "90%",
    width = "100%",
    height = "10%",
  }, avalonUI.chatTabContainer)
  avalonUI.chatTabFooter:echo("Änderungen werden erst nach Neustart von Mudlet übernommen!")

end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tabColor</name>
					<packageName></packageName>
					<script>--tabColor</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tabAbout</name>
					<packageName></packageName>
					<script>--tabAbout</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>ATCP</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>atcp</name>
				<packageName></packageName>
				<script>----------------------------------------
-- ATCP-Handling
-- In diesem Script findet der Umgang mit den ATCP-Daten statt,
-- die Avalon sendet (und empfängt) 
-- Eine Beschreibung der ATCP-Schnittstelle von Avalon findet sich im Wiki:
-- https://avalon.mud.de/wiki/avalon:atcp
--
-- Anscheinend wird in einer Tabelle mit dem Namen "atcp", wenn sie existiert(?),
-- alles gespeichert, was per atcp reinkommt.
--atcp = {}


----------------------------------------
-- onATCPEvent
----------------------------------------

function onATCPEvent(event, arg)
	cecho("&lt;magenta&gt;Wer dies lesen kann, hat einen Fehler gefunden! (atcp.lua, funct. onATCPEvent\n")
end

----------------------------------------------------------------------------------------
-- Misc
----------------------------------------------------------------------------------------

-- event == "AvalonGrafikVermeiden"
function onATCPEventAvalonGrafikVermeiden(event, arg)
	debugc("AvalonGrafikVermeiden = " .. tostring(arg) .. "\n")

--	channel = "ATCP"
--	message = "AvalonGrafikVermeiden = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonGrafikVermeiden", "onATCPEventAvalonGrafikVermeiden")



-- event == "AuthRequest"
function onATCPEventAuthRequest(event, arg)
	debugc("AuthRequest = " .. tostring(arg) .. "\n")
  --cecho("\n&lt;magenta&gt;AuthRequest: " .. tostring(arg) .. "\n")
--	channel = "ATCP"
--	message = "AuthRequest = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AuthRequest", "onATCPEventAuthRequest")



----------------------------------------------------------------------------------------
--  Charakter-Daten/Spielstand
----------------------------------------------------------------------------------------

-- event == "AvalonName"
function onATCPEventAvalonName(event, arg)
  debugc("&lt;magenta&gt;AvalonName per ATCP empfangen!\n")
  debugc("&lt;magenta&gt;AvalonName: " .. arg .."\n")
  if player.name ~= arg then
    --cecho("&lt;magenta&gt;\nplayer.name ~= arg\n")
    if string.len(player.name) == 0 then
      avalonUI.initPlayer(arg)
    end
    player.name = arg
    raiseEvent("RefreshInfobox", arg)
  end
end
registerAnonymousEventHandler("AvalonName", "onATCPEventAvalonName")



-- event == "AvalonVollName"
function onATCPEventAvalonVollName(event, arg)
	debugc("&lt;magenta&gt;AvalonVollName per ATCP empfangen!\n")
	if player.vollername ~= arg then
		player.vollername = arg
		raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonVollName", "onATCPEventAvalonVollName")



-- event == "AvalonPortfolio"
function onATCPEventAvalonPortfolio(event, arg)
	debugc("&lt;magenta&gt;AvalonPortfolio per ATCP empfangen!\n")
	if player.portfolio ~= arg then 
		player.portfolio = arg
		raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonPortfolio", "onATCPEventAvalonPortfolio")



-- event == "AvalonGilde"
function onATCPEventAvalonGilde(event, arg)
	debugc("&lt;magenta&gt;AvalonGilde per ATCP empfangen!\n")
	if player.gilde ~= arg then
		player.gilde = arg
		raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonGilde", "onATCPEventAvalonGilde")


-- event == "AvalonZuenfte"
function onATCPEventAvalonZuenfte(event, arg)
	debugc("&lt;magenta&gt;AvalonZuenfte per ATCP empfangen!\n")
	if player.zuenfte ~= arg then 
		player.zuenfte = arg
		raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonZuenfte", "onATCPEventAvalonZuenfte")



-- event == "AvalonAlter"
function onATCPEventAvalonAlter(event, arg)
	debugc("&lt;magenta&gt;AvalonAlter per ATCP empfangen: " .. arg .. "\n")
	if player.alter ~= arg then 
		player.alter = arg
		raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonAlter", "onATCPEventAvalonAlter")



-- event == "AvalonLevel"
function onATCPEventAvalonLevel(event, arg)
	debugc("&lt;magenta&gt;AvalonLevel per ATCP empfangen!\n")
	if player.level ~= arg then
		player.level = arg
		raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonLevel", "onATCPEventAvalonLevel")



-- event == "AvalonEP"
function onATCPEventAvalonEP(event, arg)
	debugc("&lt;magenta&gt;AvalonEP per ATCP empfangen!\n")
	if player.ep ~= arg then
		player.ep = arg
    --player.sessionEP = tonumber(arg) - tonumber(player.sessionEP)
		raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonEP", "onATCPEventAvalonEP")



-- event == "AvalonGesinnung"
function onATCPEventAvalonGesinnung(event, arg)
	debugc("&lt;magenta&gt;AvalonGesinnung per ATCP empfangen!\n")
	if player.gesinnung ~= arg then 
		player.gesinnung = arg
		raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonGesinnung", "onATCPEventAvalonGesinnung")



-- event == "AvalonHunger"
-- Die Texte für Hunger und für Durst hatten am Ende ein Leerzeichen zu viel.
-- Das wurde gefixt. Aber ein Trim kann nie schaden.
function onATCPEventAvalonHunger(event, arg)
	debugc("&lt;magenta&gt;AvalonHunger per ATCP empfangen!\n")
	--cecho("&lt;magenta&gt;AvalonHunger per ATCP empfangen!\n")
	arg = string.trim(arg)
	if player.hunger ~= arg then 
		player.hunger = arg
		raiseEvent("RefreshInfobox", arg)
    --raiseEvent("RefreshHDA", arg)
	end
  raiseEvent("RefreshHDA", arg)
end
registerAnonymousEventHandler("AvalonHunger", "onATCPEventAvalonHunger")



-- event == "AvalonDurst"
-- Die Texte für Hunger und für Durst hatten am Ende ein Leerzeichen zu viel.
-- Das wurde gefixt. Aber ein Trim kann nie schaden.
function onATCPEventAvalonDurst(event, arg)
	debugc("&lt;magenta&gt;AvalonDurst per ATCP empfangen!\n")
	--cecho("&lt;magenta&gt;AvalonDurst per ATCP empfangen!\n")
	arg = string.trim(arg)
	if player.durst ~= arg then
		player.durst = arg
		raiseEvent("RefreshInfobox", arg)
    --raiseEvent("RefreshHDA", arg)
	end
  raiseEvent("RefreshHDA", arg)
end
registerAnonymousEventHandler("AvalonDurst", "onATCPEventAvalonDurst")


-- event == "AvalonHoehe"
function onATCPEventAvalonHoehe(event, arg)
	debugc("&lt;magenta&gt;AvalonHoehe per ATCP empfangen!\n")
	arg = string.trim(arg)
	if player.hoehe ~= arg then
		player.hoehe = arg
		-- raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonHoehe", "onATCPEventAvalonHoehe")



-- event == "AvalonFlucht"
function onATCPEventAvalonFlucht(event, arg)
	debugc("&lt;magenta&gt;AvalonFlucht per ATCP empfangen!\n")
	arg = string.trim(arg)
	if player.flucht ~= arg then
		player.flucht = arg
		-- raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonFlucht", "onATCPEventAvalonFlucht")



-- event == "AvalonSchutz"
function onATCPEventAvalonSchutz(event, arg)
	debugc("&lt;magenta&gt;AvalonSchutz per ATCP empfangen!\n")
	arg = string.trim(arg)
	if player.schutz ~= arg then
		player.schutz = arg
    -- Wenn ein Schutzzauber hinzu kommt, gibt es eine ATCP-Message. Wenn ein
    -- Schutz wegfällt, gibt es aber keine. Um die Anzeige (und was sonst noch 
    -- so davon abhängt...) zu aktualisieren, werden hier deshalb bei jeder
    -- Veränderung ... Das ist doch quatsch. Anders lösen. 
    --sendATCP("ava_req_update")
		-- raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonSchutz", "onATCPEventAvalonSchutz")



-- event == "AvalonGruppe"
function onATCPEventAvalonGruppe(event, arg)
	debugc("&lt;magenta&gt;AvalonGruppe per ATCP empfangen!\n")
	arg = string.trim(arg)
	if player.gruppenname ~= arg then
		player.gruppenname = arg
		-- raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonGruppe", "onATCPEventAvalonGruppe")



-- event == "AvalonZaubern"
function onATCPEventAvalonZaubern(event, arg)
	debugc("&lt;magenta&gt;AvalonZaubern per ATCP empfangen!")
	arg = string.trim(arg)
	if player.zaubern ~= arg then
		player.zaubern = arg
		-- raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonZaubern", "onATCPEventAvalonZaubern")



-- event == "AvalonKampf"
function onATCPEventAvalonKampf(event, arg)
	debugc("&lt;magenta&gt;AvalonKampf per ATCP empfangen!\n")
	--cecho("\n&lt;magenta&gt;AvalonKampf: "..arg.."\n")
	arg = string.trim(arg)
	if player.kampf ~= arg then
		player.kampf = arg
		-- raiseEvent("RefreshInfobox", arg)
    raiseEvent("RefreshHDA", arg)
	end
end
registerAnonymousEventHandler("AvalonKampf", "onATCPEventAvalonKampf")



    -- event == "AvalonAngegriffen"raiseEvent("RefreshHDA", arg)

function onATCPEventAvalonAngegriffen(event, arg)
	debugc("&lt;magenta&gt;AvalonAngegriffen per ATCP empfangen!\n")
	arg = string.trim(arg)
	if player.angegriffen ~= arg then
		player.angegriffen = arg
		-- raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonAngegriffen", "onATCPEventAvalonAngegriffen")



-- event == "AvalonGetoetet"
function onATCPEventAvalonGetoetet(event, arg)
	debugc("&lt;magenta&gt;AvalonGetoetet per ATCP empfangen!\n")
	arg = string.trim(arg)
	if player.getoetet ~= arg then
		player.getoetet = arg
		-- raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonGetoetet", "onATCPEventAvalonGetoetet")



-- event == "AvalonGruppeGetoetet"
function onATCPEventAvalonGruppeGetoetet(event, arg)
	debugc("&lt;magenta&gt;AvalonGruppeGetoetet per ATCP empfangen!\n")
	arg = string.trim(arg)
	if player.gruppeGetoetet ~= arg then
		player.gruppeGetoetet = arg
		-- raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonGruppeGetoetet", "onATCPEventAvalonGruppeGetoetet")



-- event == "AvalonAllyGetoetet"
function onATCPEventAvalonAllyGetoetet(event, arg)
	debugc("&lt;magenta&gt;AvalonAllyGetoetet per ATCP empfangen!\n")
	arg = string.trim(arg)
	if player.allyGetoetet ~= arg then
		player.allyGetoetet = arg
		-- raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonAllyGetoetet", "onATCPEventAvalonAllyGetoetet")


-- Hier stehen die ruebersicht-Daten der Runenschmiede drin.
function onATCPEventAvalonGildenInfo(event, arg)
	debugc("&lt;magenta&gt;AvalonGildenInfo per ATCP empfangen!\n")
	--cecho("\n&lt;magenta&gt;AvalonGildenInfo per ATCP empfangen!: "..arg.."\n")
  
	--arg = string.trim(arg)
	--if player.allyGetoetet ~= arg then
		--player.allyGetoetet = arg
		-- raiseEvent("RefreshInfobox", arg)
	--end
  avalonUI.processGuildInfo(arg)
end
registerAnonymousEventHandler("AvalonGildenInfo", "onATCPEventAvalonGildenInfo")


----------------------------------------------------------------------------------------
--  TP, TPMAX, AP, APMAX, ZP, ZPMAX, MP, MPMAX
----------------------------------------------------------------------------------------

-- event == "AvalonTP"
function onATCPEventAvalonTP(event, arg)
	if player.stats.tp ~= tonumber(arg) then 
		player.stats.tp = tonumber(arg)
		raiseEvent("RefreshHealthBar", {player.stats.tp, player.stats.tp_max})
	end
end
registerAnonymousEventHandler("AvalonTP", "onATCPEventAvalonTP")



-- event == "AvalonMAXTP"
function onATCPEventAvalonMAXT(event, arg)
	if player.stats.tp_max ~= tonumber(arg) then
		player.stats.tp_max = tonumber(arg)
		raiseEvent("RefreshHealthBar", {player.stats.tp, player.stats.tp_max})
	end
end
registerAnonymousEventHandler("AvalonMAXTP", "onATCPEventAvalonMAXT")



-- event == "AvalonAP"
function onATCPEventAvalonAP(event, arg)
	if player.stats.ap ~= tonumber(arg) then 
		player.stats.ap = tonumber(arg)
		raiseEvent("RefreshEnduranceBar", {player.stats.ap, player.stats.ap_max})
	end
end
registerAnonymousEventHandler("AvalonAP", "onATCPEventAvalonAP")



-- event == "AvalonMAXAP"
function onATCPEventAvalonMAXAP(event, arg)
	if player.stats.ap_max ~= tonumber(arg) then 
		player.stats.ap_max = tonumber(arg)
		raiseEvent("RefreshEnduranceBar", {player.stats.ap, player.stats.ap_max})
	end
end
registerAnonymousEventHandler("AvalonMAXAP", "onATCPEventAvalonMAXAP")



-- event == "AvalonSP"
function onATCPEventAvalonSP(event, arg)
	if player.stats.zp ~= tonumber(arg) then 
		player.stats.zp = tonumber(arg)
		raiseEvent("RefreshSpellpointsBar", {player.stats.zp, player.stats.zp_max})
	end
end
registerAnonymousEventHandler("AvalonSP", "onATCPEventAvalonSP")



-- event == "AvalonMAXSP"
function onATCPEventAvalonMAXSP(event, arg)
	if player.stats.zp_max ~= tonumber(arg) then 
		player.stats.zp_max = tonumber(arg)
		raiseEvent("RefreshSpellpointsBar", {player.stats.zp, player.stats.zp_max})
	end
end
registerAnonymousEventHandler("AvalonMAXSP", "onATCPEventAvalonMAXSP")



-- event == "AvalonMP"
function onATCPEventAvalonMP(event, arg)
	if player.stats.mp ~= tonumber(arg) then
		player.stats.mp = tonumber(arg)
		raiseEvent("RefreshManaBar", {player.stats.mp, player.stats.mp_max})
	end
end
registerAnonymousEventHandler("AvalonMP", "onATCPEventAvalonMP")



-- event == "AvalonMAXMP"
function onATCPEventAvalonMAXMP(event, arg)
	if player.stats.mp_max ~= tonumber(arg) then
		player.stats.mp_max = tonumber(arg)
		raiseEvent("RefreshManaBar", {player.stats.mp, player.stats.mp_max})
	end
end
registerAnonymousEventHandler("AvalonMAXMP", "onATCPEventAvalonMAXMP")



----------------------------------------------------------------------------------------
--  Kommunikation
--
-- Meldungen über channel:
-- Avalon.Channel [kanalname] [Nachricht]
----------------------------------------------------------------------------------------

-- event == "AvalonChannel"
function onATCPEventAvalonChannel(event, arg)
  debugc("AvalonChannel = " .. arg .. "\n")
  
  -- Zu Beginn der ATCP-Nachricht steht der Kanal, über den sie geschickt wurde.
  -- Wenn ein Mensch per "vr" zu den Menschen spricht, dann steht da: "mensch ..."
  -- Dieser Kanal wird hier extrahiert. Gleichzeitig wird der erste Buchstabe in
  -- einen Großbuchstaben geändert.
  channel = string.title(string.match(arg, "^(%w+)"))
  -- Die eigentliche Nachricht ist der Teil nach dem ersten Leerzeichen.
  message = arg:gsub("^.-%s", "", 1)
  -- Die Nachricht kann Steuercode enthalten, beispielsweise für farbigen Text.
  -- Der wird hier rausgefiltert.
  --message = clearMessage(message)
  
  -- Die Channelnamen hängen davon ab, in welcher Gilde, Zunft, in welchem Volk etc. der Char ist.
  -- Auf der Oberfläche sollen die Kanalnamen aber "Volk" und "Gilde" etc. heißen. Zünfte sollen
  -- außerdem zusammengefasst werden, das wird ja sonst viel zu viele Tabs. 
  -- Um an die "echten" Channelnamen zu kommen, plündere ich mal das Skript von Twrx. Sollte da
  -- nicht alles richtig ankommen, melden sich hoffentlich die Spieler.
  if channel == "Hyraskrieger" then channel = "Gilde" end
  if channel == "Golemkultisten" then channel = "Gilde" end
  if channel == "Daemonenkrieger" then channel = "Gilde" end
  if channel == "Runenschmiede" then channel = "Gilde" end
  if channel == "Barden" then channel = "Gilde" end
  if channel == "Kleriker" then channel = "Gilde" end
  if channel == "Druiden" then channel = "Gilde" end
  if channel == "Nekromanten" then channel = "Gilde" end
  if channel == "Magier" then channel = "Gilde" end

  if channel == "Schneider" then channel = "Zuenfte" end
  if channel == "Orkjaeger" then channel = "Zuenfte" end
  if channel == "Koeche" then channel = "Zuenfte" end
  --[[
  local AVA_CONST_NATIONS = {
    "Mensch",
    "Hobbit",
    "Elf",
    "Dunkelelf",
    "Zwerg",
    "Chaoszentaur",
    "Amphib",
    "Exxen",
    "Oger"
  }
  ]]
  player.nation = player.nation or ""

  if channel == "Mensch" then
    if player.nation ~= "Menschen" then
      player.nation = "Menschen"
      raiseEvent("RefreshInfobox")
    end
    channel = "Volk"
  elseif channel == "Hobbit" then
    if player.nation ~= "Hobbits" then
      player.nation = "Hobbits"
      raiseEvent("RefreshInfobox")
    end
    channel = "Volk"
  elseif channel == "Elf" then
    if player.nation ~= "Elfen" then
      player.nation = "Elfen"
      raiseEvent("RefreshInfobox")
    end
    channel = "Volk"
  elseif channel == "Dunkelelf" then
    if player.nation ~= "Dunkelelfen" then
      player.nation = "Dunkelelfen"
      raiseEvent("RefreshInfobox")
    end
    channel = "Volk"
  elseif channel == "Zwerg" then
    if player.nation ~= "Zwerge" then
      player.nation = "Zwerge"
      raiseEvent("RefreshInfobox")
    end
    channel = "Volk"
  elseif channel == "Chaoszentaur" then
    if player.nation ~= "Chaoszentauren" then
      player.nation = "Chaoszentauren"
      raiseEvent("RefreshInfobox")
    end
    channel = "Volk"
  elseif channel == "Amphib" then
    if player.nation ~= "Amphiben" then
      player.nation = "Amphiben"
      raiseEvent("RefreshInfobox")
    end
    channel = "Volk"
  elseif channel == "Exxen" then
    if player.nation ~= "Exxen" then
      player.nation = "Exxen"
      raiseEvent("RefreshInfobox")
    end
    channel = "Volk"
  elseif channel == "Oger" then   
    if player.nation ~= "Oger" then 
      player.nation = "Oger"
      raiseEvent("RefreshInfobox")
    end
    channel = "Volk"
  end
  --[[
  if channel == "Mensch" then channel = "Volk" end
  if channel == "Hobbit" then channel = "Volk" end
  if channel == "Elf" then channel = "Volk" end
  if channel == "Dunkelelf" then channel = "Volk" end
  if channel == "Zwerg" then channel = "Volk" end
  if channel == "Chaoszentaur" then channel = "Volk" end
  if channel == "Amphib" then channel = "Volk" end
  if channel == "Exxen" then channel = "Volk" end
  if channel == "Oger" then channel = "Volk" end
  ]]
  -- Schließlich wird die Nachricht in das entsprechende Logfile geschrieben.
  -- Diese Dateien liegen im "log"-Verzeichnis im jeweiligen Mudlet-Profil.
  -- Und sie sind nach dem Kanalnamen benannt. ("Sagen.txt")
  -- TODO: Charakternamen hinzufügen, damit ein Profil auch mit unterschiedlichen
  --       Charakteren gespielt werden kann.
--  Logger:Log(channel, message, {"timestamp", split = 4000})
  avalonUI.processMessage(channel, message)
  -- Anschließend muss evtl. die Anzeige auf der Oberfläche aktualisiert werden.
  -- Dafür sorgt dieses Event:
--  raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonChannel", "onATCPEventAvalonChannel")



-- event == "AvalonComm" (Sagen)
function onATCPEventAvalonComm(event, arg)
  debugc("AvalonComm = " .. arg .. "\n")
  -- Der Kanalname steht auch am Anfang der Nachricht, aber in Kapitalien.
  -- Ich setz den einfach mal von Hand:  
  channel = "Sagen"
  -- Die eigentliche Nachricht ist der Teil hinter dem ersten Leerzeichen,
  -- alles vorher wird hier abgeschnitten.
  message = arg:gsub("^.-%s", "", 1)
  -- Die Nachricht wird von Steuercode (Farbe) befreit:
  --message = clearMessage(message)
  -- Die Nachricht wird in das entsprechende Logfile geschrieben:
  --Logger:Log(channel, message, {"timestamp", split = 4000})
  avalonUI.processMessage(channel, message)
  -- Die Anzeige auf der Oberfläche wird ggf. aktualisiert:
  --raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonComm", "onATCPEventAvalonComm")



-- event == "AvalonRComm" (Reden)
function onATCPEventAvalonRComm(event, arg)
	debugc("AvalonRComm = " .. arg .. "\n")
	channel = "Reden"
	message = arg:gsub("^.-%s", "", 1)
	--message = clearMessage(message)
	--Logger:Log(channel, message, {"timestamp", split = 4000})
  avalonUI.processMessage(channel, message)
	--raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonRComm", "onATCPEventAvalonRComm")



-- event == "AvalonSoul" (Sagen)
function onATCPEventAvalonSoul(event, arg)
	debugc("AvalonSoul = " .. arg .. "\n")
	channel = "Sagen"
	message = arg:gsub("^.-%s", "", 1)
	--message = clearMessage(message)
	--Logger:Log(channel, message, {"timestamp", split = 4000})
  avalonUI.processMessage(channel, message)
	--raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonSoul", "onATCPEventAvalonSoul")



-- event == "AvalonRSoul" (Reden)
function onATCPEventAvalonRSoul(event, arg)
  debugc("AvalonRSoul = " .. arg .. "\n")
  channel = "Reden"
  -- Kanalnamen aus der Nachricht entfernen:
  message = arg:gsub("^.-%s", "", 1)
  -- Formatierungen entfernen:
  --message = clearMessage(message)
  -- Nachricht ins logfile schreiben:
  --Logger:Log(channel, message, {"timestamp", split = 4000})
  avalonUI.processMessage(channel, message)
  -- evtl. Anzeige auf der Oberfläche aktualisieren:
  --raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonRSoul", "onATCPEventAvalonRSoul")



----------------------------------------------------------------------------------------
--  ??? Item-Handling
----------------------------------------------------------------------------------------

-- event == "AvalonInventarRein"
function onATCPEventAvalonInventarRein(event, arg)
	debugc("AvalonInventarRein = " .. arg .. "\n")
	
	if player.inventarRein ~= arg then
		player.inventarRein = arg
--		raiseEvent("RefreshInfobox", arg)
	end
--	channel = "ATCP"
--	message = "AvalonInventarRein = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonInventarRein", "onATCPEventAvalonInventarRein")



-- event == "AvalonInventarRaus"
function onATCPEventAvalonInventarRaus(event, arg)
	debugc("AvalonInventarRaus = " .. arg .. "\n")
	
	if player.inventarRaus ~= arg then
		player.inventarRaus = arg
--		raiseEvent("RefreshInfobox", arg)
	end
--	channel = "ATCP"
--	message = "AvalonInventarRaus = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonInventarRaus", "onATCPEventAvalonInventarRaus")



-- event == "AvalonBehaelterRein"
function onATCPEventAvalonBehaelterRein(event, arg)
	debugc("AvalonBehaelterRein = " .. arg .. "\n")
	
	if player.behaelterRein ~= arg then
		player.behaelterRein = arg
--		raiseEvent("RefreshInfobox", arg)
	end
--	channel = "ATCP"
--	message = "AvalonBehaelterRein = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonBehaelterRein", "onATCPEventAvalonBehaelterRein")



-- event == "AvalonBehaelterRaus"
function onATCPEventAvalonBehaelterRaus(event, arg)
	debugc("AvalonBehaelterRaus = " .. arg .. "\n")
	
	if player.behaelterRaus ~= arg then
		player.behaelterRaus = arg
--		raiseEvent("RefreshInfobox", arg)
	end
--	channel = "ATCP"
--	message = "AvalonBehaelterRaus = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonBehaelterRaus", "onATCPEventAvalonBehaelterRaus")



-- event == "AvalonGefuehrt"
function onATCPEventAvalonGefuehrt(event, arg)
	debugc("AvalonAvalonGefuehrt = " .. arg .. "\n")
	
	if player.gefuehrt ~= arg then
		player.gefuehrt = arg
--		raiseEvent("RefreshInfobox", arg)
	end
--	channel = "ATCP"
--	message = "AvalonGefuehrt = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonGefuehrt", "onATCPEventAvalonGefuehrt")



-- event == "AvalonGesenkt"
function onATCPEventAvalonGesenkt(event, arg)
	debugc("AvalonGesenkt = " .. arg .. "\n")
	
	if player.gesenkt ~= arg then
		player.gesenkt = arg
--		raiseEvent("RefreshInfobox", arg)
	end
--	channel = "ATCP"
--	message = "AvalonGesenkt = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonGesenkt", "onATCPEventAvalonGesenkt")



-- event == "AvalonAngezogen"
function onATCPEventAvalonAngezogen(event, arg)
	debugc("AvalonAvalonAngezogen = " .. arg .. "\n")
	
	if player.angezogen ~= arg then
		player.angezogen = arg
--		raiseEvent("RefreshInfobox", arg)
	end
--	channel = "ATCP"
--	message = "AvalonAngezogen = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonAngezogen", "onATCPEventAvalonAngezogen")



-- event == "AvalonAusgezogen"
function onATCPEventAvalonAusgezogen(event, arg)
	debugc("AvalonGesenkt = " .. arg .. "\n")
	
	if player.ausgezogen ~= arg then
		player.ausgezogen = arg
--		raiseEvent("RefreshInfobox", arg)
	end
--	channel = "ATCP"
--	message = "AvalonAusgezogen = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonAusgezogen", "onATCPEventAvalonAusgezogen")



--------------------------------------------------------------------
-- Map/Mapper
--------------------------------------------------------------------

-- event == "AvalonDunkel"
function onATCPEventAvalonDunkel(event, arg)
  debugc("AvalonDunkel = " .. tostring(arg) .. "\n")
  --cecho("&lt;magenta&gt;AvalonDunkel = " .. tostring(arg) .. "\n")

  if (player.istDunkel ~= tostring(arg)) then
    player.istDunkel = tostring(arg)
    raiseEvent("RefreshInfobox", arg)
  end
--	-- mapper.dunkel gibt es nicht, bei bedarf anlegen	
--	if tmapper.dunkel ~= arg then
--		tmapper.dunkel = arg
--	end
--	channel = "ATCP"
--	message = "AvalonDunkel = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
  --raiseEvent("RefreshInfobox", arg)
end
registerAnonymousEventHandler("AvalonDunkel", "onATCPEventAvalonDunkel")

-- ATCP.AvalonInstance kann man anfordern, da steht dann die RoomID drin...
-- Klingt für mich wie n Bug, mal bei Gelegenheit nachfragen. TODO
function onATCPEventAvalonInstance(event, arg)
  debugc("AvalonInstance = " .. tostring(arg) .. "\n")
  --cecho("\n&lt;magenta&gt;AvalonInstance (= AvalonRoomID): "..tostring(arg).."\n")

  -- Also hier kommt irgendwie eine verbeulte RoomID: sie beginnt mit "hier ", dann kommt die ID
  -- und dann statt des Namen in Anführungszeichen nur leere Anführungszeichen.
  
  -- erstmal das führende "hier " abtrennen
  arg = string.gsub(arg, "hier (.*)", "%1")
  
  -- dann zur Weiterverarbeitung an die Funktion übergeben, die die RoomID sonst auch
  -- verarbeitet. (Und dort dann den Sonderfall "leere Zeichenkette beim Namen" verarbeiten.
  raiseEvent("AvalonRoomID", arg)
  
end
registerAnonymousEventHandler("AvalonInstance", "onATCPEventAvalonInstance")


-- event == "AvalonRoomID"
function onATCPEventAvalonRoomID(event, arg)
  debugc("AvalonRoomID = " .. tostring(arg) .. "\n")
  --cecho("\n&lt;magenta&gt;AvalonRoomID: "..tostring(arg).."\n")

  -- TODO: hier müsste AvalonInstance noch durchgeschleust werden,
  -- und zwar um "ava_req_inv hier" zu aktualisieren.
  -- Dafür muss das aber umgebaut werden.
  -- Erstmal den RoomHash extrahieren. Dann gucken, ob der Name
  -- des Raums nur ein leerer String ist. Ist dem so, dann einfach
  -- den aktuellen Wert beibehalten. Sonst den neuen übernehmen.


  player.avalonRoomID = ""
  --player.avalonRoomID = tostring(arg)
  str = string.gsub(arg, "^%S*%s+(.+)", "%1", 1)
  if str ~= '""' then 
    player.avalonRoomID = str
    avalonUI.IGMapModel.room = str
  end
  str = string.gsub(arg, "^raum/(%S*)%s+.+", "%1", 1)
  player.avalonRoomHash = str
  
  
  
  
  
  lagStopWatch = lagStopWatch or createStopWatch() -- create, or re-use a stopwatch, and store the watchID in a global variable to access it from anywhere

  -- then you can start the stop watch in some trigger/alias/script with:
  startStopWatch(lagStopWatch)
  
  sendATCP("ava_req_inv hier")
  
  --cecho("&lt;magenta&gt;avalonRoomHash: " .. str .. "\n")

--	-- tMapper.roomID gibt es nicht, bei bedarf anlegen	
--	if tMapper.roomID ~= arg then
--		tMapper.roomID = arg
--	end
--	channel = "ATCP"
--	message = "AvalonRoomID = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
--  raiseEvent("RefreshInfobox", arg)                                   --TODO: Kann dann weg
  raiseEvent("RefreshIngameMap", arg)
  
end
registerAnonymousEventHandler("AvalonRoomID", "onATCPEventAvalonRoomID")



-- event == "AvalonRoomBrief"
function onATCPEventAvalonRoomBrief(event, arg)
	debugc("AvalonRoomBrief = " .. tostring(arg) .. "\n")
	--echo("AvalonRoomBrief = " .. tostring(arg) .. "\n")

--	-- tMapper.roomBrief gibt es nicht, bei bedarf anlegen	
--	if tMapper.roomBrief ~= arg then
--		tMapper.roomBrief = arg
--	end
--	channel = "ATCP"
--	message = "AvalonRoomBrief = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonRoomBrief", "onATCPEventAvalonRoomBrief")



-- event == "AvalonArea"
function onATCPEventAvalonArea(event, arg)
	debugc("AvalonArea = " .. tostring(arg) .. "\n")
	--echo("AvalonArea = " .. tostring(arg) .. "\n")

--	-- tMapper.area gibt es nicht, bei bedarf anlegen	
--	if tMapper.area ~= arg then
--		tMapper.area = arg
--	end
--	channel = "ATCP"
--	message = "AvalonArea = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonArea", "onATCPEventAvalonArea")



-- event == "AvalonInv"
function onATCPEventAvalonInv(event, arg)
	debugc("AvalonInv = " .. tostring(arg) .. "\n")
	--echo("AvalonInv = " .. tostring(arg) .. "\n")
  
    -- to stop the watch and measure its time in e.g. a trigger script you can write:
  lagTime = stopStopWatch(lagStopWatch)
  if lagTime ~= nil then
    --echo("Antwortzeit INV: " .. lagTime .. " seconds.")
  end
  resetStopWatch(lagStopWatch)

  raiseEvent("ProcessAvalonInv", arg)

end
registerAnonymousEventHandler("AvalonInv", "onATCPEventAvalonInv")



-- event == "AvalonSite"
function onATCPEventAvalonSite(event, arg)
	debugc("AvalonSite = " .. tostring(arg) .. "\n")
	--echo("AvalonSite = " .. tostring(arg) .. "\n")

--	-- tMapper.site gibt es nicht, bei bedarf anlegen	
--	if tMapper.site ~= arg then
--		tMapper.site = arg
--	end
--	channel = "ATCP"
--	message = "AvalonSite = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonSite", "onATCPEventAvalonSite")



-- event == "AvalonExits"
function onATCPEventAvalonExits(event, arg)
	debugc("AvalonExits = " .. tostring(arg) .. "\n")

--	-- tMapper.exits gibt es nicht, bei bedarf anlegen	
--	if tMapper.exits ~= arg then
--		tMapper.exits = arg
--	end
--	channel = "ATCP"
--	message = "AvalonExits = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonExits", "onATCPEventAvalonExits")



-- event == "AvalonAvalonWeg"
function onATCPEventAvalonAvalonWeg(event, arg)
	debugc("AvalonAvalonWeg = " .. tostring(arg) .. "\n")

--	-- tMapper.avalonWeg gibt es nicht, bei bedarf anlegen	
--	if tMapper.avalonWeg ~= arg then
--		tMapper.avalonWeg = arg
--	end
--	channel = "ATCP"
--	message = "AvalonAvalonWeg = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonAvalonWeg", "onATCPEventAvalonAvalonWeg")



-- event == "AvalonAvalonIcon16"
function onATCPEventAvalonAvalonIcon16(event, arg)
	debugc("AvalonAvalonWeg = " .. tostring(arg) .. "\n")

--	-- tMapper.avalonIcon16 gibt es nicht, bei bedarf anlegen	
--	if tMapper.avalonIcon16 ~= arg then
--		tMapper.avalonIcon16 = arg
--	end
--	channel = "ATCP"
--	message = "AvalonAvalonIcon16 = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonAvalonIcon16", "onATCPEventAvalonAvalonIcon16")



--------------------------------------------------------------------
-- onKill wird durch einen kill ausgelöst -- ab hier nicht funktionsfähig
--------------------------------------------------------------------

function onKillEvent(event,name,file)
	--sendATCP("ava_req_inv", "hier")
	if tMetzel and tMetzel.sMode ~= nil then fMetzelGetoetet() end 
	--sendAll("r","t bewohner")
end
--registerAnonymousEventHandler("KillEvent", "onKillEvent")

-- Script: AvalonAllyGetoetet
function AvalonAllyGetoetet(event,arg)
	onATCP (event,arg)
	raiseEvent("onKillEvent",arg)
end
--registerAnonymousEventHandler("AvalonAllyGetoetet", "AvalonAllyGetoetet")

-- Script: AvalonAP
function AvalonAP(event,arg)
	tPlayer.diffap = tonumber(arg) - tonumber(tPlayer.ap)
	onATCP (event,arg)
end
--registerAnonymousEventHandler("AvalonAP", "AvalonAP")


-- Script: AvalonBehaelterRaus
function AvalonBehaelterRaus(event,arg)
	onATCP (event,arg)
	--sendATCP("ava_req_inv", "mich")
end
--registerAnonymousEventHandler("AvalonBehaelterRaus", "AvalonBehaelterRaus")

-- Script: AvalonBehaelterRein
function AvalonBehaelterRein(event,arg)
	onATCP (event,arg)
	--sendATCP("ava_req_inv", "mich")
end
--registerAnonymousEventHandler("AvalonBehaelterRein", "AvalonBehaelterRein")
</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<Script isActive="no" isFolder="no">
			<name>ReplaceUmlauts</name>
			<packageName></packageName>
			<script>-- Hier werden - als letztes in der Verarbeitungskette - eventuelle
-- Umlaute aus den Strings entfernt, die ans MUD geschickt werden.
-- Diese Funktion macht im Grunde das, was sie soll. Sie verhindert
-- aber nicht, dass Mudlet eine Warnung ausgibt, wenn das erste mal
-- nach dem Start von Mudlet ein Umlaut eingegeben wird. Und diese
-- Warnung besagt, dass das Mud wohl keine Umlaute versteht. Diese
-- Warnung möchte ich den Usern nicht zumuten. Und ich weiß nicht,
-- wie ich sie abstellen kann. Ich sehe keine andere Möglichkeit,
-- als das Alias "Umlauts" aktiv zu lassen. Auch wenn das bedeutet,
-- dass eigene Alias' mit Umlauten u.U. mehrfach ausgeführt werden.
-- Diese Funktion wird dann nicht benötigt.
--[[
function replaceUmlauts(event, command)

  if string.match(command, "[äöüÄÖÜß]") then
    command = string.gsub(command, 'ü', 'ue' );
    command = string.gsub(command, 'ö', 'oe' );
    command = string.gsub(command, 'ä', 'ae' );
    command = string.gsub(command, 'Ä', 'Ae' );
    command = string.gsub(command, 'Ö', 'Oe' );
    command = string.gsub(command, 'Ü', 'Ue' );
    command = string.gsub(command, 'ß', 'ss' );
  end
  
end --function replaceUmlauts

registerAnonymousEventHandler("sysDataSendRequest", "replaceUmlauts")
]]</script>
			<eventHandlerList />
		</Script>
	</ScriptPackage>
	<KeyPackage>
		<KeyGroup isActive="yes" isFolder="yes">
			<name>Keypadfunktionen</name>
			<packageName></packageName>
			<script></script>
			<command></command>
			<keyCode>-1</keyCode>
			<keyModifier>0</keyModifier>
			<Key isActive="yes" isFolder="no">
				<name>9 - nordosten</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",9)</script>
				<command></command>
				<keyCode>57</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>8 - norden</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",8)</script>
				<command></command>
				<keyCode>56</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>7 - nordwesten</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",7)</script>
				<command></command>
				<keyCode>55</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>6 - osten</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",6)</script>
				<command></command>
				<keyCode>54</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>5 - schau</name>
				<packageName></packageName>
				<script>sendATCP("ava_req_iid", "hier")
raiseEvent("keyPadEvent",5)
				</script>
				<command></command>
				<keyCode>53</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>4 - westen</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",4)</script>
				<command></command>
				<keyCode>52</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>3 - suedosten</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",3)</script>
				<command></command>
				<keyCode>51</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>2 - sueden</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",2)</script>
				<command></command>
				<keyCode>50</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>1 - suedwesten</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",1)</script>
				<command></command>
				<keyCode>49</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>- - hoch</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",10)</script>
				<command></command>
				<keyCode>45</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>+ - runter</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",11)</script>
				<command></command>
				<keyCode>43</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>/ - rein</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",12)</script>
				<command></command>
				<keyCode>47</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>* - raus</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",13)</script>
				<command></command>
				<keyCode>42</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
		</KeyGroup>
		<KeyGroup isActive="yes" isFolder="yes">
			<name>Fernrohr</name>
			<packageName></packageName>
			<script></script>
			<command></command>
			<keyCode>-1</keyCode>
			<keyModifier>0</keyModifier>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-1</name>
				<packageName></packageName>
				<script></script>
				<command>spaehe sw</command>
				<keyCode>49</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-2</name>
				<packageName></packageName>
				<script></script>
				<command>spaehe s</command>
				<keyCode>50</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-3</name>
				<packageName></packageName>
				<script></script>
				<command>spaehe so</command>
				<keyCode>51</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-4</name>
				<packageName></packageName>
				<script></script>
				<command>spaehe w</command>
				<keyCode>52</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-5</name>
				<packageName></packageName>
				<script></script>
				<command>schau</command>
				<keyCode>53</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-6</name>
				<packageName></packageName>
				<script></script>
				<command>spaehe o</command>
				<keyCode>54</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-7</name>
				<packageName></packageName>
				<script></script>
				<command>spaehe nw</command>
				<keyCode>55</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-8</name>
				<packageName></packageName>
				<script></script>
				<command>spaehe n</command>
				<keyCode>56</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-9</name>
				<packageName></packageName>
				<script></script>
				<command>spaehe no</command>
				<keyCode>57</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
		</KeyGroup>
	</KeyPackage>
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
