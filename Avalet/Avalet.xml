<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>OnReconnect</name>
			<script>--[[
Dieser Trigger löst einen Event aus, wenn der Char Statue war.
Also nicht neu eingeloggt wurde, sondern "reconnected". ]]
raiseEvent("onReconnectEvent")
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>transparent</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^Verwende alten Koerper...$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>InfoBoxInjection</name>
			<script>--[[
Diese Trigger-Chain versucht, bestimmte Ausgaben in der Hauptconsole aufzunehmen und
zusätzlich in die InfoBox auszugeben. Das sind Ausgaben wie das Inventar, der Spielstand,
Ausrüstung und verschiedene Gruppeninformationen.
Da diese Ausgaben immer anders aussehen, ist das mit spezifischen Triggern kaum zu machen.
Deshalb wird hier ganz simpel einfach "alles" genommen - der reguläre Ausdruck hier reagiert
auf jede beliebige Zeile. Aktiviert wird diese Trigger-Chain durch ein Alias auf den ent-
sprechenden Befehl (i, sp, g, g info,...). Beendet wird sie durch den nächsten Prompt.
Die Idee ist also, einfach den Bereich zwischen dem eingegebenen Befehl und dem Prompt nach
Abarbeitung des Befehls zu finden. Das funktioniert sehr oft genau so. Ab und an kommt
man sich da aber auch selber in die Quere, indem man zum Beispiel sofort noch einen zweiten
Befehl abschickt. Oder einfach nochmal "Enter" drückt. Oder sonst irgendwie dafür sorgt,
dass ein vorzeitiger Prompt erscheint. Normalerweise macht das aber nichts, da man den Befehl
ja auch einfach gleich nochmal eingegeben kann.
Ursprünglich war das als "quick&amp;dirty"-Lösung für diese Funktion gedacht. Und ich hatte vor,
mich später um elegantere Trigger zu kümmern. Aber tatsächlich funktioniert es so gut, dass
es dafür meiner Meinung nach keinen Grund gibt. 
Um die Ausgabe weiterer Befehle in die InfoBox zu duplizieren, einfach einen weiteren Alias
(nach Vorbild der bestehenden) hinzufügen. ]]

--[[
Lässt den Trigger für 60 weitere Zeilen offen ]]
setTriggerStayOpen("InfoBoxInjection", 60)

--[[
Fügt die Zeile unter dem (virtuellen) Cursor dem injectionBuffer hinzu. Auf diese
Weise wird auch die Abbruchbedingung (Prompt oder Kompass) noch erfasst. Aber das 
wird später bei der Ausgabe korrigiert. ]]
if not isPrompt() then
  selectCurrentLine()
  copy()
  appendBuffer("InjectionBuffer")
  -- Zeilenzahl im Buffer ist für die Ausgabe wichtig
  avalet.infoBox.injectionBufferRows = avalet.infoBox.injectionBufferRows + 1
end
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>60</conditonLineDelta>
			<mStayOpen>60</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^.*$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>InfoBoxInjectionEnde</name>
				<script>--[[
Wenn die Trigger-Chain aktiviert wird, reagiert dieser Trigger auf den nächsten
Prompt. Und deaktiviert die Trigger-Chain wieder. Für Spieler, die den "Kompass"
benutzen, wird schon darauf reagiert (weil man das ja sicher auch nicht in der
Info-Box haben will).
Durch den Event wird die Ausgabe des Injection-Buffers in die InfoBox veranlasst. ]]

disableTrigger("InfoBoxInjection")
raiseEvent("InjectionBufferChange")
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string></string>
					<string>^   Kommandos:.*$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>7</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</Trigger>
		<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>AvaletKampf</name>
			<script>--[[
Erlaubte Werte fuer die Kampfanzeige sind: "alles", "treffer", "sehr
leicht", "leicht", "hart", "stark", "sehr stark", "extrem stark", "doppelt
extrem" und "minimal".

  &lt;trigger
   custom_colour="6"
   enabled="y"
   match="*Du triffst*"
   name="Hitline"
   script="Hitline"
   sequence="100"
  &gt;
  &lt;/trigger&gt;
  &lt;trigger
   custom_colour="7"
   enable="y"
   match="(Kopf|Koerper|Arm|Bein|Vorderbein|Hinterbein|Schwanz*)\.$"
   name="Hitline2"
   regexp="y"
   script="Hitline2"
   sequence="110"
  &gt;
  &lt;/trigger&gt;
  &lt;trigger
   custom_colour="8"
   enabled="y"
   match="([A-z, ]*) (trifft|streift|kratzt|wuergt|beisst) ([A-z, ]*)$"
   name="Hitline3"
   regexp="y"
   script="Hitline3"
   sequence="120"
  &gt;
  &lt;/trigger&gt;
  &lt;/trigger&gt;
  &lt;trigger
   custom_colour="8"
   keep_evaluating="y"
   match="([A-z, ]*) am ([A-z, ]*)\.$"
   name="Hitline4"
   regexp="y"
   script="Hitline4"
   sequence="90"
  &gt;
  &lt;/trigger&gt;


'-----------------------------------'
'Farbtriggereinstellung fuer Treffer'
'-----------------------------------'
'Zum ausschalten des ganzen:
'Sub Hitline(tname, tline, twild)
'	world.enableTrigger "Hitline", 0
'	world.enableTrigger "Hitline2", 0
'	world.enableTrigger "Hitline3", 0
'	world.enableTrigger "Hitline4", 0
'	world.note "----- und aus -----"
'End Sub

Sub Hitline(tname, tline, twild)
	world.enableTrigger "Hitline2", TRUE
	world.enableTrigger "Hitline4", FALSE
End Sub

Sub Hitline2(tname, tline, twild)
	world.enableTrigger "Hitline2", FALSE
End Sub

Sub Hitline3(tname, tline, twild)
	world.enableTrigger "Hitline4", TRUE
	world.enableTrigger "Hitline2", FALSE
End Sub

Sub Hitline4(tname, tline, twild)
	world.enableTrigger "Hitline4", FALSE
End Sub

]]
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Austeilen</name>
				<script>avalet.CONSTS.TREFFER = {
  ["doppelt extrem"] = "DOPPELT_EXTREM",
  ["extrem stark"] = "EXTREM_STARK",
  ["sehr stark"] = "SEHR_STARK",
  ["stark"] = "STARK",
  ["hart"] = "HART",
  --["???"] = "???",,
  ["leicht"] = "LEICHT",
  ["sehr leicht"] = "SEHR_LEICHT",
}
--[[
Erlaubte Werte fuer die Kampfanzeige sind: "alles", "treffer", "sehr
leicht", "leicht", "hart", "stark", "sehr stark", "extrem stark", "doppelt
extrem" und "minimal". ]]</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff5500</mFgColor>
				<mBgColor>#000000</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^   (Du triffst .* (sehr leicht|leicht|hart|stark|extrem stark) .*)$</string>
					<string>^   (Du parierst .* einen (Schlag|harten Schlag) .*\.)$</string>
					<string>^  (Du triffst.*)$</string>
					<string>^   (Du weichst .* aus\.)$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Einstecken</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff5500</mFgColor>
				<mBgColor>#000000</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^   ((Der|Die|Das|Ein|Eine) .* (beruehrt|rammt|tritt|beisst|erwischt|trifft) Dich .*)$</string>
					<string>^   ((Der|Die|Das|Ein|Eine) .* (weicht).*)$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>AvaletTriggerFuerTimer</name>
			<script>--[[
Diese Gruppe MUSS hier sein. Sie ist absichtlich leer. Die Trigger für
die Avalet-Timer werden in dieser Gruppe erstellt. Dokumentation siehe dort. ]]
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
		</TriggerGroup>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Alkohol</name>
			<script>--[[
Da der Alkohol-Zustand des Chars nicht per ATCP übertragen wird, versuche
ich den mal auf die umständliche Weise zu erfassen: per Trigger.

Reihenfolge von stark zu schwach:
Du hast einen maechtigen Rausch.
Du bist betrunken.
Du hast einen Schwips.
Du bist angeheitert.
Du fuehlst eine leichte Klarheit im Kopf. (--&gt; nüchtern)
Du verspuerst ploetzlich furchtbare Kopfschmerzen.
Du bist wieder nuechtern.
]]
    
local str = matches[1]
if avalet.char.getAlk() == nil then avalet.char.setAlk("Du bist nuechtern.") end

if str == "Die Welt dreht sich um Dich." then
  avalet.char.setAlk(str)
elseif str == "Du bist sternhagelvoll." then
  avalet.char.setAlk(str)
elseif str == "Du hast einen maechtigen Rausch." then
  avalet.char.setAlk(str)
elseif str == "Du bist betrunken." then
  avalet.char.setAlk(str)
elseif str == "Du hast einen Schwips." then
  avalet.char.setAlk(str)
elseif str == "Du bist angeheitert." then
  avalet.char.setAlk(str)
elseif str == "Du bist wieder nuechtern." then
  avalet.char.setAlk(str)
elseif str == "Du fuehlst eine leichte Klarheit im Kopf." then
  avalet.char.setAlk("Du bist nuechtern.")
elseif str == "Deine Kopfschmerzen verschwinden." then
  avalet.char.setAlk("Du bist nuechtern.")
else
  avalet.log("\nUnbehandelt im Avalet-Trigger Alkohol" .. matches[1], 3)
end

raiseEvent("RefreshHDA")
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#55007f</mFgColor>
			<mBgColor>#55ff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>Die Welt dreht sich um Dich.</string>
				<string>Du bist sternhagelvoll.</string>
				<string>Du hast einen maechtigen Rausch.</string>
				<string>Du bist betrunken.</string>
				<string>Du hast einen Schwips.</string>
				<string>Du bist angeheitert.</string>
				<string>Du bist wieder nuechtern.</string>
				<string>Du fuehlst eine leichte Klarheit im Kopf.</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>3</integer>
				<integer>3</integer>
				<integer>3</integer>
				<integer>3</integer>
				<integer>3</integer>
				<integer>3</integer>
				<integer>3</integer>
				<integer>3</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Hangover</name>
			<script>--[[
Vielleicht wäre es hier gut, noch einen Timer einzubauen, der die Kopfschmerzanzeige
irgendwann zurücksetzt. Falls der Trigger mal den Schluss-String verpasst. Das kam
gelegentlich (aber sehr selten) vor. TODO (Bzw. eigentlich müsste man erstmal die 
Gründe rausfinden, deshalb hab ich das nicht gemacht. War zu selten.) ]]

if matches[1] == "Du verspuerst ploetzlich furchtbare Kopfschmerzen." then
  avalet.char.setHangover(true)
elseif matches[1] == "Furchtbare Schmerzen jagen durch Deinen Kopf." then
  avalet.char.setHangover(true)
elseif matches[1] == "Deine Kopfschmerzen verschwinden." then
  avalet.char.setHangover(false)
end

raiseEvent("RefreshHDA")
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>Du verspuerst ploetzlich furchtbare Kopfschmerzen.</string>
				<string>Furchtbare Schmerzen jagen durch Deinen Kopf.</string>
				<string>Deine Kopfschmerzen verschwinden.</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>0</integer>
				<integer>0</integer>
				<integer>0</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>HDAAktualisierung</name>
			<script>--[[
Avalon sendet per ATCP, wenn sich der Hunger- bzw. Durst-Zustand verschlechtert.
Aber nicht, wenn er sich verbessert. Also nicht so schnell, wie man das gern hätte,
wenn man eine GUI entwickelt. Damit sich die Anzeige überhaupt mal zeitnah
aktualisiert, gibt es diesen Trigger. Der fordert aktiv ATCP-Daten an, und da 
steht dann der richtige Wert drin. ]]

_ = sendATCP("ava_req_update")
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>Das war jetzt aber noetig.</string>
				<string>Ahhh, tut das gut.</string>
				<string>Du hast ein feuchtes Gefuehl in der Kehle.</string>
				<string>Eigentlich hast Du genug.</string>
				<string>Du fuehlst Dich gesaettigt.</string>
				<string>Du bist randvoll.</string>
				<string>Naja, warum nicht.</string>
				<string>Dazu bist Du schon zu voll.</string>
				<string>Du bist gesaettigt</string>
				<string>Es schwappt und gluckert in Deinem Bauch.</string>
				<string>Du hast ausreichend gegessen.</string>
				<string>Du hast ausreichend getrunken.</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>0</integer>
				<integer>0</integer>
				<integer>0</integer>
				<integer>0</integer>
				<integer>0</integer>
				<integer>0</integer>
				<integer>0</integer>
				<integer>0</integer>
				<integer>0</integer>
				<integer>0</integer>
				<integer>0</integer>
				<integer>0</integer>
			</regexCodePropertyList>
		</Trigger>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Krankheiten-Vergiftungen-Flüche</name>
			<script>--[[
Das Giftflaschen-Symbol auf der Oberfläche, das Zustände wie 'krank',
'verflucht', 'vergiftet' anzeigen soll, muss durch Trigger gesteuert
werden. Denn diese Daten kommen nicht per ATCP. Das ist natürlich keine
so schöne Lösung, denn im Grunde gibts für jede Vergiftung etc. einen
eigenen Text, der hier erfasst werden müsste. Aber anders gehts nicht,
und ich finde das schon eine interessante Funktion für Avalet.
Diese Funktion ist also nur so gut, wie hier Texte gesammelt wurden.
Im Moment also nicht sehr gut... ]]</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>KrankheitenOneLiner</name>
				<script>--[[
Hier einzeilige Texte, die eine Krankheit bzw. einen Fluch auslösen oder anzeigen.
Mehrzeilige Texte, die innerhalb einer Textzeile eindeutig sind, können hier auch
rein. Dann halt die eindeutige Zeile nehmen, den Rest nicht. 

Zu viel Maalkraut:
Uiii, da geht etwas herum in Deinem Bauch. Vielleicht solltest Du nicht so
viele Pflanzen auf einmal essen.

Dein Bauch fuehlt sich ganz hart und steif an.
Du spuerst, wie Gase schmerzhaft von einer Darmwindung zur naechsten
kriechen.
Dein Bauch fuehlt sich hohl und aufgeblasen an.

Urgs, sind das Magenkraempfe?

]]
avalet.char.setKrankheit(true)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#000000</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Uiii, da geht etwas herum in Deinem Bauch. Vielleicht solltest Du nicht so</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>VergiftungenOneLiner</name>
				<script>--[[
Hier einzeilige Texte, die eine Krankheit bzw. einen Fluch auslösen oder anzeigen.
Mehrzeilige Texte, die innerhalb einer Textzeile eindeutig sind, können hier auch
rein. Dann halt die eindeutige Zeile nehmen, den Rest nicht. Beispiel Skorpion:
Der Skorpion schnellt seinen Stachel nach vorn und rammt ihn Dir tief ins
Fleisch.

Du hast das Gefuehl, als wenn Du Dich zersetzen wuerdest. Zum Glueck ist
dem nicht so, aber Dein Herz rast trotzdem.

Ploetzlich oeffnet die Nepenthes eine ihrer Kannen und leert Dir ein
uebelriechendes Gemisch ueber den Kopf.

Dir wird von dieser Fluessigkeit ganz anders.

Du fuehlst Dich extrem schwach auf den Beinen.

]]

avalet.char.setVergiftung(true)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#000000</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Dicke Schweissperlen bilden sich auf Deiner Stirn.</string>
					<string>Heftige Hitzewellen durchdringen Deinen Koerper.</string>
					<string>Irgendwie bist Du krank.</string>
					<string>Der Skorpion schnellt seinen Stachel nach vorn und rammt ihn Dir tief ins</string>
					<string>Kalter Schweiss laeuft Dir uebers Gesicht.</string>
					<string>Heftige Schuettelkraempfe plagen Dich.</string>
					<string>Dir wird von dieser Fluessigkeit ganz anders.</string>
					<string>Du fuehlst Dich extrem schwach auf den Beinen.</string>
					<string>Ploetzlich oeffnet die Nepenthes eine ihrer Kannen und leert Dir ein</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>0</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>3</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>FlücheOneLiner</name>
				<script>--[[
Hier einzeilige Texte, die eine Krankheit bzw. einen Fluch auslösen oder anzeigen.
Mehrzeilige Texte, die innerhalb einer Textzeile eindeutig sind, können hier auch
rein. Dann halt die eindeutige Zeile nehmen, den Rest nicht. Beispiel Skorpion:
Der Skorpion schnellt seinen Stachel nach vorn und rammt ihn Dir tief ins
Fleisch.

Du hast das Gefuehl, als wenn Du Dich zersetzen wuerdest. Zum Glueck ist
dem nicht so, aber Dein Herz rast trotzdem.

Müllberg Miobaas:
Du hast auf einmal Visionen von riesigen Muellbergen, die Dich zu
verschuetten drohen.

Balrog:
Die Flammen springen auf Dich ueber und Du beginnst am ganzen Koerper zu
brennen.
Die Flammen brennen heiss auf Deinem Koerper.
Die Flammen auf Deinem Koerper erloeschen.

]]
avalet.char.setFluch(true)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#000000</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Du hast das Gefuehl, als wenn Du Dich zersetzen wuerdest. Zum Glueck ist</string>
					<string>Die Flammen springen auf Dich ueber und Du beginnst am ganzen Koerper zu</string>
					<string>Puuuah, das Wasser schmeckt unangenehm schal und brackig.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>0</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>HeilungQuelleKrankheit</name>
				<script>
avalet.char.setKrankheit(false)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>2</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#00aa00</mFgColor>
				<mBgColor>#000000</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Das Quellwasser scheint wirkliche Wunder vollbringen zu koennen, Deine</string>
					<string>Krankheit ist voellig verschwunden!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>HeilungQuelleVergiftung</name>
				<script>--[[
Das Quellwasser scheint wirkliche Wunder vollbringen zu koennen, Dein Fluch
ist voellig verschwunden!


]]

avalet.char.setVergiftung(false)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>2</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#00aa00</mFgColor>
				<mBgColor>#000000</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Das Quellwasser scheint wirkliche Wunder vollbringen zu koennen, Deine</string>
					<string>Vergiftung ist voellig verschwunden!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>HeilungQuelleFluch</name>
				<script>avalet.char.setFluch(false)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>2</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#00aa00</mFgColor>
				<mBgColor>#000000</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Das Quellwasser scheint wirkliche Wunder vollbringen zu koennen, Dein Fluch</string>
					<string>ist voellig verschwunden!</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>HeilungFluch</name>
				<script>--[[
Hier einzeilige Texte, die das Ende eines Fluches oder einer Krankheit anzeigen.
Wenn innerhalb von zweit- bzw. mehrzeiligen Texten eine Zeile sehr eindeutig ist,
dann kann das hier auch rein. Dann halt nur die eindeutige Zeile hier aufnehmen,
den Rest nicht.
]]

avalet.char.setFluch(false)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#00aa00</mFgColor>
				<mBgColor>#000000</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Du hast Dich entflucht.</string>
					<string>hat Dich entflucht.</string>
					<string>Der Fluch scheint von Dir gewichen zu sein.</string>
					<string>Du spuerst, wie eine grosse Last von Dir faellt.</string>
					<string>Die Flammen auf Deinem Koerper erloeschen.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>0</integer>
					<integer>0</integer>
					<integer>0</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>HeilungVergiftung</name>
				<script>--[[
Das Giftgemisch der Nepenthes verliert seine Wirkung. Du fuehlst Dich
langsam etwas besser.

]]
avalet.char.setVergiftung(false)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Das Giftgemisch der Nepenthes verliert seine Wirkung. Du fuehlst Dich</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Daemonenkrieger</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>DaemonenNamenFuerWaffenverstaerkung</name>
				<script>avalet.timerModel.dkWaffenDaemonenName = matches[2]
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Du tastest telepathisch nach dem Bewusstsein von \"(\S*)\" und beginnst.*$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Hyraskrieger</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Febronenname</name>
				<script>avalet.timerModel.hyrasFebronEvo = true
avalet.timerModel.hyrasFebronName = matches[2]
--cecho("&lt;magenta&gt;Febronennamen-Trigger: avalet.timerModel.hyrasFebronName = "..matches[2].."\n")
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^Du holst Deinen Febron \"(\S*)\" aus Deinem Febronenbeutel.*$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Runenschmiede</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Schmiedehammer</name>
				<script>--[[
Hier wird die jeweilige 'Ladung' des Schmiedehammers erfasst,
wenn sich der Runi den Hammer ansieht. ]]
local CHARGE_POSITIVE = "positiv"
local CHARGE_NEGATIVE = "negativ"

if multimatches[3][2] == "blau" then
  avalet.guildInfo.runiGuildInfoModel.HammerCharge = CHARGE_POSITIVE
elseif multimatches[3][2] == "rot" then
  avalet.guildInfo.runiGuildInfoModel.HammerCharge = CHARGE_NEGATIVE
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>3</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Mit diesem Schmiedehammer kannst Du Deine Schmiedekunst ausueben. Die</string>
					<string>Symbole darauf weisen Dich als (Runenmeister|Runenforscher|Grossmeister) in der Gilde der Runenschmiede</string>
					<string>aus und glimmen (blau|rot)\.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Ladungsumkehr</name>
				<script>--[[
Hier wird die jeweilige 'Ladung' des Schmiedehammers erfasst,
wenn sich der Runi diese Ladung ändert. ]]
if avalet.guildInfo.runiGuildInfoModel.HammerCharge == "negativ" then

  avalet.guildInfo.runiGuildInfoModel.HammerCharge = "positiv"
  
else 

  avalet.guildInfo.runiGuildInfoModel.HammerCharge = "negativ"
  
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Die Ladung des Schmiedehammers hat sich geaendert.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>AutoKletternSchwimmen</name>
			<script>--[[
Hier wird das automatische klettern und das automatische schwimmen geregelt.
Der Trigger reagiert auf die Texte, mit denen Avalon mitteilt, dass man mit
normalem gehen nicht auf das nächste Feld kommt. Der Trigger wertet dann aus,
was notwendig ist (klettern oder schwimmen), und wiederholt den letzten
Bewegungs-Befehl (n, s, o, ...) zusammen mit der notwendigen Bewegungsart.
Nachteil: dadurch werden zwei Befehle in recht kurzer Zeit an das MUD geschickt,
was schonmal zu einem Unglück (Beinbruch o.ä.) führen kann.
Ist klettern bzw. schwimmen nicht mehr nötig, räumt der Trigger noch auf. ]]

--deleteLine()

if avalet.char.getLocomotion() == nil then avalet.char.setLocomotion("") end

local mot = matches[3]

if mot == "klettern" then
  avalet.char.setLocomotion("kletter")
elseif mot == "schwimmen" then
  avalet.char.setLocomotion("schwimme")
elseif mot == "nicht" then 
  avalet.char.setLocomotion("")
else
  avalet.log("Fehler in der Locomotion-Methode", 4)
end

move = string.trim(avalet.char.getLocomotion() .. " " .. avalet.char.getLastMove())
tempTimer(0.2, [[ send(move, true) ]])
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^(Du musst hier schon (schwimmen), um weiterzukommen!)$</string>
				<string>^(Dort musst Du (nicht) mehr schwimmen\.)$</string>
				<string>^(Du musst hier schon (klettern), um weiterzukommen!)$</string>
				<string>^(Dort musst Du (nicht) mehr klettern\.)$</string>
				<string>^(Du musst hier (nicht) schwimmen\.)$</string>
				<string>^(Das habe ich (nicht) verstanden. Meintest Du: \"kletter .\"\?)$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
				<integer>1</integer>
				<integer>1</integer>
				<integer>1</integer>
				<integer>1</integer>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>MapCapture</name>
			<script>--[[
Dieser Trigger versucht die Ingame-Map (IGMap) aus der Raumbeschreibung zu extrahieren,
um die dann in dem dafür vorgesehenen Bereich auszugeben. Hauptproblem dabei ist, 
möglichst viele IGMaps zu erkennen - und möglichst wenig sonstigen Content.
Derzeit funktioniert das ganze relativ simpel und dafür aber schon ziemlich gut.
Eine Erweiterung dieser Methode könnte so aussehen, dass für schwierige Bereiche
Daten fest einprogrammiert werden. Beispielsweise eine Kartenbreite von 9 für
Skalewar. Dann könnten diese Daten über die RoomID abgefragt werden. Bei den
AVALON_CONSTANTS findet sich dafür schon eine Liste, die wird aber derzeit nicht
genutzt. Optimal wäre, wenn die Karte zusätzlich per ATCP käme, und zwar mit allen
Farbinformationen und unabhängig von der Einstellung im Spielerbuch. Dann könnte
Avalet die Karte anzeige, und der Spieler könnte sie in der Raumbeschreibung aus-
schalten. Die Verhandlungen mit dem Adel dazu wären ein TODO.
Ein paar Daten, falls mal eine Überarbeitung notwendig werden sollte:
Maximale Kartengröße laut Spielerbuch: 33x17, default 17x9, minimum vielleicht
9x5 (das ist die default-Kartengröße im Kurzmodus). 

Funktion: 
Der Trigger geht davon aus, dass alle IGMaps von einem Rahmen umgeben sind.
Die erste Zeile einer Map beginnt mit einem "+", dann folgen unterschiedlich
viele "-", dann wieder ein "+". Die letzte Zeile einer IGMap sieht genau so
aus. Unterschieden werden die, weil bei der ersten Zeile noch keine Map ge-
captured wird (mapCapture == false), bei der letzten schon (mapCapture == true).
An Hand der ersten Zeile wird die Breite der Map ermittelt (Anzahl der Zeichen).
Die mittleren Zeilen einer IGMap sehen dann so aus, dass bei einer Zeichen-
kette der ermittelten Länge das erste und das letzte Zeichen aus einem "|" be-
steht. 
Die gecaptureten Zeilen kommen erst nochmal in einen Buffer, dabei wird die 
Zeilenzahl gezählt. Anschließend wird durch den "MapChange"-Event die View
dazu veranlasst, die Anzeige zu aktualisieren. ]]
  
if avalet.IGMapModel.mapCapture and line:sub(1,1) == '|' and line:sub(avalet.IGMapModel.mapCaptureLen, avalet.IGMapModel.mapCaptureLen) == '|' then

  selectSection(0, avalet.IGMapModel.mapCaptureLen)
  copy()
  appendBuffer("IGmapBuffer")
  avalet.IGMapModel.mapCaptureRows = avalet.IGMapModel.mapCaptureRows + 1
  
elseif avalet.IGMapModel.mapCapture and line:sub(1,1) == '+' and line:sub(avalet.IGMapModel.mapCaptureLen, avalet.IGMapModel.mapCaptureLen) == '+' then

  selectSection(0, avalet.IGMapModel.mapCaptureLen)
  copy()
  appendBuffer("IGmapBuffer")
  avalet.IGMapModel.mapCaptureRows = avalet.IGMapModel.mapCaptureRows + 1

  avalet.IGMapModel.mapCaptureColumns = avalet.IGMapModel.mapCaptureLen
  avalet.IGMapModel.mapCaptureLen = nil
  avalet.IGMapModel.mapCapture = false
  
  raiseEvent("MapChange")

elseif not avalet.IGMapModel.mapCapture and matches[2] ~= nil and matches[2]:len() &gt;= 9 and matches[2]:len() &lt; 21 then
  -- War "&gt; 10" statt "&gt;= 9". Geändert, damit Skalewar erfasst wird.
  -- Auswirkungen derzeit unklar.

  avalet.IGMapModel.mapCaptureLen = matches[2]:len()
  avalet.IGMapModel.mapCapture = true
  
  clearWindow("IGmapBuffer")
  selectSection(0, avalet.IGMapModel.mapCaptureLen)
  copy()
  appendBuffer("IGmapBuffer")
  avalet.IGMapModel.mapCaptureRows = 1
  
end
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^(\+---*\+)</string>
				<string>|</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
				<integer>2</integer>
			</regexCodePropertyList>
		</Trigger>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Statistics</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>BonusStundenEPZaehler</name>
				<script>if matches[1] == "Du bekommst nun eine Zeit lang erhoehte Erfahrung." then

  avalet.char.bonusEPStart()
  avalet.char.setBonusEP(0)
  --avalet.refreshCounter()
  tempRegexTrigger("^Du erhaeltst ([0-9]+) Erfahrungspunkte\.", function() avalet.char.bonusEPStop(); avalet.log("Bonusstunde beendet.", 2) end, 1)

elseif matches[2] == "ausserordentliche" then

  local ep = nil
  
  ep = tonumber(matches[3])
  avalet.char.setBonusEP(tonumber(avalet.char.getBonusEP()) + ep)
  --avalet.refreshCounter()
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Du bekommst nun eine Zeit lang erhoehte Erfahrung.</string>
					<string>Du erhaeltst (ausserordentliche) ([0-9]+) Erfahrungspunkte\.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>BonusStundenEPZaehler</name>
				<script>--[[
Entweder hier den Zähler für Session-EP deaktivieren (weiss statt grün).
Oder im Start-Trigger einen OneTime-Trigger auf diesen RegExpr hier erzeugen.
In diesem Fall muss der aber geschickt verwaltet werden, für den Fall,
dass zwei Bonusstunden unmittelbar nacheinander stattfinden. (Also den OneTime-
Trigger überschreiben oder so wenn eine Bonusstunde gestartet wird.)]]</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Du erhaeltst ([0-9]+) Erfahrungspunkte\.</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Artus</name>
			<script>
raiseGlobalEvent("avaletSendAllProfiles", "WARN", "Artus", "Und wird Dich gleich rausschmeissen!")

</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>Artus warnt Dich.*</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Armageddon</name>
			<script>
raiseGlobalEvent("avaletSendAllProfiles", "WARN", "ARMAGEDDON", "Und macht hier gleich das Licht aus!!!")
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#000000</mFgColor>
			<mBgColor>#ff00ff</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^Armageddon ruft.*$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
	</TriggerPackage>
	<TimerPackage>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>avaletTimersTimer</name>
			<script>--[[
Timer-Timer
Dieser Mudlet-Timer sorgt dafür, dass die Anzeige der Avalet-Timer
aktualisiert wird. Die hier sekündlich aufgerufene Funktion sorgt dafür,
dass ggf. die Reihenfolge der Timer geändert wird, dass die Schriftfarbe
die Restlaufzeit wiedergibt und dass der Fortschrittsbalken aktualisiert wird. ]]
avaletUI.refreshTimer()</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:01.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>DateTime</name>
			<script>--avaletUI.getAvalonTime()
avaletUI.Box42:echo(avaletUI.getAvalonTime())</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:01.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>ATCP-Update</name>
			<script>-- ATCP-Update
-- Manche Informationen werden von ATCP nicht automatisch verschickt. Beispielsweise
-- werden der Hunger- und der Durst-Status nicht aktualisiert, wenn der Char isst
-- oder trinkt. Und die Anzeige des Alters auf der Oberfläche ist natürlich auch nicht
-- aktuell. Ich setz hier deshalb mal alle 5 Sekunden eine manuelle Aktualisierung. 
-- Mal sehen, ob sich das bewährt.
_ = sendATCP("ava_req_update")</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:05.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>tickTimerTimer</name>
			<script>--
-- Dieser Timer sorgt für die Anzeige des "Ticks", das ist
-- der schmale Timer oberhalb von TP/AP/ZP. Der Timer zeigt
-- an, wann es wieder TP, ZP und AP dazu gibt. Also die 
-- Default-Regeneration.
avalet.vitals.refreshTickTimer()</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:01.000</time>
		</Timer>
	</TimerPackage>
	<AliasPackage>
		<Alias isActive="yes" isFolder="no">
			<name>logout</name>
			<script>--[[
Dieses Alias soll ausgelöst werden, wenn der Spieler den
Charakter richtig ausloggt. Aber NICHT, wenn er Statue wird.
Der hier ausgelöste Event räumt dann hauptsächlich Daten ab, damit
die nächste Session sauber beginnt. ]]

-- Der vom Spieler eingegebene Befehl wird ans MUD durchgreicht
send(matches[1],false)
-- Ein "logoutEvent" wird ausgelöst
raiseEvent("logoutEvent")
</script>
			<command></command>
			<packageName></packageName>
			<regex>^(ende|ende hier|einschlafen|schlaf ein|schlafe ein)$</regex>
		</Alias>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Infobox</name>
			<script>--[[
Die in dieser Gruppe versammelten 'alias' sorgen dafür, dass die Ausgabe der
jeweils vom Alias abgedeckten Befehle nicht nur im Hauptfenster ausgegeben
werden, sondern auch noch in der Info-Box, oben rechts in Avalet. Die Funktions-
weise ist dabei immer gleich. Der Befehl
  enableTrigger("InfoBoxInjection")
aktiviert eine Trigger-Chain mit einem "catch all"-Trigger und einem Trigger 
auf den "Prompt". Und der Befehl
  send(matches[1],false)
sendet die Benutzereingabe (auf die das Alias reagiert hat) dann auch an das MUD.
Der "catch all"-Trigger leitet jede durchlaufende Zeile in einen Buffer um, und
wenn sich darunter der Prompt findet, schaltet sich die Trigger-Chain wieder ab.
Im Ergebnis findet sich alles zwischen dem Befehl, auf den das Alias reagiert, 
und dem darauf als nächstes folgenden Prompt im Buffer wieder. Und dieser Buffer
wird dann in der Info-Box ausgegeben.

Ein weiteres Alias ('InfoboxDefault') setzt diesen Bereich auf den Standardwert zurück.
Falls man mal keine 10 Sekunden warten möchte. ]]</script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>InfoboxDefault</name>
				<script>--[[
Stellt in der InfoBox die Default-Ansicht wieder her. Dazu wird
erstmal der Timer (und dessen ID) gelöscht, der diesen Job sonst
in ein paar Sekunden erledigen würde. Der Event sorgt dann für
die Erneuerung des entsprechenden Bereichs. Erneuert wird mit
Standard-Wert, weil es keine gespeicherte TimerID gibt dann. ]]
if avalet.infoBox.injectionTimerID ~= nil then
  killTimer(avalet.infoBox.injectionTimerID)
end
avalet.infoBox.injectionTimerID=nil;
raiseEvent("RenewInfoBox")
</script>
				<command></command>
				<packageName></packageName>
				<regex>^cinfo$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Ausruestung</name>
				<script>--[[
Die verschiedenen "Inventar"-Befehle. Die Inhalte der einzelnen Behälter
(Rucksack und so) wird nicht erfasst.
Der Befehl ist eigentlich ziemlich umfangreich, wie man sich mit 'hilfe
inventar' ansehen kann. Und dieses Alias geht von einer Standard-Ansicht aus.
Das kann natürlich zu Problemen führen, wenn der Spieler sich seinen eigenen
Standard definiert hat. Einfach weil die Liste dann unter Umständen sehr lang
wird und die Info-Box dafür nicht ausreicht. Aber... dann hat er halt Pech. ]]

enableTrigger("InfoBoxInjection")

send(matches[1],false)
</script>
				<command></command>
				<packageName></packageName>
				<regex>^(inventar|ausruestung|ausr|i|inv)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Gruppenübersicht</name>
				<script>--[[
Die verschiedenen Gruppen-Übersichten enthalten Informationen über die
Gruppe, in der sich der Char grade gefindet. ]]

enableTrigger("InfoBoxInjection")

send(matches[1],false)
</script>
				<command></command>
				<packageName></packageName>
				<regex>^(g(ruppe)?( (info|gesundheit|tp|einst|einstellungen|sonst|sonstiges))?)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Kampfaufbau</name>
				<script>--[[
Der Kampfaufbau zeigt verschiedene Kampfinformationen an. Und hat
die nervige Eigenschaft, im Kampfgetümmel sofort rauszuscrollen.
Außer natürlich man hat Avalet. ;) ]]

enableTrigger("InfoBoxInjection")

send(matches[1],false)
</script>
				<command></command>
				<packageName></packageName>
				<regex>^(kampfaufbau)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Runenübersicht</name>
				<script>--[[
Der Befehl 'ruebersicht' ist ein Befehl der Runenschmiede. Damit wird
denen eine komprimierte Übersicht aller getragenen Rüstungsteile und
aller geführten Waffen sowie den darauf befindlichen Runen angezeigt. ]]

enableTrigger("InfoBoxInjection")

send(matches[1],false)
</script>
				<command></command>
				<packageName></packageName>
				<regex>^(ruebersicht|rübersicht)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Spielstand</name>
				<script>--[[
Der Spielstand ist der Spielstand. Für alle die im Kampfscroll mal
gucken wollen, wie lang sie noch bis zum nächsten Level brauchen. ]]

enableTrigger("InfoBoxInjection")

send(matches[1],false)
</script>
				<command></command>
				<packageName></packageName>
				<regex>^(sp|spielstand|info)$</regex>
			</Alias>
		</AliasGroup>
		<Alias isActive="yes" isFolder="no">
			<name>Hilfetext</name>
			<script>--[[
Avalet - Nur echt mit einem endlosen Hilfetext. ]]
cecho("&lt;green&gt;"..avalet.getHelp())
</script>
			<command></command>
			<packageName></packageName>
			<regex>^avalet hilfe$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>Laufrichtung</name>
			<script>--[[
Hier wird die Laufrichtung auch dann erfasst, wenn der
Spieler tatsächlich das Laufen richtig austippt. ]]
mapCapture=nil
--cecho("&lt;magenta&gt;\n&gt;"..matches[1].."&lt;\n")

local key = 0
--local m = matches[1]

if rex.find(matches[1], '^(sw|s(ue|ü)dwest(en)?)$') then
  key = 1
elseif rex.find(matches[1], '^(s|s(ue|ü)d(en)?)$') then
  key = 2
elseif rex.find(matches[1], '^(so|s(ue|ü)dost(en)?)$') then
  key = 3
elseif rex.find(matches[1], '^(w|west(en)?)$') then
  key = 4
elseif rex.find(matches[1], '^(o|ost(en)?)$') then
  key = 6
elseif rex.find(matches[1], '^(nw|nordwest(en)?)$') then
  key = 7
elseif rex.find(matches[1], '^(n|nord(en)?)$') then
  key = 8
elseif rex.find(matches[1], '^(no|nordost(en)?)$') then
  key = 9
elseif rex.find(matches[1], '^(h|hoch)$') then
  key = 10
elseif rex.find(matches[1], '^(r|runter)$') then
  key = 11
end

--local listOfDirections = {"sw","s","so","w","sc","o","nw","n","no","h","r","rein","raus"}
--cecho("&lt;magenta&gt;richtung: "..listOfDirections[key].."\n")
raiseEvent("keyPadEvent", key)
</script>
			<command></command>
			<packageName></packageName>
			<regex>^(n|nord(en)?|s|s(ue|ü)d(en)?|o|ost(en)?|w|west(en)?|no|nordost(en)?|so|s(ue|ü)dost(en)?|sw|s(ue|ü)dwest(en)?|nw|nordwest(en)?|h|hoch|r|runter)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>schau</name>
			<script>--[[
Also hier wird die RoomID des aktuellen Raumes angefordert. Die kommt dann
als "AvalonInstance" per ATCP. Dieser Wert wird dann innerhalb von Avalet
einfach weitergereicht, und zwar an die Funktion, die auch die RoomID ver-
arbeitet, wenn die per ATCP kommt. Und DORT wird dann "RoomInv" nochmal
per ATCP angefordert. Und DAS sorgt dann dafür, dass die "RoomInv"-Anzeige
auf dem GUI aktualisiert wird. Dort steht, was sich so im Raum befindet.
Also: man selbst, Gruppenmitglieder oder allgemein andere Chars, Gegner,
Leichen, Loot, Möbel... Sinn ist, dass man sich so im Kampfgetümmel einen
Überblick über den aktuellen Stand verschaffen kann. Denn von selbst
aktualisiert sich RoomInv nicht. 
Und ich weiß nicht mehr, warum ich das so gebaut habe. Und warum ich hier
nicht einfach RoomInv anfordere. Aber ich vertrau mal darauf, dass das
irgendeinen Grund hat. Und halte mich an die alte Regel: never change a
running system.]]
sendATCP("ava_req_iid", "hier")
send(matches[1],false)
</script>
			<command></command>
			<packageName></packageName>
			<regex>^(b|betrachte|betrachten|schau)$</regex>
		</Alias>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>Hilfsfunktionen</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>PokemonTest</name>
				<script>--[[
Das hier ist eine Möglichkeit um die Febronen-Timer zu testen. Ich hab hier die 
Standardtexte sowohl für die lange als auch für die kurze Anzeige versammelt und 
spiele sie einmal durch, zusätzlich werden noch als "Ende" das normale Ende sowie 
das Einpacken eines einzelnen als auch das Einpacken aller Febronen gleichzeitig 
simuliert. Wenn das hier alles durchläuft kann es aber trotzdem sein, dann ist das 
erstmal ein gutes Zeichen. Aber da zum Beispiel durch die Benennung der Febronen 
bei anderen auch anders formatierte Texte auftreten können, kann es natürlich 
trotzdem noch zu Problemen kommen. 

Aufruf mit:
'test evo febron &lt;parameter&gt;'

Parameter können sein:
'angriff', 'defensiv', 'fuehrung', 'offensiv', 'schutz', 'stress' und 'alles'
]]


local febname = ""
local vorbereitung = ""
local langerText = ""
local kurzerText = ""
local normalesEnde = ""
local abbruchEiner = ""
local abbruchAlle = ""


local function pokemonTestStrings(welche)

  if (welche == "angriff") then
    febname = "Ahoernchen"
    vorbereitung = "Du holst Deinen Febron \""..febname.."\" aus Deinem Febronenbeutel und beginnst Dich\nzu konzentrieren."
    langerText = "Als Du Deinen Spruch zu Ende gesprochen hast, ist \""..febname.."\" vollstaendig\nevoliert und beginnt aus Deiner Hand zu schweben. \""..febname.."\" ist nun fuer den\nKampf gegen Deine Feinde geruestet und fliegt kaempferisch um Dich herum."
    kurzerText = "Als Du Deinen Spruch zu Ende gesprochen hast, ist \""..febname.."\" nun fuer den\nKampf gegen Deine Feinde geruestet."
    normalesEnde = "Dein Febron \""..febname.."\" ist vom ewigen Herumschwirren erschoepft. Er verliert\nlangsam aber sicher sein Leuchten. Er wird kleiner und rettet sich mit\nletzter Kraft in Deinen Febronenbeutel, wo er sein duesteres Leuchten\nkomplett verliert."
    abbruchEiner = "Du faengst Dein Febron \""..febname.."\" ein und legst ihn in Deinen Febronenbeutel."
    abbruchAlle = "Du faengst vorsichtig alle Deine Febrone ein und legst sie in Deinen\nFebronenbeutel."
  elseif (welche == "defensiv") then
    febname = "Bhoernchen"
    vorbereitung = "Du holst Deinen Febron \""..febname.."\" aus Deinem Febronenbeutel und beginnst Dich\nzu konzentrieren."
    langerText = "Mit einem Schlag schiesst \""..febname.."\" nach oben. Er ist nun bereit, Dich vor\nden Attacken Deiner Gegner telepathisch zu schuetzen. Kommen sie Dir zu\nnahe, wirst Du es spueren und kannst nun schnell parieren."
    kurzerText = "Mit einem Schlag schiesst \""..febname.."\" nach oben. Er wird Dich vor Schlaegen\nwarnen."
    normalesEnde = "Dein Defensivfebron \""..febname.."\" ist vom Kampf erschoepft. Er wird kleiner und\nschwirrt in Deinen Beutel zurueck."
    abbruchEiner = "Du faengst Dein Febron \""..febname.."\" ein und legst ihn in Deinen Febronenbeutel."
    abbruchAlle = "Du faengst vorsichtig alle Deine Febrone ein und legst sie in Deinen\nFebronenbeutel."
  elseif (welche == "fuehrung") then
    febname = "Choernchen"
    vorbereitung = "Du holst Deinen Febron \""..febname.."\" aus Deinem Febronenbeutel und beginnst Dich\nzu konzentrieren."
    langerText = "Mit einem Schlag schiesst \""..febname.."\" nach oben. Er ist nun bereit, andere\nFebrone so zu leiten, dass sie ihre Aufgaben besser vollziehen koennen."
    kurzerText = "Mit einem Schlag schiesst \""..febname.."\" nach oben. Er ist nun bereit, andere\nFebrone so zu leiten, dass sie ihre Aufgaben besser vollziehen koennen."
    normalesEnde = "Dein Fuehrungsfebron \""..febname.."\" ist vom Kampf erschoepft. Er wird kleiner und\nschwirrt in Deinen Beutel zurueck."
    abbruchEiner = "Du faengst Dein Febron \""..febname.."\" ein und legst ihn in Deinen Febronenbeutel."
    abbruchAlle = "Du faengst vorsichtig alle Deine Febrone ein und legst sie in Deinen\nFebronenbeutel."
  elseif (welche == "offensiv") then
    febname = "Dhoernchen"
    vorbereitung = "Du holst Deinen Febron \""..febname.."\" aus Deinem Febronenbeutel und beginnst Dich\nzu konzentrieren."
    langerText = "Mit einem Schlag schiesst \""..febname.."\" nach oben. Er ist nun bereit, Dich\ntelepathisch zu staerkeren Attacken anzufeuern. Kommen Gegner Dir zu nahe,\nwird er es spueren und Dich zu einem starken Schlag zwingen."
    kurzerText = "Mit einem Schlag schiesst \""..febname.."\" nach oben. Er wird Dich nun staerker\nzuschlagen lassen."
    normalesEnde = "Dein Offensivfebron \""..febname.."\" ist vom Kampf erschoepft. Er wird kleiner und\nschwirrt in Deinen Beutel zurueck."
    abbruchEiner = "Du faengst Dein Febron \""..febname.."\" ein und legst ihn in Deinen Febronenbeutel."
    abbruchAlle = "Du faengst vorsichtig alle Deine Febrone ein und legst sie in Deinen\nFebronenbeutel."
  elseif (welche == "schutz") then
    febname = "Ehoernchen"
    vorbereitung = "Du holst Deinen Febron \""..febname.."\" aus Deinem Febronenbeutel und beginnst Dich\nzu konzentrieren."
    langerText = "Dein Febron \""..febname.."\" fliegt um Dich herum und bildet einen schuetzenden\nSchild um Dich."
    kurzerText = "Dein Febron \""..febname.."\" fliegt um Dich herum und bildet einen schuetzenden\nSchild um Dich."
    normalesEnde = "Dein Schutzfebron \""..febname.."\" ist vom Kampf erschoepft. Er wird kleiner und\nschwirrt in Deinen Beutel zurueck."
    abbruchEiner = "Du faengst Dein Febron \""..febname.."\" ein und legst ihn in Deinen Febronenbeutel."
    abbruchAlle = "Du faengst vorsichtig alle Deine Febrone ein und legst sie in Deinen\nFebronenbeutel."
  elseif (welche == "stress") then
    febname = "Fhoernchen"
    vorbereitung = "Du holst Deinen Febron \""..febname.."\" aus Deinem Febronenbeutel und beginnst Dich\nzu konzentrieren."
    langerText = "Als Du Deinen Spruch zu Ende gesprochen hast ist \""..febname.."\" bereits vollstaendig\nevoliert. Er beginnt bereits Dich zu nerven, springt vor Deinen Augen umher\nund schlaegt Dir an Deinen Kopf. Man, das war der groesste Fehler Deines\nLebens, den zu evolieren! Du faehrst fast aus Deiner Haut, als er Dich\nkraeftig erwischt und schlaegst um Dich. GNAAAAAAaaaa, DU BIST BOESE!"
    kurzerText = "Als Du Deinen Spruch zu Ende gesprochen hast, beginnt \""..febname.."\" Dich nun\nanzutreiben."
    normalesEnde = "Dein Stressfebron \""..febname.."\" ist vom Kampf erschoepft. Er wird kleiner und\nschwirrt in Deinen Beutel zurueck."
    abbruchEiner = "Du faengst Dein Febron \""..febname.."\" ein und legst ihn in Deinen Febronenbeutel."
    abbruchAlle = "Du faengst vorsichtig alle Deine Febrone ein und legst sie in Deinen\nFebronenbeutel."
  else
    cecho("&lt;magenta&gt;\nFalscher Parameter\n")
  end


end

pokemonTestStrings(matches[2])

if ((matches[2] == "angriff") or 
    (matches[2] == "defensiv") or 
    (matches[2] == "fuehrung") or 
    (matches[2] == "offensiv") or 
    (matches[2] == "schutz") or 
    (matches[2] == "stress")) then
  cecho("&lt;magenta&gt;teste "..matches[2].."febron\n")
  
  pokemonTestStrings(matches[2])

  tempTimer(0, function() 
        msg = "Vorbereitung (nötig damit das Skript den Namen kennt)"
        cecho("&lt;magenta&gt;\nStep 1: "..msg.."\n")
        feedTriggers("\n"..vorbereitung.."\n")
      end)
  tempTimer(1, function() 
        msg = "Langer Text"
        cecho("&lt;magenta&gt;\n"..msg.."\n")
        feedTriggers("\n"..langerText.."\n") 
      end)
  tempTimer(5, function() 
        msg = "Normales Ende"
        cecho("&lt;magenta&gt;\n"..msg.."\n")
        feedTriggers("\n"..normalesEnde.."\n") 
      end)
  tempTimer(6, function() 
        msg = "Vorbereitung (nötig damit das Skript den Namen kennt)"
        cecho("&lt;magenta&gt;\nStep 2: "..msg.."\n")
        feedTriggers("\n"..vorbereitung.."\n")
      end)
  tempTimer(7, function() 
        msg = "Kurzer Text"
        cecho("&lt;magenta&gt;\n"..msg.."\n")
        feedTriggers("\n"..kurzerText.."\n") 
      end)
  tempTimer(11, function() 
        msg = "Abbruch, einzelner Febron"
        cecho("&lt;magenta&gt;\n"..msg.."\n")
        feedTriggers("\n"..abbruchEiner.."\n") 
      end)
  tempTimer(12, function() 
        msg = "Vorbereitung (nötig damit das Skript den Namen kennt)"
        cecho("&lt;magenta&gt;\nStep 3: "..msg.."\n")
        feedTriggers("\n"..vorbereitung.."\n")
      end)
  tempTimer(13, function() 
        msg = "Langer Text"
        cecho("&lt;magenta&gt;\n"..msg.."\n")
        feedTriggers("\n"..langerText.."\n") 
      end)
  tempTimer(17, function() 
        msg = "Abbruch, alle Febronen"
        cecho("&lt;magenta&gt;\n"..msg.."\n")
        feedTriggers("\n"..abbruchAlle.."\n")
        cecho("&lt;magenta&gt;ende test\n")
      end)
elseif (matches[2] == "alles") then
  cecho("&lt;magenta&gt;teste alles\n")
  
  --[[
  pokemonTestStrings("angriff")
  pokemonTestStrings("defensiv")
  pokemonTestStrings("fuehrung")
  pokemonTestStrings("offensiv")
  pokemonTestStrings("schutz")
  pokemonTestStrings("stress")
  ]]
  local i = 0
  tempTimer(i, function() 
        msg = "Vorbereitung (nötig damit das Skript den Namen kennt)"
        cecho("&lt;magenta&gt;\nStep 1: "..msg.."\n")
        pokemonTestStrings("angriff")
        feedTriggers("\n"..vorbereitung.."\n")
      end)
  i = i + 1
  tempTimer(i, function() 
        msg = "Langer Text"
        cecho("&lt;magenta&gt;\n"..msg.."\n")
        pokemonTestStrings("angriff")
        feedTriggers("\n"..langerText.."\n") 
      end)
  i = i + 24
  
  tempTimer(i, function() 
        msg = "Vorbereitung (nötig damit das Skript den Namen kennt)"
        cecho("&lt;magenta&gt;\nStep 1: "..msg.."\n")
        pokemonTestStrings("defensiv")
        feedTriggers("\n"..vorbereitung.."\n")
      end)
  i = i + 1
  tempTimer(i, function() 
        msg = "Langer Text"
        cecho("&lt;magenta&gt;\n"..msg.."\n")
        pokemonTestStrings("defensiv")
        feedTriggers("\n"..langerText.."\n") 
      end)
  i = i + 24
  
  tempTimer(i, function() 
        msg = "Vorbereitung (nötig damit das Skript den Namen kennt)"
        cecho("&lt;magenta&gt;\nStep 1: "..msg.."\n")
        pokemonTestStrings("fuehrung")
        feedTriggers("\n"..vorbereitung.."\n")
      end)
  i = i + 1
  tempTimer(i, function() 
        msg = "Langer Text"
        cecho("&lt;magenta&gt;\n"..msg.."\n")
        pokemonTestStrings("fuehrung")
        feedTriggers("\n"..langerText.."\n") 
      end)
  i = i + 24
  
  tempTimer(i, function() 
        msg = "Vorbereitung (nötig damit das Skript den Namen kennt)"
        cecho("&lt;magenta&gt;\nStep 1: "..msg.."\n")
        pokemonTestStrings("offensiv")
        feedTriggers("\n"..vorbereitung.."\n")
      end)
  i = i + 1
  tempTimer(i, function() 
        msg = "Langer Text"
        cecho("&lt;magenta&gt;\n"..msg.."\n")
        pokemonTestStrings("offensiv")
        feedTriggers("\n"..langerText.."\n") 
      end)
  i = i + 24
  
  tempTimer(i, function() 
        msg = "Vorbereitung (nötig damit das Skript den Namen kennt)"
        cecho("&lt;magenta&gt;\nStep 1: "..msg.."\n")
        pokemonTestStrings("schutz")
        feedTriggers("\n"..vorbereitung.."\n")
      end)
  i = i + 1
  tempTimer(i, function() 
        msg = "Langer Text"
        cecho("&lt;magenta&gt;\n"..msg.."\n")
        pokemonTestStrings("schutz")
        feedTriggers("\n"..langerText.."\n") 
      end)
  i = i + 24
  
  tempTimer(i, function() 
        msg = "Vorbereitung (nötig damit das Skript den Namen kennt)"
        cecho("&lt;magenta&gt;\nStep 1: "..msg.."\n")
        pokemonTestStrings("stress")
        feedTriggers("\n"..vorbereitung.."\n")
      end)
  i = i + 1
  tempTimer(i, function() 
        msg = "Langer Text"
        cecho("&lt;magenta&gt;\n"..msg.."\n")
        pokemonTestStrings("stress")
        feedTriggers("\n"..langerText.."\n") 
      end)
  i = i + 24
  
  tempTimer(i, function() 
        msg = "Normales Ende"
        cecho("&lt;magenta&gt;\n"..msg.."\n")
        pokemonTestStrings("schutz")
        cecho("&lt;magenta&gt;\nBeende Schutz-Febron")
        feedTriggers("\n"..normalesEnde.."\n") 
      end)
  i = i + 24

  tempTimer(i, function() 
        msg = "Abbruch, einzelner Febron"
        cecho("&lt;magenta&gt;\n"..msg.."\n")
        pokemonTestStrings("defensiv")
        cecho("&lt;magenta&gt;\nBeende Defensiv-Febron")
        feedTriggers("\n"..abbruchEiner.."\n") 
      end)
  i = i + 24

  tempTimer(i, function() 
        msg = "Abbruch, alle Febronen"
        cecho("&lt;magenta&gt;\n"..msg.."\n")
        pokemonTestStrings("schutz")
        cecho("&lt;magenta&gt;\nBeende alle Febronen")
        feedTriggers("\n"..abbruchAlle.."\n")
        cecho("&lt;magenta&gt;ende test alle\n")
      end)

--[=[

  tempTimer(i, function() 
        msg = "Vorbereitung (nötig damit das Skript den Namen kennt)"
        cecho("&lt;magenta&gt;\nStep 2: "..msg)
        feedTriggers("\n"..vorbereitung.."\n")
      end)
  i = i + 1
  tempTimer(i, function() 
        msg = "Kurzer Text"
        cecho("&lt;magenta&gt;\n"..msg)
        feedTriggers("\n"..kurzerText.."\n") 
      end)
  i = i + 4
  tempTimer(i, function() 
        msg = "Abbruch, einzelner Febron"
        cecho("&lt;magenta&gt;\n"..msg)
        feedTriggers("\n"..abbruchEiner.."\n") 
      end)
  i = i + 1
  tempTimer(i, function() 
        msg = "Vorbereitung (nötig damit das Skript den Namen kennt)"
        cecho("&lt;magenta&gt;\nStep 3: "..msg)
        feedTriggers("\n"..vorbereitung.."\n")
      end)
  i = i + 1
  tempTimer(i, function() 
        msg = "Langer Text"
        cecho("&lt;magenta&gt;\n"..msg)
        feedTriggers("\n"..langerText.."\n") 
      end)
  i = i + 4
  tempTimer(i, function() 
        msg = "Abbruch, alle Febronen"
        cecho("&lt;magenta&gt;\n"..msg)
        feedTriggers("\n"..abbruchAlle.."\n")
        cecho("&lt;magenta&gt;ende test angriffsfebron\n")
      end)
    ]=]
      
else
  cecho("&lt;magenta&gt;\nFalscher Befehl?!\n")
end

--[=[
tempTimer(1, [[ send("sag huhu") ]])
tempTimer(3, [[ send("sag 3 sekunden später") ]])


lua feedTriggers("\nDu holst Deinen Febron \"Tirfea\" aus Deinem Febronenbeutel und beginnst Dich\nzu konzentrieren.\n")

lua feedTriggers("\nMit einem Schlag schiesst \"Tirfea\" nach oben. Er ist nun bereit, Dich vor\nden Attacken Deiner Gegner telepathisch zu schuetzen. Kommen sie Dir zu\nnahe, wirst Du es spueren und kannst nun schnell parieren.\n")
lua feedTriggers("\nMit einem Schlag schiesst \"Tirfea\" nach oben. Er wird Dich vor Schlaegen\nwarnen.\n")

lua feedTriggers("\nDu faengst Dein Febron \"Tirfea\" ein und legst ihn in Deinen Febronenbeutel.\n")
lua feedTriggers("\nDein Defensivfebron \"Tirfea\" ist vom Kampf erschoepft. Er wird kleiner und\nschwirrt in Deinen Beutel zurueck.\n")
lua feedTriggers("\nDu faengst vorsichtig alle Deine Febrone ein und legst sie in Deinen\nFebronenbeutel.\n")
]=]</script>
				<command></command>
				<packageName></packageName>
				<regex>^test evo febron (\S*)$</regex>
			</Alias>
		</AliasGroup>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<Script isActive="yes" isFolder="no">
			<name>README</name>
			<packageName></packageName>
			<script>--[[

README

Avalet funktioniert im Wesentlichen über Events. Per ATCP eintreffende Daten
lösen jeweils einen Event aus, für den sich dann Funktionen registrieren können.
Diese Funktionen werden durch den Event dann aufgerufen. Und auch der von mir
programmierte Teil funktioniert so: Kommt der Char-Name ("vollername" in diesem
Fall) per ATCP, dann löst das einen Event aus. Die so aufgerufene Funktion trägt
den Namen mit der "setVollerName"-Funktion am Char-Objekt ein, die dabei einen
Event auslöst. Für diesen Event ist das Model-Objekt registriert, das die ent-
sprechenden Daten (also "vollername") anzeigt. Der Event sorgt also dafür, dass
das Model-Objekt seine Daten neu berechnet und den frisch eingetroffenen Namen
dabei berücksichtigt. Anschließend löst dieses Model-Objekt einen Event aus, für
den das dazugehörige View-Objekt registriert ist. Das wird dadurch veranlasst,
die Anzeige im GUI neu zu schreiben. So gelangt der neue "vollername" bis zur
Oberfläche.

(Jedenfalls ist das die Theorie. In der Praxis hat Avalet verschieden alte Teile,
und grad am Anfang hab ich häufig mit normalen Funktionsaufrufen gearbeitet statt
mit dem Event-System. Aber das wirst Du schon sehen.)

Außerdem gibt es Standard-Events, die Mudlet selber auslöst. Die Behandlung dieser
Events in Avalet findet sich im Abschnitt "Avalet --&gt; Events". Die Namen sind
eigentlich Selbsterklärend - es gibt ein Event beim Installieren des Moduls Avalet.
(Also immer beim Neustart von einem Mudlet-Profil, das Avalet installiert hat.)
Es gibt einen Event beim Connect (zum MUD). Einen Event beim Disconnect... Usw.
Innerhalb dieser Events wird Avalet initialisiert bzw. sinnvoll beendet. Ein 
guter Startpunkt, um sich Avalet zu erschließen, wäre vielleicht "onSysInstall".

Profil und Charakter (und ein paar andere Sachen) als Objekt auszulegen, also mit 
privaten Variablen und öffentlichen und privaten (und statischen) Funktionen, war 
eine dämliche Idee. Ich hab nur Probleme gehabt damit. Allerdings ist es von der 
Logik her nunmal sinnvoll, die Daten zentral zu sammeln und dort auch alles weitere 
zu veranlassen. Also Änderungs-Events auszulösen zum Beispiel. Und ich weiß auch
nicht, ob ich nicht einfach zu blöd war. Aber jedenfalls funktionieren deshalb
Funktionsaufrufe wie 'avalet.char:setName("Charname")' nicht - da kommt bei
der Funktion das Char-Objekt als Parameter an (statt des Strings "Charname").
Der weniger gut lesbare Funktionsaufruf mit Punkt statt Doppelpunkt funktioniert.
Also 'avalet.char.setName("Charname")'

Die einzelnen Teile von Avalet, die auf der Oberfläche zu sehen sind, werden dann
im Bereich "Model" und im Bereich "View" angelegt. Und dort finden sich dann auch 
die Funktionen, die konkret im Zusammenhang mit den einzelnen Bestandteilen von 
Avalet stehen.
Die Trennung in "Model" und "View" (eigentlich in Model-View-Control, kurz MVC)
ist ein übliches "Design Pattern" in der Programmierung. Nach diesem Pattern wird
der Code aufgetrennt. Und zwar einmal in alles, was mit der eigentlichen Oberfläche 
zu tun hat. Also das, was man konkret als "Grafical User Interface" sehen kann: 
die Oberflächenelemente, Dialogfenster, Menüs, Buttons, ... usw. Das ist die "View".
Und auf der anderen Seite hat man dann die Daten, die auf der Oberfläche angezeigt 
werden sollen. Die Objekte, Variablen, etc. Und natürlich auch die Logik, also die 
Möglichhkeiten, diese Daten zu manipulieren. Das ist das "Model" bzw. "Control". 
Diese Aufteilung macht Sinn, weil "MC" und "V" schon sehr unterschiedlich sind und 
man meist auch nur an einem von beidem gleichzeitig arbeiten will. Naja, und wenn ich 
unter diesen zig Fenster-Elementen, aus denen Avalet besteht, das suchen muss, was 
ich nun grade bearbeiten will, dann ist es schon hilfreich, wenn ich nicht auch noch 
durch das ganze Model scrollen muss dabei. Viel übersichtlicher. Und damit auch viel 
weniger fehleranfällig.

Manche Daten werden auch NICHT im Model verarbeitet. Jedenfalls nicht in dem Model,
das zur View passt. EP beispielsweise kommen auch per ATCP, und werden dann ins 
Char-Objekt geschrieben. Das ist ein "Character-Model", aber das wird nicht in Reinform
auf der Oberfläche angezeigt. Stattdessen gibt es verschiedene Teile der Oberfläche,
die verschiedene Daten aus dem Character-Model anzeigen. Bei diesem Beispiel, wo sich
die EP des Characters ändern, würden also die neuen EP ins Character-Model geschrieben
werden. Anschließend würde die Funktion am "CharInfoModel" (wo die EP angezeigt werden)
aufgerufen werden, die die Daten für die Anzeige zusammenstellt. Und dann gäbe es 
wiederrum so einen Event, in diesem Fall dann vielleicht einen "CharInfo has changed"-
Event. Wodurch die View der entsprechenden Stelle angeregt wird, sich zu aktualisieren.

Lua-Skripte (oder Mudlet-Module, keine Ahnung) werden beim Start einmal komplett einge-
lesen. Bei dieser Gelegenheit werden alle Funktionen angelegt. Und alles, was nicht in 
einer Funktion steht, wird ausgeführt. Es werden also beispielsweise globale Variablen 
angelegt. Aber auch Code würde ausgeführt werden, wenn er nicht in einer Funktion ge-
kapselt ist. Ein Funktionsaufruf außerhalb einer Funktion würde also beispielsweise 
ausgeführt werden. Allerdings nur, wenn diese Funktion VOR dem Funktionsaufruf steht. 
Denn nur dann existiert sie schon zu diesem Zeitpunkt. Ich schreibe das so ausführlich,
weil es mir und anderen immer mal wieder Probleme bereitet hat. Mein Vorschlag wäre, auf 
Funktionsaufrufe außerhalb von Funktionen zu verzichten.
 
Und dieses "alles erstmal einlesen und abarbeiten" passiert auch jedesmal, wenn man was
am Code ändert und dann das Profil speichert. Deshalb macht es Sinn, Variablen sich selbst
zuzuordnen. (Im Sinne von: 'varName = varName or {}'.) Dadurch bleibt der Wert erhalten,
wenn man was am Code ändert und das Profil speichert.

Für potentielle Entwickler:
---------------------------

Wenn du selber was an Avalet ändern möchtest, dann musst du vorher die Installation
verändern. Tust du das nicht, dann überschreibt sich Avalet mit sich selbst beim
nächsten Neustart, und deine Änderungen sind weg. Damit das nicht passiert, gehst du
wie folgt vor:
- Entpacke das Archiv von Avalet, also die .mpackage bzw die .zip-Datei. Abgesehen vom
  Namen sind beide identisch, du kannst also die .mpackage-Datei einfach wie eine
  ZIP-Datei entpacken. Oder lade dir das Projekt von Github runter.
- DEinstalliere Avalet, falls du es auf die herkömmliche Art installiert hast. Starte
  dann vorsichtshalber Mudlet neu.
- INstalliere Avalet neu. Aber diesmal NICHT die .mpackage bzw. die .zip-Datei, sondern
  die grade eben entpackte Datei 'Avalet.xml'.
- Achte darauf, dass im Modul-Manager das Sync-Häkchen gesetzt ist.
Jetzt sollten deine Änderungen erhalten bleiben. ]]
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>init</name>
			<packageName></packageName>
			<script>--[[
init

Alles was besonders früh angelegt werden muss ist hier gut aufgehoben. ]] 

----------------------------------------------------------------------------
-- Globale Variablen
----------------------------------------------------------------------------

-- Namespaces für Avalet
avalet = avalet or {}

--[[
Die Oberfläche bekommt einen eigenen Namespace, einfach um die Trennung von
Model und View auch hier umzusetzen. ]]
avaletUI = avaletUI or {}

avalet.MODULE_NAME = "Avalet"
avalet.VERSION_NR = nil
avalet.VERSION_DATE = nil

--[[
Ich habe einen "DEBUG-Modus" gebraucht, durch den ich Code nur dann ausführen
kann, wenn ich an Avalet arbeite. Damit ich nicht immer ein- und auskommentieren
muss. (Und damit ich vor allem nicht mehr immer wieder vergesse, das vor dem 
Release wieder auszuschalten.)
Dieser Debug-Modus kann hier ganz generell eingeschaltet werden, dann ist er sehr
früh aktiv. Also schon während der Installation des Moduls. Einfach die Variable 
auf 'true' setzten und das Profil neu starten.
Und ab sofort gibt es noch die Moeglichkeit, eine Datei mit dem Namen "debug" oder
"debug.txt" in das Verzeichnis zu legen, wo das Modul Avalet liegt. Also in das 
Verzeichnis, wo entweder die Datei "avalet.mpackage" oder "avalet.zip" liegt. 
Oder in das Verzeichnis, wo die Datei "avalet.xml" liegt, wenn es eine Entwickler-
Installation ist. Ist so eine Datei vorhanden, dann werden Debug-Ausgaben hier 
auch schon aktiviert, so dass auch die Installation des Moduls in Mudlet schon 
von Log-Ausgaben begleitet wird.
Eine aeltere Loesung erhalte ich aus Gruenden der Abwaertskompatibilitaet:
Der Debug-Modus kann aber auch durch den Profil-Namen gesteuert werden. Ich habe 
Entwicklungs-Profile in Mudlet angelegt, deren Namen mit einem "- DEV" enden. Wenn 
das Profil geladen ist, wird der "SysLoadEvent" ausgelöst, und in der Funktion 
"onSysLoadEvent" wird dann die Variable avalet.debug auf "true" gesetzt. Wenn 
diese Variable hier auf "false" gesetzt ist, das Profil aber ein Entwicklungsprofil 
ist, wird der Debug-Modus also dort dann aktiviert. Damit gibt es dann KEINE 
Debug-Ausgaben, bis der "SysLoadEvent" feuert. Und ab dann schon.
Man kann das auch auf der Eingabezeile von Mudlet erledigen. Mit 
"lua avalet.debug=true" schaltet man den Debug-Modus ein. ]]
avalet.DEBUG_PATTERN = ".- DEV"
avalet.debug = avalet.debug or false

--[[
Schaut ob eine Datei namens "debug" oder "debug.txt" im gleichen 
Verzeichnis wie die Installationsdatei liegt. Wird weiter unten 
verwendet.
Diese 3zeilige sting.gsub-Sache funktioniert so: Wenn der gesuchte 
Modul-Name im Modul-Pfad steht, dann wird der Pfad OHNE Modul am Ende 
zurückgegeben. Also der Pfad in das Verzeichnis, wo das installierte 
Modul liegt. Wird der Modul-Name nicht gefunden, dann gibt die Funktion 
den ganzen zu durchsuchenden String zurück. In irgendeiner der drei 
Zeilen wird also auf jeden Fall der richtige Pfad ermittelt, die anderen 
beiden Zeilen geben den einfach unverändert zurück. 
Am Ende wird dann geschaut, ob in diesem Verzeichnis eine Datei mit dem 
Namen "debug(.txt)" liegt.]]
local function debugMode()
  local modulePath = getModulePath(avalet.MODULE_NAME)
  modulePath = string.gsub(modulePath, avalet.MODULE_NAME..".xml", "")
  modulePath = string.gsub(modulePath, avalet.MODULE_NAME..".mpackage", "")
  modulePath = string.gsub(modulePath, avalet.MODULE_NAME..".zip", "")
  if (io.exists(modulePath.."debug") or io.exists(modulePath.."debug.txt")) then
    return true
  else
    return false
  end
end

if debugMode() then 
  avalet.debug = true 
end

--[[
Ich hab gelegentlich mal ein neues Release von Avalet veroeffentlicht, bei dem 
der Debug-Mode aktiv war. Deshalb hab ich mir hier eine Erinnerung eingebaut. 
Spaeter kam dann das Avalet-Logging dazu, durch den man das jetzt auch an 
unzaehligen Logging-Ausgaben erkennen kann. 
Aber was solls, doppelt haelt besser.]]
if avalet.debug then
  -- Die avalet.log()-Funktion existiert hier noch nicht beim Systemstart. Deshalb von Hand.
  cecho("&lt;black:magenta&gt;                                                                               \n")
  cecho("&lt;black:magenta&gt; DEBUG MODE von Avalet ist aktiviert!                                          \n")
  cecho("&lt;black:magenta&gt;                                                                               \n")
end

--[[
Der eingestellte 'loglevel' bestimmt, wie viele Logging-Ausgaben man zu 
sehen bekommt. Dokumentiert ist das unter '/Misc/avalet.log'.
Konfigurieren kann man das hier. Oder über die Eingabezeile von Mudlet.
Mit z.B. "lua avalet.loglevel=2" legt man die Schwelle, ab der Logausgaben 
angezeigt werden, auf INFO. Dann erspart man sich die ganzen DEBUG-Ausgaben. 
loglevel=0 zeigt alles. ]]
avalet.loglevel = avalet.loglevel or 0

-- Objekt-Variable
avalet.profile = avalet.profile or {}
avalet.char = avalet.char or {}
avalet.fight = avalet.fight or {}
avalet.mapper = avalet.mapper or {}

--[[
Speicherort des Moduls. Zeigt auf den Speicherort des Downloads, also auf 'Avalet.mpackage'
oder auf 'Avalet.zip'.
Bei einer Entwickler-Installation allerdings zeigt dieser Pfad auf die Entwicklungsversion,
also auf 'Avalet.xml'. Bei so einer Entwicklungsinstallation wird Avalet auch nicht richtig
installiert, es werden also auch die Ressourcen-Dateien (Bilder, 'version.txt') nicht an den
gewohnten Ort kopiert. Deshalb sucht Avalet in so einem Fall auch gleich im Entwicklungs-
verzeichnis, nicht im homedir einer normalen Avalet-Installation. (Das kommt weiter unten.)
Wird unter Windows beispielsweise zu
C:/Users/&lt;usrdir&gt;/Downloads/Avalet/Avalet.mpackage (oder eben das Download-Verzeichnis)
oder
C:/Users/&lt;usrdir&gt;/Documents/Avalet/Avalet/Avalet.xml (Entwicklungs-Verzeichnis) ]]
avalet.MODULE_PATH = getModulePath(avalet.MODULE_NAME)

--[[
Speicherort des geladenen Profils. Wird unter Windows zu:
C:/Users/&lt;usrdir&gt;/.config/mudlet/profiles/&lt;Profilname&gt; ]]
avalet.MUDLET_HOME_DIR = getMudletHomeDir()

--[[
Wenn Avalet aus einer .xml-Datei installiert wurde, dann handelt es sich vermutlich um
eine Entwicklungsinstallation. In diesem Fall kommen die Ressourcen (Bilder z.B.) eben-
falls aus dem Entwicklungsverzeichnis. Und nicht aus dem MODULE_HOME_DIR, wie sonst. ]]
local pattern = avalet.MODULE_NAME..".xml"
if string.find(avalet.MODULE_PATH, pattern) ~= nil then
  cecho("&lt;yellow&gt;[AVALET]  - Entwicklungsinstallation\n")
  avalet.MODULE_HOME_DIR = string.gsub(avalet.MODULE_PATH, pattern, "")
else
  -- C:/Users/&lt;usrdir&gt;/.config/mudlet/profiles/&lt;Profilname&gt;/&lt;Modulname&gt;/
  avalet.MODULE_HOME_DIR = avalet.MUDLET_HOME_DIR.."/"..avalet.MODULE_NAME.."/"
end

--[[
Bei einer Standard-Installation:
C:/Users/&lt;usrdir&gt;/.config/mudlet/profiles/&lt;Profilname&gt;/&lt;Modulname&gt;/imgs/ 
sonst eben das entsprechende Unterverzeichnis im Entwicklungsverzeichnis. ]]
avalet.IMAGE_FOLDER_PATH = avalet.MODULE_HOME_DIR.."imgs/"
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>Help</name>
			<packageName></packageName>
			<script>--[[
Gibt den Hilfetext zurück ]]
function avalet.getHelp()

  local hilfe = "\n"
  hilfe = hilfe .. " _____________________________________________________________________________\n" 
  hilfe = hilfe .. "/                                                                           / \\\n"
  hilfe = hilfe .. "|                               Avalet Hilfe                                | |\n"
  hilfe = hilfe .. "\\___________________________________________________________________________\\_/\n"
  hilfe = hilfe .. " |                                                                          |\n"
  hilfe = hilfe .. " | Avalet ist ein Mudlet-Plugin für das MUD Avalon. Das Ziel von Avalet     |\n"
  hilfe = hilfe .. " | ist, etwas mehr Komfort ins Spiel zu bringen. Avalet ist ein Spieler-    |\n"
  hilfe = hilfe .. " | projekt und kein offizieller Bestandteil von Avalon. Folglich sind auch  |\n"
  hilfe = hilfe .. " | nicht 'die Adeligen' schuld, wenn hier was nicht funktioniert...         |\n"
  hilfe = hilfe .. " |                                                                          |\n"
  hilfe = hilfe .. " | Die meisten Funktionen von Avalet sind offensichtlich und brauchen wohl  |\n"
  hilfe = hilfe .. " | keine Erklaerung. Aber auf ein paar Features moechte ich doch hinweisen: |\n"
  hilfe = hilfe .. " |                                                                          |\n"
  hilfe = hilfe .. " | Avalet belegt den Ziffernblock einer Tastatur mit Funktionen. Und zwar   |\n"
  hilfe = hilfe .. " | zunaechst mal mit Lauffunktionen: durch das Druecken der 'Richtungs-     |\n"
  hilfe = hilfe .. " | tasten' rund um den Mittelpunkt '5' laeuft der Charakter in die ent-     |\n"
  hilfe = hilfe .. " | sprechende Richtung. Dazu kommen das '-' fuer 'hoch' und das '+' fuer    |\n"
  hilfe = hilfe .. " | 'runter'. Die Taste '5' ist mit dem Befehl 'schau' belegt, hat aber noch |\n"
  hilfe = hilfe .. " | zwei Nebenfunktionen: einmal wird die Standard-Anzeige des Info-Bereichs |\n"
  hilfe = hilfe .. " | wieder hergestellt. Und dann wird die Anzeige unterhalb der Karte aktu-  |\n"
  hilfe = hilfe .. " | alisiert. Also die Anzeige von dem, was sich im Raum befindet. Das ist   |\n"
  hilfe = hilfe .. " | nützlich im Kampf, wenn man wissen will, welche Gruppenmitglieder grad   |\n"
  hilfe = hilfe .. " | anwesend sind, welche Gegner sich schon in Leichen verwandelt haben oder |\n"
  hilfe = hilfe .. " | was sonst noch so rumliegt (an Loot beispielsweise). Und die Taste '0'   |\n"
  hilfe = hilfe .. " | ist mit dem Befehl 'blicke gegner' belegt.                               |\n"
  hilfe = hilfe .. " | Wenn der Charakter klettern oder schwimmen muss, geschieht das automa-   |\n"
  hilfe = hilfe .. " | tisch beim Druecken einer Richtungstaste. Dabei solltest du aber etwas   |\n"
  hilfe = hilfe .. " | Geschwindigkeit rausnehmen, sonst wird der Character vermutlich verun-   |\n"
  hilfe = hilfe .. " | gluecken. Wenn sich ein Fernrohr im Inventar befindet, kannst du durch   |\n"
  hilfe = hilfe .. " | druecken einer Richtungstaste zusammen mit der STRG-Taste den Char in    |\n"
  hilfe = hilfe .. " | die entsprechende Richtung 'spaehen' lassen.                             |\n"
  hilfe = hilfe .. " |                                                                          |\n"
  hilfe = hilfe .. " | Bei den Zaehlern interessiert dich vielleicht, dass der Zaehler fuer die |\n"
  hilfe = hilfe .. " | Bonussstunden-EP NUR die EP zaehlt, die du fuer Kaempfe bekommst. Die    |\n"
  hilfe = hilfe .. " | anderen EP-Zaehler zaehlen dagegen alle EP, die im gemessenen Zeitraum   |\n"
  hilfe = hilfe .. " | anfallen. Wenn du also in der Bonusstunde einen Schild und danach noch   |\n"
  hilfe = hilfe .. " | Licht zauberst, dann erhoeht der Lichtzauber die Gesamt-EP, die Session- |\n"
  hilfe = hilfe .. " | EP und die Schild-EP um jeweils 10 EP - die Bonusstunden-EP aber nicht.  |\n"
  hilfe = hilfe .. " | Der Kampfdauer-Zaehler ist nicht so trivial zu bauen, wie man vielleicht |\n"
  hilfe = hilfe .. " | meinen koennte. Sollte er gelegentlich nicht wie erwartet funktionieren, |\n"
  hilfe = hilfe .. " | dann liegt das da dran. Speziell bei Angriffen nur mit Zaubern wird es   |\n"
  hilfe = hilfe .. " | schwierig. Erstrecht, wenn Gegenangriff ausgeschaltet ist. Aber unter    |\n"
  hilfe = hilfe .. " | den allermeisten Umstaenden sollte er zuverlaessig funktionieren.        |\n"
  hilfe = hilfe .. " |                                                                          |\n"
  hilfe = hilfe .. " | Bei den Kommunikations-Tabs findet sich ein Sammel-Tab, auf dem der      |\n"
  hilfe = hilfe .. " | Inhalt mehrerer Kanaele angezeigt werden kann. Du kannst dir die Tabs    |\n"
  hilfe = hilfe .. " | in deren Kontextmenue (rechte Maustaste) konfigurieren.                  |\n"
  hilfe = hilfe .. " |                                                                          |\n"
  hilfe = hilfe .. " | Fuer Runenschmiede gibt es eine Anzeige von beschaedigter Ausruestung    |\n"
  hilfe = hilfe .. " | und beschaedigten Runen. Diese Anzeige reagiert auf 'ruebersicht' und    |\n"
  hilfe = hilfe .. " | wird aber nur sichtbar, wenn es auch etwas anzuzeigen gibt. Also etwas   |\n"
  hilfe = hilfe .. " | beschaedigtes. Bitte beachte, dass diese Anzeige sich nicht von selbst   |\n"
  hilfe = hilfe .. " | aktualisiert! Lediglich am Ende eines Kampfes sendet Avalon einmal von   |\n"
  hilfe = hilfe .. " | selbst aktuelle Daten. Davon abgesehen musst du das selbst erledigen,    |\n"
  hilfe = hilfe .. " | indem du 'ruebersicht' eingibst. (Und die normale Ausgabe von diesem     |\n"
  hilfe = hilfe .. " | Befehl wird auch ausgeleitet, wie 'sp(ielstand)', 'i(nventar)' und       |\n"
  hilfe = hilfe .. " | anderes.)                                                                |\n"
  hilfe = hilfe .. " |                                                                          |\n"
  hilfe = hilfe .. " | Der schmale Fortschrittsbalken oberhalb der Anzeige von TP, ZP und AP    |\n"
  hilfe = hilfe .. " | soll den 'Tick' anzeigen. Das ist der regelmaeßige TP-, ZP und AP-Schub, |\n"
  hilfe = hilfe .. " | der etwa alle 40 Sekunden kommt. Dieses Feature ist noch eher experimen- |\n"
  hilfe = hilfe .. " | tell und liegt selbst unter guenstigen Umstaenden nur bei einer Genauig- |\n"
  hilfe = hilfe .. " | keit von +/- einer Sekunde. Plus Lag.                                    |\n"
  hilfe = hilfe .. " |                                                                          |\n"
  hilfe = hilfe .. " | Das Flaschen-Symbol oberhalb der Anzeige von Hunger, Durst und Alkohol   |\n"
  hilfe = hilfe .. " | soll anzeigen, wenn der Char vergiftet, krank oder verflucht ist. Auch   |\n"
  hilfe = hilfe .. " | dieses Feature funktioniert noch nicht zuverlaessig. Da naemlich jeder   |\n"
  hilfe = hilfe .. " | Einzelfall in die entsprechenden Trigger eingebaut werden muss.          |\n"
  hilfe = hilfe .. " | Wenn sich das Symbol mal nicht richtig zurueck setzt, dann kannst du ihm |\n"
  hilfe = hilfe .. " | mit einem Doppelklick dabei helfen. Und wenn du mal einen Fall hast, in  |\n"
  hilfe = hilfe .. " | der die Anzeige noch nicht funktioniert, dann wuerde ich mich ueber ei-  |\n"
  hilfe = hilfe .. " | nen Hinweis freuen.                                                      |\n"
  hilfe = hilfe .. " |                                                                          |\n"
  hilfe = hilfe .. " | Genauso freue ich mich auch ueber jeden anderen Hinweis, der mir hilft,  |\n"
  hilfe = hilfe .. " | Avalet zu verbessern. Gerne per Mudmail an Rofhessa bitte.               |_\n"
  hilfe = hilfe .. " |                                                                          | |\n"
  hilfe = hilfe .. " \\__________________________________________________________________________\\_/\n"
  hilfe = hilfe .. "\n"  
  
  return hilfe

end



</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>settings</name>
			<packageName></packageName>
			<script>--[[
Eigentlich sollten die User auch was einstellen können in Avalet. Also
selber konfigurieren können. Aber bisher ist mir noch nichts eingefallen,
bei dem die Vorgaben derart unzumutbar wären, dass ich mir die Mühe
machen müsste. Also hab ich das nie ausgearbeitet. TODO ]]</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>objProfile</name>
			<packageName></packageName>
			<script>--[[
Hier sind alle Profil-bezogenen Funktionen versammelt.

Im Unterschied zum Charakter kann das Profil sofort beim Start von Avalet geladen
werden, die hier gespeicherten Daten stehen also (fast) von Anfang an zur Verfügung.
Dieses Objekt wäre also der richtige Platz, um beispielsweise Einstellungen zu
speichern, die unabhängig vom gespielten Char sind.

Genau wie der Charakter ist das Profil als Objekt ausgelegt. Also mit der Möglichkeit, 
öffentliche und private Attribute und Funktionen zu haben. Und statische Funktionen. 
Und getter und setter. ]]
local objProfile = {}

objProfile.new = function()

  local self = {}
  
  --[[
  Rückgabewert dieser inneren Funktion ist der Pfad zu der Datei, in der profilbezogene
  Daten gespeichert werden. ]]
  local getProfileFilePath = function()
    --[[
    Der Separator in aktuellen System-Pfaden wird ermittelt und gespeichert.
    Notwendig weil unterschiedliche Betriebssysteme unterschiedliche Separatoren verwenden. ]]
    local separator = ""  
    if string.char(getMudletHomeDir():byte()) == "/" then separator = "/" else  separator = "\\" end
    
    -- In dieser Datei wird das Profil gespeichert
    local profilePath = getMudletHomeDir() .. separator .. "AvaletProfileSettings.json"
    
    --[[
    Das hier ist der Versuch, ein Problem mit Leerzeichen im Pfad unter Linux zu lösen.
    Indem das Leerzeichen mit einem "\" maskiert wird. Alternativ müsste man das mit 
    Anführungszeichen um den Pfad rum lösen. ]]
    if separator == "/" then string.gsub(profilePath, " ", "\ ") end
    
    return profilePath 
  end

  local profileFilePath = getProfileFilePath()
  
  local collectionTabLabel = avalet.CONSTS.SUMMING_TAB_NAME  -- "Sammeltab"
  -- achtung, die keys müssen mit der liste unten übereinstimmen!
  local collectionTabList = {"Reden", "Sagen", "Gruppe"}
  local listOfChatTabs = {
    [1] = collectionTabLabel,
    [2] = "Reden", 
    [3] = "Sagen", 
    [4] = "Laber", 
    [5] = "Neuling", 
    [6] = "Gruppe", 
    [7] = "Volk", 
    [8] = "Gilde", 
    [9] = "Schwafel"
  }
  
  function self.changeTabContext(index, newContext) listOfChatTabs[tonumber(index)] = newContext end
  --function self.setCollectionTab(str) collectionTab = str end
  --function self.getCollectionTab() return ollectionTab end
  --function self.setCollectionList(lst) collectionList = lst end
  function self.getCollectionList() return collectionTabList end
  --function self.setChatTabsList(lst) listOfChatTabs = lst end
  function self.getChatTabsList() return listOfChatTabs end
 
  -- Hier werden die Daten dieses Objektes auf Festplatte geschrieben.
  function self.dumpProfile()
    -- Hier wird noch eine Kopie angelegt, damit Variablen aufgelöst werden.
    -- (Z.B. "data.collectionTab" in "data.newChatTabsList") 
    local data = {}
    
    data.collectionTabList = collectionTabList
    data.listOfChatTabs = listOfChatTabs

    avalet.writeDataToFS(profileFilePath, data, "w") 
  end
  
  -- Hier werde vorher gespeicherte Daten wieder eingelesen
  function self.restoreProfile()
    avalet.log("Function avalet.profile.restoreProfile()", 1)
  
    --[[
    Wenn eine Profil-Datei existiert, wird sie geladen. Existiert keine solche
    Datei, dann ist das Profil wohl neu. Dann wird die Datei angelegt, wenn 
    Mudlet das Profil schließt. ]]
	  if io.exists(profileFilePath) then
      -- Daten laden
      local data = avalet.readFileFromFS(profileFilePath, "r")
      -- Geladene Daten mit dem Profil-Objekt mergen
      
      if data.collectionTabList ~= nil then
        collectionTabList = data.collectionTabList
      end
      if data.listOfChatTabs ~= nil then
        listOfChatTabs = data.listOfChatTabs 
        -- Der Sammeltab wird wieder hergestellt (nur zur Sicherheit)
        listOfChatTabs[1] = avalet.CONSTS.SUMMING_TAB_NAME
      end
  	end
  end
  
  return self      

end --objProfile.new = function()

--[[
Hier wird das Profil-Objekt initialisiert. Aufruf in Events --&gt; onSysInstall ]]
function avalet.initProfile()
  avalet.log("Function avalet.initProfile()", 1)

  -- Profile-Objekt erzeugen
  local profile = objProfile.new()
  
  -- Gespeichertes Profil laden
  profile.restoreProfile()
  
  return profile

end
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>objCharacter</name>
			<packageName></packageName>
			<script>--[[
Das Charakter-Objekt
Ich habe die Repräsentation des Charakters als Objekt ausgeführt. Das heißt,
ich habe die Variablen hier gegen den direkten Zugriff geschützt und dafür
getter und setter eingebaut. In den allermeisten Fällen ist das sicherlich
nicht notwendig. Aber in ein paar Fällen dann eben doch. Weil beim ändernden
Zugriff auf den Charakter dann eben auch manchmal noch was anderes geschehen
soll.

Der Code für das Charakter-Objekt steht weiter unten, vorher kommen die Objekt-
bezogenen Funktionen. ]]
local objCharacter = {}

--[[
Hier beginnt das eigentliche Character-Objekt.
Das ist hier sicherlich noch nicht optimal. Ursprünglich hab ich hier alles behandelt,
was per ATCP kommt. Das hatte sich so entwickelt. Mittlerweile hab ich wenigstens den
Kampf ausgelagert (nach objFight). Das hat hier schonmal ein paar hundert Zeilen Code
gespart. Noch auslagerungsfähig wäre alles, was sich mit dem Raum/der Map beschäftig.
Und möglicherweise die Inventar-Verwaltung. Beides ist allerdings noch nicht realisiert,
und deshalb halt auch noch nicht ausgelagert. TODO bzw. work in progress. Bis zur
Realisierung ist es hier halt ein bisschen unübersichtlich. ]]
objCharacter.new = function()

  local self = {}

  local characterFilePath = ""--getCharacterFilePath()
  
  --[[ 
  Hier werden die Inhalte der Kommunikationstabs gespeichert. Bei einem
  "reconnect" (nach Statue oder so) bleiben die Puffer erhalten, bei einem
  regulären Logout werden sie gelöscht. Servicefunktionen dazu ganz unten
  in dieser Objekt-Definition Schrägstrich Funktion. ]]
  local chatsBuffer = {}
   
  local name = ""           -- ATCP: AvalonName
  local vollername = ""     -- ATCP: AvalonVollName
  local nation = ""         -- wird zwar nicht direkt per atcp übertragen, lässt sich aber aus den kanälen ermitteln
  local alter = ""          -- ATCP: AvalonAlter
  local gilde = ""          -- ATCP: AvalonGilde
  local gildenInfo = ""     -- ATCP: AvalonGildenInfo (enthält die Daten von ruebersicht
  local zuenfte = ""        -- ATCP: AvalonZuenfte
  local ep = 0              -- ATCP: AvalonEP
  local level = ""          -- ATCP: AvalonLevel
  local gesinnung = ""      -- ATCP: AvalonGesinnung
  local portfolio = ""      -- ATCP: AvalonPortfolio
  local hunger = ""         -- ATCP: AvalonHunger
  local durst = ""          -- ATCP: AvalonDurst
  local alk = ""            -- wird leider nicht übertragen
  local hangover = false
  local fluch = false       -- wird leider nicht übertragen
  local krankheit = false   -- wird leider nicht übertragen
  local vergiftung = false  -- wird leider nicht übertragen
  local hoehe = ""          -- ATCP: AvalonHoehe
  local flucht = ""         -- ATCP: AvalonFlucht
  local schutz = ""         -- ATCP: AvalonSchutz
  local gruppenname = ""    -- ATCP: AvalonGruppe
  local zaubern = 0         -- ATCP: AvalonZaubern
  local stats = {
    tp = 0,
    tp_max = 0,
    ap = 0,
    ap_max = 0,
    zp = 0,
    zp_max = 0,
    mp = 0,
    mp_max = 0,
  }
  local inventarRein = ""	  -- ATCP: AvalonInventarRein
  local inventarRaus = ""	  -- ATCP: AvalonInventarRaus
  local behaelterRein = ""	-- ATCP: AvalonBehaelterRein
  local behaelterRaus = ""  -- ATCP: AvalonBehaelterRaus
  local gefuehrt = ""       -- ATCP: AvalonGefuehrt
  local gesenkt = ""        -- ATCP: AvalonGesenkt
  local angezogen = ""      -- ATCP: AvalonAngezogen
  local ausgezogen = ""     -- ATCP: AvalonAusgezogen
  local ep_speicher = ""
  local sessionEPBasis = 0  -- Speichert den EP-Stand beim einloggen
  local lastSessionEP = 0
  local bonusEP = 0
  local bonusEPAktiv = false
  local lastBonusEP = 0
  local schildEP = {
      ["istAktiv"] = false,
      ["basis"] = 0,
      ["wert"] = 0,
      ["letzterWert"] = 0,
  }
  local loginIsReconnect = false

  local lastMove = ""
  local avalonRoomID = ""
  local avalonRoomHash = ""
  local avalonRoomInv = ""
  local roomInv = {}
  local istDunkel = ""
  local locomotion = ""         -- speichert die Fortbewegungsart ("kletter"/"schwimme") für das automatische Klettern/Schwimmen
  local dataStorage = {}
  
  --[[
  Rückgabewert dieser inneren Funktion ist der Pfad zu der Datei, in der charakterbezogene
  Daten gespeichert werden. Das ist eine "Static Function", und die steht hier vorne,
  weil sie gleich verwendet wird. ]]
  local getCharacterFilePath = function(strCharName)
    --[[
    Der Separator in aktuellen System-Pfaden wird ermittelt und gespeichert.
    Notwendig weil unterschiedliche Betriebssysteme unterschiedliche Separatoren verwenden. ]]
    local separator = ""  
    if string.char(getMudletHomeDir():byte()) == "/" then separator = "/" else  separator = "\\" end
    
    -- In dieser Datei wird das Profil gespeichert
    local characterPath = getMudletHomeDir() .. separator .. "Avalet"..string.title(strCharName)..".json"

    --[[
    Das hier ist der Versuch, ein Problem mit Leerzeichen im Pfad unter Linux zu lösen.
    Indem das Leerzeichen mit einem "\" maskiert wird. Alternativ müsste man das mit 
    Anführungszeichen um den Pfad rum lösen. ]]
    if separator == "/" then string.gsub(characterPath, " ", "\ ") end

    return characterPath 
  end  


  local loadCharDataFromDisk = function(strName)
  	avalet.log("private function: loadCharDataFromDisk()", 1)

    strCharFilePath = getCharacterFilePath(strName)
  
    if io.exists(strCharFilePath) then
      avalet.log("Lade Charakter-Datei: " .. strName, 2)

      local subset = avalet.readFileFromFS(strCharFilePath, "r")
      --[=[
      --[[
      Also eigentlich finde ich, das hier müsste gehen. Geht aber nicht. TODO 
      Toll, Twrx hat mir die Lösung geschickt, irgendwas mit deepcopy, aber ich
      finde den Code grade nicht... :( Sorry Twrx. Mach ich in einem der 
      nächsten Updates. 
      Artox redet zu Dir: beim laden des chars hast du ne pairs schleife drin die
        nicht funktioniert...kann auch nicht, weil teile von subset tables
        sind, da koennte eine types abfrage helfen und vieleicht ein deepcopy
        wenns ein table ist
      Artox redet zu Dir: if type(v)~="table" then avalet.char[k] = v else
        avalet.char[k] = table.deepcopy(v) end      
      ]]
      for k,v in pairs(subset) do
        if k ~= "loginIsReconnect" then
          avalet.log("Geladenes Datum: "..k.." mit wert: "..tostring(v).."\n", 2)
          --avalet.char[k] = v 
          --self[k] = v
          key = v
        end
      end
      
      Dann eben umständlich:
      ]=]
      
      chatsBuffer = subset["chatsBuffer"]
      name = subset["name"]
      vollername = subset["vollername"]
      nation = subset["nation"]
      alter = subset["alter"]
      gilde = subset["gilde"]
      gildenInfo = subset["gildenInfo"]
      zuenfte = subset["zuenfte"]
      ep = subset["ep"]
      level = subset["level"]
      gesinnung = subset["gesinnung"]
      portfolio = subset["portfolio"]
      hunger = subset["hunger"]
      durst = subset["durst"]
      alk = subset["alk"]
      hangover = subset["hangover"]
      fluch = subset["fluch"]
      krankheit = subset["krankheit"]
      vergiftung = subset["vergiftung"]
      --hoehe = subset["hoehe"]
      --flucht = subset["flucht"]
      --schutz = subset["schutz"]
      --gruppenname = subset["gruppenname"]
      --zaubern = subset["zaubern"]
      stats = subset["stats"]
      --inventarRein = subset["inventarRein"]
      --inventarRaus = subset["inventarRaus"]
      --behaelterRein = subset["behaelterRein"]
      --behaelterRaus = subset["behaelterRaus"]
      --gefuehrt = subset["gefuehrt"]
      --gesenkt = subset["gesenkt"]
      --angezogen = subset["angezogen"]
      --ausgezogen = subset["ausgezogen"]
      --lastMove = subset["lastMove"]
      ep_speicher = subset["ep_speicher"]
      sessionEPBasis = subset["sessionEPBasis"]
      lastSessionEP = subset["lastSessionEP"]
      bonusEP = subset["bonusEP"]
      bonusEPAktiv = subset["bonusEPAktiv"]
      lastBonusEP = subset["lastBonusEP"]
      schildEP = subset["schildEP"]
      --NEVER!!!!loginIsReconnect = subset["loginIsReconnect"]
      --avalonRoomID = subset["avalonRoomID"]
      --avalonRoomHash = subset["avalonRoomHash"]
      --istDunkel = subset["istDunkel"]
      locomotion = subset["locomotion"]
      dataStorage = subset["dataStorage"] or {}
     
      if not loginIsReconnect then
        lastSessionEP = ep - sessionEPBasis
        --if bonusEP ~= 0 then 
        --  lastBonusEP = bonusEP
        --  bonusEP = 0
        --end
        avalet.log("SessionEP-Zähler wird zurückgesetzt auf EP: "..tostring(ep), 2)
        sessionEPBasis = tonumber(ep)
        if bonusEPAktiv then
          avalet.log("'Bonusstunde' wird deaktiviert.", 2)
          bonusEPAktiv = false
        end
        schildEP = {
            ["istAktiv"] = false,
            ["basis"] = 0,
            ["wert"] = 0,
            ["letzterWert"] = 0,
        }
        avalet.fight.resetLastFight()
      else
        avalet.log("SessionEP-Zähler wird NICHT zurückgesetzt, weil reconnect! ", 2)
      end
      
      avalet.log("Charakter-Datei wurde geladen!", 2)
      raiseEvent("characterFileLoadedEvent")
      
      -- Anzeige von TP, AP, ... aktualisieren
      avalet.vitals.updateAllVitals()
    else
      avalet.log("Charakter-Datei nicht gefunden für: " .. strName, 2)
      self.saveCharDataToDisk()
    end
  end
  

  self.saveCharDataToDisk = function()
    avalet.log("public function character: saveCharDataToDisk()", 1)

    if name == "" or name == nil then return end
  
    local data = {}
    data["chatsBuffer"] = chatsBuffer
    data["name"] = name
    data["vollername"] = vollername
    data["nation"] = nation
    data["alter"] = alter
    data["gilde"] = gilde
    data["gildenInfo"] = gildenInfo
    data["zuenfte"] = zuenfte
    data["ep"] = ep
    data["level"] = level
    data["gesinnung"] = gesinnung
    data["portfolio"] = portfolio
    data["hunger"] = hunger
    data["durst"] = durst
    data["alk"] = alk
    data["hangover"] = hangover
    data["fluch"] = fluch
    data["krankheit"] = krankheit
    data["vergiftung"] = vergiftung
    --data["hoehe"] = hoehe
    --data["flucht"] = flucht
    --data["schutz"] = schutz
    --data["gruppenname"] = gruppenname
    --data["zaubern"] = zaubern
    data["stats"] = stats
    --data["inventarRein"] = inventarRein
    --data["inventarRaus"] = inventarRaus
    --data["behaelterRein"] = behaelterRein
    --data["behaelterRaus"] = behaelterRaus
    --data["gefuehrt"] = gefuehrt
    --data["gesenkt"] = gesenkt
    --data["angezogen"] = angezogen
    --data["ausgezogen"] = ausgezogen
    --data["lastMove"] = lastMove
    data["ep_speicher"] = ep_speicher
    data["sessionEPBasis"] = sessionEPBasis
    data["lastSessionEP"] = lastSessionEP
    data["bonusEP"] = bonusEP
    data["bonusEPAktiv"] = bonusEPAktiv
    data["lastBonusEP"] = lastBonusEP
    data["schildEP"] = schildEP
    data["loginIsReconnect"] = loginIsReconnect
    --data["avalonRoomID"] = avalonRoomID
    --data["avalonRoomHash"] = avalonRoomHash
    --data["istDunkel"] = istDunkel
    data["locomotion"] = locomotion
    data["dataStorage"] = dataStorage

    avalet.log("Schreibe Character-Daten ...", 2)
    avalet.writeDataToFS(getCharacterFilePath(name), data, "w")
    avalet.log("... schreiben der Character-Daten beendet.", 2)

  end  
    
  self.getName = function() return name end
  self.setName = function(arg)
    --[[ Ich setze den Namen auf "nil" bei einem disconnect, damit 
    bei einem reconnect OHNE vorher Mudlet zu schließen das Char-
    File neu eingelesen wird. Ich hoffe das geht so. ]]
    if arg == nil then 
      avalet.log("Setze char.name auf Leerstring wegen disconnect (logout).", 2)
      name = ""
      return 
    end
    local newName = string.trim(tostring(arg))
    if name ~= newName then
      -- Wenn der Name noch leer ist, dann wird grade zum ersten Mal
      -- der Name per ATCP gesendet. Damit kann dann ein bestehendes
      -- Char-File geladen werden. 
      if string.len(name) == 0 then
        loadCharDataFromDisk(newName)
      end
      name = newName
      raiseEvent("CharacterInfoChange")
    end
  end --function self.setName(strNewName)
  self.getVollerName = function() return vollername end
  self.setVollerName = function(newFullName) 
    if vollername ~= newFullName then
      vollername = newFullName 
      raiseEvent("CharacterInfoChange")
    end
  end
  self.getNation = function() return nation end
  self.setNation = function(newNation) 
    if nation ~= newNation then 
      nation = newNation
      raiseEvent("CharacterInfoChange")
    end
  end
  self.getAlter = function() return alter end
  self.setAlter = function(newAlter) 
    if alter ~= newAlter then
      alter = newAlter
      raiseEvent("CharacterInfoChange")
    end
  end
  self.getGilde = function() return gilde end
  self.setGilde = function(newGilde)
    if gilde ~= newGilde then
      gilde = newGilde
      raiseEvent("CharacterInfoChange")
    end
  end
  self.getGildenInfo = function() return gildeninfo end
  self.setGildenInfo = function(newGildenInfo) 
    gildeninfo = newGildenInfo
    raiseEvent("GuildInfoChange")
  end
  self.getZuenfte = function() return zuenfte end
  self.setZuenfte = function(newZuenfte)
    if zuenfte ~= newZuenfte then
      zuenfte = newZuenfte
      raiseEvent("CharacterInfoChange")
    end
  end
  self.getEP = function() return ep end
  self.setEP = function(newEP)
    if ep ~= newEP then
    
      --[[
      Die EP sind 0 a) wenn der Char neu ist und b) wenn noch keine
      Charakter-Daten per ATCP eingegangen sind. Im Fall a) sind die
      "newEP" halt auch Null. Im Fall b) nicht. In beiden Fällen
      wäre das aber die Basis, auf der die Session-EP berechnet werden. ]]
      if ep == 0 then sessionEPBasis = newEP;avalet.log("sesseionEPBasis auf EP gesetzt!", 2) end
      
      ep = newEP

      if schildEP.istAktiv then
        schildEP.wert = ep - schildEP.basis
      end
    
      raiseEvent("StatisticsChange")
    end
  end
  self.getLevel = function() return level end
  self.setLevel = function(newLevel)
    if level ~= newLevel then
      level = newLevel
      raiseEvent("CharacterInfoChange")
    end
  end
  self.getGesinnung = function() return gesinnung end
  self.setGesinnung = function(newGesinnung) 
    if gesinnung ~= newGesinnung then
      gesinnung = newGesinnung
      raiseEvent("CharacterInfoChange")
    end
  end
  self.getPortfolio = function() return portfolio end
  self.setPortfolio = function(newPortfolio)
    if portfolio ~= newPortfolio then
      portfolio = newPortfolio
      raiseEvent("CharacterInfoChange")
    end
  end
  self.getHunger = function() return hunger end
  self.setHunger = function(newHunger) 
    hunger = newHunger
    raiseEvent("RefreshHDA", arg)
  end
  self.getDurst = function() return durst end
  self.setDurst = function(newDurst) 
    durst = newDurst
    raiseEvent("RefreshHDA", arg)
  end
  self.getAlk = function() return alk end
  self.setAlk = function(newAlk) 
    alk = newAlk
    raiseEvent("RefreshHDA", arg) 
  end
  self.getHangover = function() return hangover end
  self.setHangover = function(newHangover) 
    hangover = newHangover
    raiseEvent("RefreshHDA", arg)
  end
  self.getFluch = function() return fluch end
  self.setFluch = function(newFluch)
    if newFluch ~= true and newFluch ~= false then
      avalet.log("Fehlerhafter Wert für 'Fluch': muss binär sein", 3)
    end
    fluch = newFluch
    raiseEvent("DistressChange")
  end
  self.getKrankheit = function() return krankheit end
  self.setKrankheit = function(newKrankheit) 
    if newKrankheit ~= true and newKrankheit ~= false then
      avalet.log("Fehlerhafter Wert für 'Krankheit': muss binär sein", 3)
    end
    krankheit = newKrankheit
    raiseEvent("DistressChange")
  end
  self.getVergiftung = function() return vergiftung end
  self.setVergiftung = function(newVergiftung) 
    if newVergiftung ~= true and newVergiftung ~= false then
      avalet.log("Fehlerhafter Wert für 'Vergiftung': muss binär sein", 3)
    end
    vergiftung = newVergiftung
    raiseEvent("DistressChange")
  end
  --self.getHoehe = function() return hoehe end
  self.setHoehe = function(newHoehe) hoehe = newHoehe end
  --self.getFlucht = function() return flucht end
  self.setFlucht = function(newFlucht) flucht = newFlucht end
  self.getSchutz = function() return schutz end
  self.setSchutz = function(newSchutz) schutz = newSchutz end
  self.getGruppenname = function() return gruppenname end
  self.setGruppenname = function(newGruppenname) gruppenname = newGruppenname end
  --self.getZaubern = function() return zaubern end

  self.getLastSessionEP = function()
    return lastSessionEP
  end
  self.getLastBonusEP = function()
    return lastBonusEP  
  end
  self.getLastSchildEP = function()
    return schildEP["letzterWert"]
  end
  
  self.setZaubern = function(newZaubern) zaubern = newZaubern end

  self.getStats = function() return stats end
  self.getStatsTP = function() return stats.tp end
  self.setStatsTP = function(newTP)
    if stats.tp ~= newTP then 
      stats.tp = newTP
      raiseEvent("VitalsChange", {"TP", stats.tp, stats.tp_max})
    end 
  end
  --self.getStatsTPMax = function() return stats.tp_max end
  self.setStatsTPMax = function(newTPMax) 
    if stats.tp_max ~= newTPMax then
      stats.tp_max = newTPMax
      raiseEvent("VitalsChange", {"TP", stats.tp, stats.tp_max})
    end
  end
  --self.getStatsAP = function() return stats.ap end
  self.setStatsAP = function(newAP) 
    if stats.ap ~= newAP then
      stats.ap = newAP 
      raiseEvent("VitalsChange", {"AP", stats.ap, stats.ap_max})
    end
  end
  --self.getStatsAPMax = function() return stats.ap_max end
  self.setStatsAPMax = function(newAPMax) 
    if stats.ap_max ~= newAPMax then
      stats.ap_max = newAPMax 
      raiseEvent("VitalsChange", {"AP", stats.ap, stats.ap_max})
    end
  end
  --self.getStatsZP = function() return stats.zp end
  self.setStatsZP = function(newZP) 
    if stats.zp ~= newZP then
      stats.zp = newZP 
      raiseEvent("VitalsChange", {"ZP", stats.zp, stats.zp_max})
    end
  end
  --self.getStatsZPMax = function() return stats.zp_max end
  self.setStatsZPMax = function(newZPMax) 
    if stats.zp_max ~= newZPMax then
      stats.zp_max = newZPMax 
      raiseEvent("VitalsChange", {"ZP", stats.zp, stats.zp_max})
    end
  end
  --self.getStatsMP = function() return stats.mp end
  self.setStatsMP = function(newMP) 
    if stats.mp ~= newMP then
      stats.mp = newMP 
      raiseEvent("VitalsChange", {"MP", stats.mp, stats.mp_max})
    end
  end
  --self.getStatsMPMax = function() return stats.mp_max end
  self.setStatsMPMax = function(newMPMax) 
    if stats.mp_max ~= newMPMax then
      stats.mp_max = newMPMax
      raiseEvent("VitalsChange", {"MP", stats.mp, stats.mp_max})
    end 
  end
  --self.getInventarRein = function() return inventarRein end
  self.setInventarRein = function(newInventarRein) inventarRein = newInventarRein end
  --self.getInventarRaus = function() return inventarRaus end
  self.setInventarRaus = function(newInventarRaus) inventarRaus = newInventarRaus end
  --self.getBehaelterRein = function() return inventarRein end
  self.setBehaelterRein = function(newBehaelterRein) behaelterRein = newBehaelterRein end
  --self.getBehaelterRaus = function() return behaelterRaus end
  self.setBehaelterRaus = function(newBehaelterRaus) behaelterRaus = newBehaelterRaus end
  --self.getGefuehrt = function() return gefuehrt end
  self.setGefuehrt = function(newGefuehrt) gefuehrt = newGefuehrt end
  --self.getGesenkt = function() return gesenkt end
  self.setGesenkt = function(newGesenkt) gefuehrt = newGesenkt end
  --self.getAngezogen = function() return angezogen end
  self.setAngezogen = function(newAngezogen) angezogen = newAngezogen end
  --self.getAusgezogen = function() return ausgezogen end
  self.setAusgezogen = function(newAusgezogen) ausgezogen = newAusgezogen end
  self.getLastMove = function() return lastMove end
  self.setLastMove = function(newLastMove) lastMove = newLastMove end
  self.getEPSpeicher = function() return ep_speicher end
  self.setEPSpeicher = function(newEPSpeicher) ep_speicher = newEPSpeicher end
  self.getSessionEP = function() return (ep - sessionEPBasis) end
--  self.setSessionEP wird nicht gebraucht
  self.bonusEPStart = function() 
    bonusEPAktiv = true
    lastBonusEP = bonusEP
    bonusEP = 0
    raiseEvent("StatisticsChange")
  end
  self.bonusEPStop = function() 
    bonusEPAktiv = false
    raiseEvent("StatisticsChange")
  end
  self.setBonusEP = function(intBonusEP) 
    bonusEP = intBonusEP  
    raiseEvent("StatisticsChange")
  end
  self.getBonusEP = function() 
    return bonusEP 
  end
  self.getBonusEPState = function() return bonusEPAktiv end
  self.schildEPStart = function()
    schildEP.istAktiv = true
    schildEP.letzterWert = schildEP.wert
    schildEP.basis = ep
    raiseEvent("StatisticsChange")
  end
  self.schildEPStop = function() 
    schildEP.istAktiv = false
    --schildEP["letzterWert"] = schildEP.wert
    --schildEP.wert = ep - schildEP.basis
    raiseEvent("StatisticsChange")
  end
  self.getSchildEP = function() return schildEP.wert end
  self.getSchildEPActivityState = function() return schildEP.istAktiv end
  self.getLoginIsReconnect = function() return loginIsReconnect end
  self.setLoginIsReconnect = function(newLoginIsReconnect) loginIsReconnect = newLoginIsReconnect end
  self.getAvalonRoomID = function() return avalonRoomID end
  self.setAvalonRoomID = function(newAvalonRoomID)
    avalet.log("Function char:setAvalonRoomID", 1)
    --[[
    Per ATCP kommen RoomID und RoomHash in einem String. Die Zerlegung findet
    aber schon im ATCP-Bereich statt. Hier kommt also wirklich nur RoomID an. ]]
    if avalonRoomID ~= newAvalonRoomID then
      avalonRoomID = newAvalonRoomID
    end
    raiseEvent("AvalonRoomIDChange")
    --[[
    avalonRoomID = ""
    local str = ""
    str = string.gsub(newAvalonRoomID, "^%S*%s+(.+)", "%1", 1)
    if str ~= '""' then 
      avalonRoomID = str
      avaletUI.roomID:echo(str)
    end
    str = string.gsub(newAvalonRoomID, "^raum/(%S*)%s+.+", "%1", 1)
    avalonRoomHash = str
    ]]  
  end
  self.getAvalonRoomHash = function() return avalonRoomHash end
  self.setAvalonRoomHash = function(newAvalonRoomHash)
    avalet.log("Function char:setAvalonRoomHash", 1)
    --cecho("&lt;magenta&gt;roomHash: "..newAvalonRoomHash.."\n")
    avalonRoomHash = newAvalonRoomHash
  end
  self.getAvalonRoomInv = function() return avalonRoomInv end
  self.getRoomInv = function(id)
    if id == nil then
      return roomInv
    else
      if roomInv[id] == nil then
        avalet.log("Unbekannte ID, findet sich nicht in roomInv. roomInv wird neu angefordert.", 2)
        _ = sendATCP("ava_req_inv hier")
        local tbl = {}
        tbl[id] = {["name"]="???", ["type"]="???", ["iid"]=id}
        return tbl[id]
      else
        return roomInv[id]
      end
    end
  end
  self.setAvalonRoomInv = function(newAvalonRoomInv)
  
    arg = newAvalonRoomInv
    local objType
    local objIID
    local objName
    
    avalonRoomInv = newAvalonRoomInv;

    -- alte Daten löschen
    roomInv = {}
    
    -- erstmal das führende "hier " abtrennen
    arg = string.gsub(arg, "hier (.*)", "%1")
  
    -- den Rest in die einzelnen Objekte zerlegen
    for i in string.gmatch(arg, "[^,]+") do
  
      for objIID, objName in string.gmatch(i, '([^"]+)["]([^"]+)["]') do
      
        objType = string.gsub(objIID, "avalon/([^/]+)/.+", "%1")
        objIID = string.gsub(objIID, "^avalon/[a-z]*/(.*) ", "%1")  
        
        roomInv[objIID] = {["name"]=objName, ["type"]=objType, ["iid"]=objIID}
        
      end
      
    end
    
    raiseEvent("AvalonInvChange") 
  end
  --self.getIstDunkel = function() return istDunkel end
  self.setIstDunkel = function(newIstDunkel) istDunkel = newIstDunkel end
  self.getLocomotion = function() return locomotion end
  self.setLocomotion = function(newLocomotion) locomotion = newLocomotion end
  
  self.getDataStorage = function(moduleName) 
                          if(moduleName == nil) then 
                          	avalet.log("Funktion avalet.char.getDataStorage(): Parameter ist nil.", 2)
                            return {"Parameter ist nil"} 
                          end;
                          if dataStorage[moduleName] ~= nil then 
                          	avalet.log("Funktion avalet.char.getDataStorage(): Daten gefunden.", 2)
                            return dataStorage[moduleName] 
                          else 
                          	avalet.log("Funktion avalet.char.getDataStorage(): Keine Daten unter dem Namen.", 2)
                            dataStorage[moduleName]={}
                            return dataStorage[moduleName]
                          end 
                        end
  self.setDataStorage = function(moduleName, data) 
                          if moduleName == nil then 
                          	avalet.log("Funktion avalet.char.setDataStorage(): Parameter modulName ist nil.", 2)
                            return 
                          end
                          if data == nil then 
                          	avalet.log("Funktion avalet.char.setDataStorage(): Parameter data ist nil.", 2)
                            return 
                          end
                         	avalet.log("Funktion avalet.char.setDataStorage(): Daten werden gespeichert.", 2)
                          dataStorage[moduleName] = data 
                        end
  
  self.getChatBuffer = function(key) return chatsBuffer[key] end
  
  self.flushChatBuffer = function()
    for k,v in pairs(chatsBuffer) do
      chatsBuffer[v] = {}
    end
  end
    
  return self

end

--[[
Hier wird das Charakter-Objekt erstmals nach dem Neustart von Mudlet/Avalet
erzeugt. Zu diesem Zeitpunkt ist der Charaktername noch nicht bekannt, das
erzeugte Objekt ist deshalb weitgehend leer bzw. mit default-Werten besetzt. ]]
function avalet.initCharacter()
	avalet.log("Funktion avalet.initCharacter() aufgerufen.", 1)

  return objCharacter.new()
  
end
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>objFight</name>
			<packageName></packageName>
			<script>--[[
Hier findet alles statt, was mit einem Kampf zu tun hat. Unter anderem wird
hier auch die Kampfdauer gemessen. Dazu ein paar Worte:
Prinzipiell ist das mit der Kampfdauer kein Problem: Beim Angriff eine Stopwatch
starten, beim Tod des Kampfes die Stopwatch auslesen und die Zeit anzeigen. Wird
der Kampf unterbrochen, wird auch die Stopuhr gestoppt. Die Stopuhr erhält als
Bezeichnung ("name") die Gegner-ID, so dass ein begonnener Kampf auch wieder
fortgesetzt werden kann. (Indem erstmal die bestehenden Stopwatches durchsucht
werden nach einer, die die Gegner-ID als Namen hat.) Beim Tod eines Gegners wird
die Stopuhr gelöscht. Übriggebliebene Stopuhren werden hoffentlich nicht so zahl-
reich, dass sie zum Problem werden. (Wenn man mit aktiviertem Gegenangriff durch
die Gegend rennt, gibt halt jeder agressive Gegner eine Stopuhr.) 
Problematisch sind Sonderfälle wie: 
- mehrere Gegner, 
- fliehende Gegner (vor allem wenn es mehrere Gegner sind, die in unterschiedliche
  Richtungen fliehen...)
- Kämpfe, die der Char ausschließlich mit Zaubern durchführt (ohne Gegenangriff und
  ohne erstmal mit Fäusten oder so anzugreifen)
- "one strike"-Kämpfe mit Zaubern,
- usw. 
Da soll die Kampfdauer aber natürlich auch irgendwie nachvollziehbare Werte anzeigen. TODO 

Hier sollen auch die Treffer erfasst werden. Das ist aber noch nicht realisiert. TODO 

Die Messung der Kampfdauer gehört zu den zuletzt implementierten Funktionen und ist
sicherlich noch sehr BETA... ]]

local objFight = {}

objFight.new = function()

  local self = {}

  local kampf = false               -- ATCP: AvalonKampf
  local angegriffen = ""            -- ATCP: AvalonAngegriffen
  local getoetet = ""               -- ATCP: AvalonGetoetet
  local gruppeGetoetet = ""         -- ATCP: AvalonGruppeGetoetet
  local allyGetoetet = ""           -- ATCP: AvalonAllyGetoetet

  local battleTimerID = nil         -- Speichert die ID des Timers, der sekündlich ...
                                    -- ... die Statistiken aktualisiert (wenn Kampfdauer-Zähler läuft)
  local stopWatchName = nil         -- Gegen diesen Gegner wird grad gekämpft, der Kampfdauer-Zähler zeigt diesen Wert an.
  local thisFightDuration = nil     -- Hier wird die Dauer eines Kampfes gespeichert, wenn der Kampf vorbei ist.
  local lastFightDuration = nil     -- Hier wird die Dauer des letzten Kampfes gespeichert, bevor der Zähler gelöscht wird.
  local inBattle = false            -- Ist true nur wenn der Char auch austeilt. Nicht wenn er nur haue bezieht.
  local fights = {}                 -- Liste der Gegner in einem Kampf
  local hits = {}                   -- Treffer (ausgeteilte und eingesteckte), Paraden, Ausweichen...
  
  local STOPWATCH_PREFIX = "avalet_fights_"         -- string.find(string, STOPWATCH_PREFIX)
  
  --[=[
  Folgende Situation: der Char greift einen Wolf an. Der Wolf holt sich Verstärkung, da sinds zwei Wölfe.
  Die Spielerin weiß, was sie zu tun hat, und so kommt für jeden getöteten Wolf ein neuer nach. Bis es 
  insgesamt vier Wölfe sind bzw. waren. Irgendwann sind alle vier Wölfe tot. Wie kann man da jetzt die
  Kampfdauer messen? Und zwar so, dass es egal ist, in welcher Reihenfolge die Wölfe getötet werden und 
  ob der Kampf vielleicht mal kurz unterbrochen wird. 
  fights = {
      [gegner11ID/stopWatchName] = {
          [gegner11ID] = "Name", 
          [gegner12ID] = "Name", 
          [gegner13ID] = "Name", 
          [gegner14ID] = "Name"
      }
  }
  hits = {
      [gegner11ID/stopWatchName] = {
          [extrem] = 0, 
          [sehr_stark] = 0, 
          [stark] = 0, 
          [hart] = 0, 
          [leicht] = 0,
          [ausgewichen] = 0,
          [pariert] = 0,
      }
  }

Erlaubte Werte fuer die Kampfanzeige sind: "alles", "treffer", "sehr
leicht", "leicht", "hart", "stark", "sehr stark", "extrem stark", "doppelt
extrem" und "minimal".
]=]

  --[[
  Fügt einen Kampf zur Liste der Kämpfe hinzu. 
  Param1: ID des Gegners als String (ist gleichzeitig der StopWatch-Name)
  Param2 (optional): Name des Gegners ("Schaf") als String 
  call: self.addFight("GegnerID"(, "GegnerName")) ]]
  self.addFight = function(strStopWatchName, strOpponentID, strOpponentName)
    local stopWatchName = strStopWatchName
    local opponentID = strOpponentID
    local opponentName = strOpponentName or true
    fights[stopWatchName]={}
    fights[stopWatchName][opponentID]=opponentName
  end
  
  
  --[[
  Fügt einen Gegner einem Kampf hinzu.
  Param1: Kampf-ID (StopWatch-Name, ID des ersten Gegners im Kampf)
  Param2: ID des Gegners, der hinzugefügt werden soll
  Param3 (optional): Name des Gegners, der hinzugefügt werden soll ("Schaf") 
  call: self.addOpponentToFight("FightID", "OpponentID"(, "OpponentName")) ]]
  self.addOpponentToFight = function(strFightID, strOpponentID, strOpponentName)
    local fightID = strFightID
    local opponentID = strOpponentID
    local opponentName = strOpponentName or true
    fights[fightID][opponentID]=opponentName
  end
  
  
  self.removeOpponentFromFight = function(strFightID, strOpponentIDToRemove)
    avalet.log("inner function fight:removeOpponentFromFight() with param '"..tostring(strFightID).."' und '"..tostring(strOpponentIDToRemove), 1)
    local fightID = strFightID
    local opponentIDToRemove = strOpponentIDToRemove
    if fights[fightID] then
      fights[fightID][opponentIDToRemove] = nil
    end
  end
  
  self.removeFight = function(strFightID)
    local fightID = strFightID
    if table.is_empty(fights[fightID]) then
      if stopWatchName == fightID then
        -- aktueller Fight endet
        
      end
      fights[fightID] = nil
      avalet.log("Kampf gelöscht: "..tostring(fightID), 2)
    end    
  end
  
  self.fightHasNoOpponents = function(fightID)
    if table.is_empty(fights[fightID]) then
      return true
    else
      return false
    end
  end

  
  --[[
  Gibt die ID des Kampfes zurück, an der der Gegner beteiligt ist bzw. war.
  Oder nil, wenn es so eine Kampf-ID nicht gibt. 
  Param1: Gegner-ID als String ]]
  self.getOpponentsFightID = function(strOpponentID)
    local opponentID = strOpponentID
    for k, v in pairs(fights) do
      for i, j in pairs(v) do
        if i == gegnerID then 
          avalet.log("Kampf für Gegner "..tostring(opponentID).." gefunden, Kampf-ID:: "..tostring(k), 2)
          return k
        end
      end
    end
    avalet.log("KEIN Kampf für Gegner "..tostring(opponentID).." gefunden", 2)
    return nil
  end
  
  --[[
  Fügt die Bezeichnung des Gegners ("Schaf") zum Kampf hinzu, falls diese vorher nicht 
  bekannt war. (Weil der Gegner den Raum erst betreten hat, nachdem der Char schon da stand
  und deshalb bei Kampfbeginn in roomInv nicht enthalten war.)
  Param1: Gegner-ID als String
  Param2: Gegner-Bezeichung als String ]]
  self.updateGegnerName = function(strOpponentID, strOpponentName)
    local opponentID = strOpponentID
    local opponentName = strOpponentName
    
    local fightID = self.getOpponentsFightID(opponentID)

    if fightID ~= nil then fights[fightID][opponentID] = opponentName end

  end


  --[[
  Für die Anzeige auf der Oberfläche wird der Sekundenwert aufgehübscht. ]]
  local formatFightDuration = function(arg)
    local dauer = arg or 0
    local m = 0
    local s = 0
    m = math.floor(dauer/60)
    s = dauer%60
    return string.format("%d:%02d", m, s)
  end
  

  self.resetLastFight = function() lastFightDuration = nil end


  --[[
  Der ATCP-Wert "AvalonKampf" zeigt zwar an, ob der Char sich in einem
  Kampf befindet. Aber dazu zählt auch schon, wenn nur der Gegner kämpft,
  der Char aber noch nicht. Deshalb wird hier nur das ENDE des Kampfes
  für den Kampfdauer-Zähler verwendet. Indem die Stopwatch angehalten wird.
  Der Kampf muss damit nicht zuende sein. Eine Unterbrechung (Flucht des
  Gegners, Flucht des Chars, ...) würde das auch auslösen. ]]
  self.getKampf = function() return kampf end
  self.setKampf = function(newKampf)
    avalet.log("public function fight: setKampf(): "..tostring(newKampf), 2)
    if newKampf == "0" then
      kampf = false
      --[[
      Wenn nicht gekämpft wird, dann darf auch keine Stopwatch laufen. Das hier
      wird zum Problem, wenn es auch mal für andere Zwecke Stopuhren geben sollte.
      Und ich hab keine Ahnung, ob hier auch Stopuhren aus anderen Modulen oder so
      gefunden werden würden. Aber wer braucht schon Stopuhren! ]]
      -- Liste mit allen Stopwatches holen
      avalet.log("Stoppe alle StopWatches", 2)
      local listOfStopWatches = getStopWatches()
      avalet.log("Anzahl Stopwatches derzeit: "..tostring(#listOfStopWatches), 2)
      for _,v in ipairs(listOfStopWatches) do
        if string.find(v["name"], STOPWATCH_PREFIX) ~= nil then
          avalet.log("Stopwatch mit dem richtigen Prefix gefunden: "..v["name"].."(running: "..tostring(v["isRunning"])..")", 2)
          -- laufende Stopwatches stoppen
          if v["isRunning"] then
            stopStopWatch(v["name"])
            avalet.log("Stopwatch gestoppt", 2)
          end
        end
      end
      avalet.log("Setze iBattle auf false", 2)
      inBattle = false
      --[[
      Der Timer aktualisiert sekündlich die Char-Info-Box, damit dort die Kampfdauer angezeigt wird.
      Und der muss jetzt weg. ]]
      avalet.log("Entferne Timer battleTimerID: "..tostring(battleTimerID), 2)
      if battleTimerID ~= nil then
        if killTimer(battleTimerID) then
          battleTimerID = nil
          avalet.log("Timer erfolgreich entfernt.", 2)
        else
          avalet.log("Timer konnte nicht entfernt werden!", 3)
        end
      end
      
      --aktualisierung der Oberfläche (deaktivierung des Zählers)
      avalet.log("Aktualisiere Oberfläche (deaktiviere Zähler)", 2)
      raiseEvent("StatisticsChange")
      
    elseif newKampf == "1" then
      kampf = true
    else
      avalet.log("Fehlerhafter Wert für 'Kampf': "..newKampf.." (0 oder 1 als String erwartet)", 3)
    end
    raiseEvent("UnderAttackChange")
  end

  --[[
  Dauer des letzten Kampfes, für die Anzeige auf der Oberfläche. Der Wert
  ist hier schon für die Anzeige formatiert. (m:ss) ]]
  self.getLastFightDuration = function()
    avalet.log("function fight:getLastFightDuration()", 1)
    avalet.log("lastFightDuration: "..tostring(lastFightDuration), 2)
    if lastFightDuration == nil or lastFightDuration == 0 then
      return nil
    else
      return formatFightDuration(lastFightDuration)
    end
  end  
  
  --[[
  Der Kampfstatus ist nur true, wenn der Char auch zuhaut. Denn nur dann soll
  die Zeit gezählt werden. ]]
  self.getFightStatus = function() return inBattle end
  
  
  --[[
  Die ID des angegriffenen Gegners wird als Name für die StopWatch verwendet. Auf diese
  Weise kann der Timer wiedergefunden werden, wenn der Kampf unterbrochen und später
  fortgesetzt wird. Wenn der Gegner ein "wesen" ist, dann wird die reine ID verwendet,
  in anderen Fällen (Gegner ist NPC) wird der gesamte String verwendet. Sollte so oder
  so eindeutig sein. ]]
  local getOpponentID = function(arg)
  
    return string.gsub(arg, "^avalon/wesen/(.*)", "%1")
  
  end
  
  
  self.onRoomInvChange = function()
    avalet.log("onRoomInvChange ist ausgelöst worden!", 2)
  end
  registerAnonymousEventHandler("AvalonInvChange", "avalet.fight.onRoomInvChange")
  --raiseEvent("AvalonInvChange")
  
  
  --[[
  Die aktuelle Kampfdauer wird von der Oberfläche abgefragt. Sie wird
  hier frisch von der Stopwatch abgefragt, formatiert und zurückgeschickt.
  Existiert die Stopwatch nicht, liefert die Abfrage nil zurück. In diesem
  Fall ist der Kampf schon beendet und die Kampfdauer in der Variable 
  'thisFightDuration' gespeichert. ]]
  self.getFightDuration = function()
    local sec = 0
    if stopWatchName ~= nil then
      avalet.log("stopWatchName = '"..tostring(stopWatchName).."'", 2)
      sec = getStopWatchTime(stopWatchName)
    end
    if thisFightDuration == nil then thisFightDuration = 0 end
    if sec == nil then sec = math.floor(thisFightDuration) end
    
    return formatFightDuration(sec)

  end
  
  local getOpponentsStopWatchName = function(strOppID)
    avalet.log("private function fight:getOpponentsStopWatchName()", 1)
    
    if table.is_empty(fights) then avalet.log("table is_empty!", 2); return nil else avalet.log("table IST NICHT empty!", 2) end
    
    local opponentID = strOppID
    
    for key, value in pairs(fights) do
      if value[opponentID] then
        return key
      end
    end
    
    return nil
  end

  --[[
  ANGEGRIFFEN
  Der ATCP-Wert 'AvalonAngegriffen' enthält die Gegner-ID des angegriffenen Gegners. ]]
  self.setAngegriffen = function(arg)
    avalet.log("public function fight:setAngegriffen() mit param: "..tostring(arg), 1)
    
    -- was wenn der gegner vom gruppenmitglied im nachbarraum getötet wird?
  
    -- das könnte vermutlich weg 
    angegriffen = arg
    
    --[[
    Gibt es schon eine StopWatch, bei der dieser Gegner bekämpft wurde? ]]
    --stopWatchID = getOpponentsStopWatchName()  TODO

    if not inBattle then
    
      --[[
      Wenn der Char nicht 'inBattle' ist, dann beginnt ein neuer Kampf. Oder ein alter wird
      wieder aufgenommen. Oder es ist ein Kill durch Zauber, bei dem das hier extra ausgeführt wird.]]
    
      --[[
      In 'thisFightDuration' wird die gemessene Zeit gespeichert, wenn der Gegner tot und der
      Kampf somit endgültig beendet ist. Sonst ist er leer. Da jetzt ein neuer Gegner
      angegriffen wurde, wird dieser letzte Wert erstmal gesichert, damit auf der Ober-
      fläche jeweils auch die Dauer des vorherigen Kampfes angezeigt werden kann. ]]
      if thisFightDuration ~= nil then
        avalet.log("thisFightDuration wird zu lastFightDuration", 2)
        lastFightDuration = thisFightDuration; 
        thisFightDuration = nil 
      end
      
      --[[
      Wenn der Char noch nicht im Kampf ist, dann ist er es jetzt. ]]
      inBattle = true
      -- Zähler auf Oberfläche grün machen:
      
      --[[
      Sollte es noch einen Battle-Timer geben, muss der jetzt weg. (Das war mal in
      einer eher schrägen Konstellation der Fall. Sollte also selten vorkommen
      und stört auch nicht die Funktionsfähigkeit, wenn der alte Timer erhalten
      bleibt, kostet aber Laufzeit. ]]
      if battleTimerID ~= nil then
        avalet.log("BattleTimer läuft schon, wird entfernt: "..tostring(battleTimerID), 2)
        if killTimer(battleTimerID) then
          battleTimerID = nil
          avalet.log("Timer erfolgreich entfernt.", 2)
        else
          avalet.log("Timer konnte nicht entfernt werden!", 3)
        end
      end
      --[[
      Der Timer, der hier erzeugt und dessen timerID hier gespeichert wird,
      löst sekündlich einen Event aus, durch den die Anzeige der Info-Box 
      aktualisiert wird. Damit dort die angezeigte Zeit (einigermassen) stimmt. ]]
      battleTimerID = tempTimer(1, function() raiseEvent("StatisticsChange") end, true)
      
      local opp = {}
      --[[
      Die ID des angegriffenen Gegners wird als Name für die StopWatch verwendet. Auf diese
      Weise kann der Timer wiedergefunden werden, wenn der Kampf unterbrochen und später
      fortgesetzt wird. ]]
      local opponentID = getOpponentID(arg)
      stopWatchName = getOpponentsStopWatchName(opponentID)
      
      if stopWatchName == nil then
        avalet.log("Unbekannter Gegner, erhält neue StopWatch", 2)
        stopWatchName = STOPWATCH_PREFIX..opponentID

        --[[
        Der Gegner wird nochmal extra gespeichert, um Kämpfe gegen mehrere Gegner abbilden
        zu können. Zusätzlich wird die Bezeichnung des Gegners ("Schaf") aus dem roomInv
        geholt. ]]
        opp = avalet.char.getRoomInv(opponentID)
        
        if opp == nil then avalet.log("Keinen Gegner-Namen erhalten", 3) end

        self.addFight(stopWatchName, opponentID, opp["name"])

      else
        avalet.log("Gegner schon bekannt, StopWatch existiert und wird weiter verwendet", 2)
      end
      
      --[[
      Wenn die StopWatch unter diesem Namen schon existiert, dann liefert der Versuch, sie
      nochmal zu erzeugen, nil zurück. Und sonst wird sie halt erzeugt. ]]
      local stopWatchID = createStopWatch(stopWatchName)
      if stopWatchID == nil then avalet.log("StopWatch existiert schon, setze Messung damit fort.", 2) end
      
      --[[
      Egal ob sie schon existierte oder grade erzeugt wurde - die StopWatch wird gestartet. ]]
      startStopWatch(stopWatchName)
      raiseEvent("StatisticsChange")
      
      avalet.log("Angegriffen: "..opponentID.." ("..tostring(opp["name"])..")", 2)

    else --if inBattle
    
      --[[
      Wenn da schon ein Kampf läuft grade, dann ist der neue Gegner wohl ein zusätzlicher
      Gegner im laufenden Kampf. In diesem Fall läuft die StopWatch schon, der Timer auch.
      Hier wird also lediglich gespeichert, dass der aktuell laufende Kampf einen weiteren
      Gegner bekommen hat. Der Laufende Kampf ist der, zu dem die laufende StopWatch gehört. ]]

      --[[
      Die ID des hinzugekommenen Gegners wird benötigt, um sie gleich zu speichern. ]]
      additionalOpponentID = getOpponentID(arg)
      avalet.log("ID des zuätzlichen Gegners: "..tostring(additionalOpponentID), 2)
      
      --[[
      Der Gegner wird dem schon bestehenden Kampf hinzugefügt. Zusätzlich wird die Bezeichnung
      des Gegners ("Schaf") aus dem roomInv geholt. ]]
      opp = avalet.char.getRoomInv(additionalOpponentID)
      
      if opp == nil then avalet.log("Keinen Gegner-Namen erhalten", 3) end

      self.addOpponentToFight(stopWatchName, additionalOpponentID, opp["name"])
    
      avalet.log("Dem Kampf "..stopWatchName.." hinzugefügt:"..additionalOpponentID.." ("..tostring(opp["name"])..")", 2)
      
    end
    
  end

  --[[
  Die ATCP-Werte 'Getoetet', 'GruppeGetoetet' und 'AllyGetoetet' besagen für die Kampfdauer
  alle das gleiche - der Gegner ist tot, der Kampf vorbei. Außer es gibt mehr als einen
  Gegner natürlich. Deshalb werden diese drei Werte hier einheitlich verarbeitet. ]]
  local gegnerGetoetet = function(arg, strWho)
  
    local who = strWho -- wer hat getötet: "char", "ally", "gruppe"; doch nicht verwendet
  
    local opponentID = getOpponentID(arg)
    
    --[[
    Der Name der StopWatch ist eigentlich die Gegner-ID (plus Prefix) - aber nur im Kampf 
    gegen einzelne Gegner. Im Kampf gegen mehrere wird die StopWatch des zuerst angegriffenen
    für alle verwendet. Die Funktion getOpponentsStopWatchName gibt den verwendeten Namen
    zurück - oder nil, wenn es keine StopWatch zu dieser Gegner-ID gibt. ]]
    local oppStopWatchName = getOpponentsStopWatchName(opponentID)
    
    avalet.log("Der grade getötete Gegner hat die ID: '"..tostring(opponentID).."'", 2)
    avalet.log("Derzeit gestartete StopWatch (Name, nicht ID): '"..tostring(stopWatchName).."'", 2)
    avalet.log("StopWatch des Gegners, falls bekannt: '"..tostring(oppStopWatchName).."'", 2)
    
    --[[
    Ein Gegner kann mit einem einzigen Schlag getötet werden - zumindest wenn dieser Schlag
    ein Lavastoss V ist. Und Zauber scheinen nicht als normale Angriffe behandelt zu werden,
    es gibt also kein "Angegriffen"-Flag per ATCP. Folglich gibt es keine StopWatch für den
    Gegner, wenn die "Getötet"-Meldung per ATCP kommt. Und es gibt auch keine StopWatch,
    wenn Gruppenmitglieder den Gegner töten. Ohne dass man selbst angreifen konnte. Und es
    mag auch noch andere Gründe geben, warum das hier ausgeführt wird, ohne dass es eine
    StopWatch gibt. Deshalb ...]]
    if oppStopWatchName == nil then 
      raiseEvent("AvalonAngegriffen", arg)
      oppStopWatchName = getOpponentsStopWatchName(opponentID)
    end
    --[[
    ... gibt es sie jetzt doch. Und die Variable 'stopWatchName' enthält jetzt ihren Namen. 
    Und gestartet ist sie jetzt auch. ]]

    --[[
    Wenn der Gegner der aktuellen StopWatch (Variable: stopWatchName) zugeordnet ist, dann 
    ist das ja auch der Kampf, der grade auf der Oberfläche angezeigt wird. Der Gegner wird
    dann an der StopWatch entfernt. Ist er der letzte Gegner dieser StopWatch, ist der Kampf
    vorbei. Das sollte sowohl einen aktiven Kampf abdecken als auch eine Situation, in der
    der Char den Kampf verlassen hat und ein Gruppenmitglied den Gegner in der Zeit tötet.
    (Unterschied wäre dann, das "inBattle" einmal true und einmal false ist.) ]]
    if stopWatchName == oppStopWatchName then
      self.removeOpponentFromFight(stopWatchName, opponentID)
    
    --[[
    Ist der Gegner einer anderen, für den Char grad nicht aktuellen StopWatch zugeordnet, wird
    er von dort entfernt. Ist die StopWatch dann leer, wird sie auch entfernt. ]]
    else
      self.removeOpponentFromFight(oppStopWatchName, opponentID)
      if self.fightHasNoOpponents(oppStopWatchName) then 
        self.removeFight(oppStopWatchName) 
        deleteStopWatch(oppStopWatchName)
      end
      return
    end
    
    avalet.log("StopWatchName: "..tostring(stopWatchName),2)

    if self.fightHasNoOpponents(stopWatchName) then
      avalet.log("Kampf hat keine weiteren Gegner: "..tostring(stopWatchName), 2)
    
      -- Die entsprechende StopWatch wird gestoppt...
      stopStopWatch(stopWatchName)
      --[[
      ... und die gemessene Zeit ausgelesen und in 'thisFightDuration' gespeichert, damit die
      StopWatch gelöscht werden kann. ]]
      thisFightDuration = getStopWatchTime(stopWatchName)
      
      inBattle = false
      raiseEvent("StatisticsChange")
      
      --[[
      Das Löschen der StopWatch gibt true oder false zurück, je nachdem.
      Wenn sie nicht gelöscht werden konnte, dann vermutlich weil sie nicht existierte. ]]
      avalet.log("Stopwatch gelöscht: "..tostring(deleteStopWatch(stopWatchName)), 2)

      avalet.log("Lösche Eintrag in Tabelle 'fights'", 2)
      self.removeFight(stopWatchName)

      --[[
      Bei einem "one strike"-Kill (also ein Kill ohne vorher existierender StopWatch)
      muss noch aufgeräumt werden. ]]
      if not kampf then raiseEvent("AvalonKampf", "0") end

    end    

    local opp = avalet.char.getRoomInv(opponentID) 
    avalet.log("Getötet: "..opp["name"].." ("..opponentID..") nach "..thisFightDuration.." Sekunden.", 2)

    --[[
    Hier wird ein ATCP-Event simuliert, der sonst durch eintreffende Channel-Kommunikation
    ausgelöst wird. Also wenn jemand labert, redet etc. Hier wird der Channel "Console"
    angesprochen, den es in Avalon nicht gibt. Im Ergebnis wird der String in die Datei 
    "Console.txt" im log-Verzeichnis des Profils geschrieben.
    Sollte ich das noch implementieren, kann der String aber auch in einem entsprechenden
    Tab im Chat-Bereich ausgegeben werden. ]]
    raiseEvent("AvalonChannel", "Console Getötet: "..opponentID.." nach "..thisFightDuration.." Sekunden.")
  end
  
  --self.getGetoetet = function() return getoetet end
  self.setGetoetet = function(newGetoetet) 
    getoetet = newGetoetet
    avalet.log("ATCP-Getoetet: "..tostring(newGetoetet), 2) 
    gegnerGetoetet(getoetet, "char")
  end
  --self.getGruppeGetoetet = function() return gruppeGetoetet end
  self.setGruppeGetoetet = function(newGruppeGetoetet)
    gruppeGetoetet = newGruppeGetoetet 
    avalet.log("ATCP-GruppeGetoetet: "..tostring(newGetoetet), 2) 
    gegnerGetoetet(gruppeGetoetet, "gruppe")
  end
  --self.getAllyGetoetet = function() return allyGetoetet end
  self.setAllyGetoetet = function(newAllyGetoetet) 
    allyGetoetet = newAllyGetoetet 
    avalet.log("ATCP-AllyGetoetet: "..tostring(newGetoetet), 2) 
    gegnerGetoetet(allyGetoetet, "ally")
  end
  
 
  return self
  
end

--[[
 ]]
function avalet.initFight()
	avalet.log("Funktion avalet.initFight()", 1)

  return objFight.new()
  
end
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>test</name>
			<packageName></packageName>
			<script>--[[
Ich hatte Schwierigkeiten mit der fights-Liste und hab deshalb hier alle
Zugriffsmöglichkeiten mal durch-dekliniert. Bleibt bis ich sicher bin,
dass ich das jetzt im Griff hab. ]]
function avalet.test()

  test = test or {}
  
  -- angriffsliste
  fights = {}
  stopWatchName = nil
  battleTimerID = nil
  
  fights["1"] = {"gegnerID11", "gegnerID12", "gegnerID13", "gegnerID14"}
  table.insert(fights["1"], "gegnerID15")
  fights["2"] = {"gegnerID21", "gegnerID22", "gegnerID23", "gegnerID24", "gegnerID25"}
  --fights["1"] = nil
  
  
  fights["gegnerID21"] = {["gegnerID21"]="Schaf", ["gegnerID22"]=true, ["gegnerID23"]="Wolf", ["gegnerID24"]=true}
  fights["gegnerID21"]["gegnerID25"] = true
  fights["gegnerID21"]["gegnerID22"] = nil
  
  function test.addFight(arg1, arg2)
    local gegnerID = arg1
    local gegnerName = arg2 or true
    fights[gegnerID]={}
    fights[gegnerID][gegnerID]=gegnerName
  end
  
  function test.addGegnerToFight(arg1, arg2, arg3)
    local kampfID = arg1
    local gegnerID = arg2
    local gegnerName = arg3 or true
    fights[kampfID][gegnerID]=gegnerName
  end
  
  test.addFight("gegnerID31")
  test.addGegnerToFight("gegnerID31", "gegnerID32")
  test.addGegnerToFight("gegnerID31", "gegnerID33", "Wolf")
  test.addFight("gegnerID41", "Wolf")
  test.addGegnerToFight("gegnerID41", "gegnerID42", "Schaf")
  test.addGegnerToFight("gegnerID41", "gegnerID43")
  
  function test.removeOpponentFromFight(arg1, arg2)
    local fightID = arg1
    local gegnerIDToRemove = arg2
    fights[fightID][gegnerIDToRemove] = nil
    
    if table.is_empty(fights[fightID]) then
      cecho("&lt;magenta&gt;table '"..fightID.."' is_empty!\n")
    else 
      cecho("&lt;magenta&gt;table '"..fightID.."' IST NICHT empty!\n")
    end
  end
  
  function test.removeFight(arg)
    local fightID = arg
    if table.is_empty(fights[fightID]) then
      fights[fightID] = nil
      cecho("&lt;magenta&gt;Kampf gelöscht: "..fightID.."!\n")
    else
      cecho("&lt;magenta&gt;Kampf "..fightID.." nicht leer, nicht gelöscht!\n")
    end    
  end

  test.removeOpponentFromFight("gegnerID41", "gegnerID42")
  test.removeFight("gegnerID41")
  test.removeOpponentFromFight("gegnerID41", "gegnerID41")
  test.removeFight("gegnerID41")
  test.removeOpponentFromFight("gegnerID41", "gegnerID43")
  test.removeFight("gegnerID41")
  
  function test.getOpponentsFightID(arg)
    local gegnerID = arg
    for k, v in pairs(fights) do
      --cecho("&lt;magenta&gt;k: "..tostring(k).."\n")
      --cecho("&lt;magenta&gt;v: "..tostring(v).."\n")
      for i, j in pairs(v) do
        if i == gegnerID then 
          --cecho("&lt;magenta&gt;\ngefunden in: "..k.." (erwartet in: gegnerID31)\n")
          return k
        end
      end
    end
  end
  
  function test.updateGegnerName(arg1, arg2)
    local gegnerID = arg1
    local gegnerName = arg2
    --fights["gegnerID21"]["gegnerID25"] = true
    local fightID = test.getOpponentsFightID(gegnerID)

    fights[fightID][gegnerID] = gegnerName

  end
  
  test.updateGegnerName("gegnerID23", "Grummiente")
  
  display(fights)
  --cecho("\nGegner ist in Kampf: "..test.gegnerIsInFight("gegnerID33").."\n")
  cecho("&lt;magenta&gt;\nGegner gefunden in: "..test.gegnerIsInFight("gegnerID33").." (erwartet in: gegnerID31)\n")
 
  --[[
  angriff:
  
  - läuft eine stopWatch/ein kampf oder nicht? 
     ja: gegner hinzufügen
     nein: ist der gegner in einer gestoppten stopwatch?
       ja: stopwatch raussuchen und weiterlaufen lassen
       nein: gegner neu anlegen, stopwatch erzeugen und starten
  
  
  ]]
  
  
  
  
  
  
  
  
  
  
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>objMapper</name>
			<packageName></packageName>
			<script>--[[
Irgendwann müssen die Raum-/Map-bezogenen Daten vom Char-Objekt hierher
umziehen. Aber zur Zeit ist das hier nur ein Platzhalter. TODO ]]

local objMapper = {}

objMapper.new = function()

  local self = {}

  local varName = "varValue"
  
  local privateFunction = function(privFuncParam)
  
  end
  
  self.publicFunction = function()
  
  end
  
--[==[

  -- AvalonDunkel
  function avalet.atcp.onATCPEventAvalonDunkel(event, arg)
    avalet.log("AvalonDunkel = " .. tostring(arg), 1)
    --avalet.char.setIstDunkel(tostring(arg))
  end
  registerAnonymousEventHandler("AvalonDunkel", "avalet.atcp.onATCPEventAvalonDunkel")
  
  --[[
  ATCP.AvalonInstance kann man anfordern, und zwar mit 'sendATCP("ava_req_iid", "hier")'.
  (Ohne die ' vorne und hinten.) Was dann kommt ist eine verbeuelte RoomID: nur die ID,
  nicht der Name. Ich wollte immer mal fragen, ob das ein Bug ist, aber ... dann war
  der Tag immer schon um. TODO
  Angefordert wird AvalonInstance übrigens durch ein Alias auf "schau" oder durch die
  5 auf dem Ziffernblock. ]]
  function avalet.atcp.onATCPEventAvalonInstance(event, arg)
    avalet.log("AvalonInstance = " .. tostring(arg), 1)
    
    --[[
    Format:
    hier raum/193219d1cd6e2e81fbf8a116c22c0022 ""
  
    Hier kommt im Grunde eine "RoomID" an, nur mit einem führenden "hier ". Dieser Teil
    wird hier abgeschnitten, und dann wird der Rest einfach an die Funktion übergeben,
    die die RoomID sonst auch verarbeitet. Das ist die hier direkt drunter... ]]
    
    -- Erstmal das führende "hier " abtrennen
    arg = string.gsub(arg, "hier (.*)", "%1")
    
    --[[
    Dann so tun als ob per ATCP 'AvalonRoomID' eintrifft, dadurch übernimmt dann die
    richtige Funktion. (Und dort dann den Sonderfall "leerer Name" verarbeiten.) ]]
    raiseEvent("AvalonRoomID", arg)
  end
  registerAnonymousEventHandler("AvalonInstance", "avalet.atcp.onATCPEventAvalonInstance")
  
  
  -- AvalonRoomID
  function avalet.atcp.onATCPEventAvalonRoomID(event, arg)
    avalet.log("AvalonRoomID = " .. tostring(arg), 1)
    
    --[[
    Normalerweise enthält die RoomID auch einen Namen, also "Walhalla" oder sowas.
    Aber es gibt den Sonderfall, dass da kein Name ist. Warum das so ist, steht 
    weiter oben bei 'function avalet.atcp.onATCPEventAvalonInstance(event, arg)' ]]
  
    local str = string.gsub(arg, "^%S*%s+(.+)", "%1", 1)
    if str ~= '""' then 
      avalet.char.setAvalonRoomID(str)
    end
  
    str = string.gsub(arg, "^raum/(%S*)%s+.+", "%1", 1)
    avalet.char.setAvalonRoomHash(str)
    
    --[[
    Hierdurch wird RoomInv abgefragt. Das geschieht auch bei einem "schau", damit
    man im Kampf durch "schau" (oder durch die 5 auf dem Ziffernblock) ein aktuelles
    RoomInv bekommt. Das dann angezeigt wird und zum Beispiel Gegner bzw. Leichen und
    Loot und so zeigt. Und die anderen Chars aus der Gruppe ggf. ]]
    _ = sendATCP("ava_req_inv hier")
    
  end
  registerAnonymousEventHandler("AvalonRoomID", "avalet.atcp.onATCPEventAvalonRoomID")
  
  
  
  -- event == "AvalonRoomBrief"
  function avalet.atcp.onATCPEventAvalonRoomBrief(event, arg)
  	avalet.log("AvalonRoomBrief = " .. tostring(arg), 1)
  
  end
  registerAnonymousEventHandler("AvalonRoomBrief", "avalet.atcp.onATCPEventAvalonRoomBrief")
  
  
  -- AvalonArea
  function avalet.atcp.onATCPEventAvalonArea(event, arg)
  	avalet.log("AvalonArea = " .. tostring(arg), 1)
  
  end
  registerAnonymousEventHandler("AvalonArea", "avalet.atcp.onATCPEventAvalonArea")
  
  
  -- AvalonInv
  function avalet.atcp.onATCPEventAvalonInv(event, arg)
  	avalet.log("AvalonInv = " .. tostring(arg), 1)
    
    avalet.char.setAvalonRoomInv(arg)
  
  end
  registerAnonymousEventHandler("AvalonInv", "avalet.atcp.onATCPEventAvalonInv")
  
  
  -- AvalonSite
  function avalet.atcp.onATCPEventAvalonSite(event, arg)
  	avalet.log("AvalonSite = " .. tostring(arg), 1)
  
  end
  registerAnonymousEventHandler("AvalonSite", "avalet.atcp.onATCPEventAvalonSite")
  
  
  -- AvalonExits
  function avalet.atcp.onATCPEventAvalonExits(event, arg)
  	avalet.log("AvalonExits = " .. tostring(arg), 1)
  
  end
  registerAnonymousEventHandler("AvalonExits", "avalet.atcp.onATCPEventAvalonExits")
  
  
  -- AvalonAvalonWeg
  function avalet.atcp.onATCPEventAvalonAvalonWeg(event, arg)
  	avalet.log("AvalonAvalonWeg = " .. tostring(arg), 1)
  
  end
  registerAnonymousEventHandler("AvalonAvalonWeg", "avalet.atcp.onATCPEventAvalonAvalonWeg")
  
  
  -- AvalonAvalonIcon16
  function avalet.atcp.onATCPEventAvalonAvalonIcon16(event, arg)
  	avalet.log("AvalonAvalonWeg = " .. tostring(arg), 1)
  
  end
  registerAnonymousEventHandler("AvalonAvalonIcon16", "avalet.atcp.onATCPEventAvalonAvalonIcon16")

]==]  
  
  return self
  
end

--[[
 ]]
function avalet.initMapper()
	avalet.log("Funktion avalet.initMapper()", 1)

  return objMapper.new()
  
end
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>objObject</name>
			<packageName></packageName>
			<script>--[[
Dummy-Object, dann muss ich nicht immer googeln. ]]

local objObject = {}

objObject.new = function()

  local self = {}

  local privateVarName = "privateVarValue"
  self.publicVarName = "publicVarValue"
  
  local privateFunctionName = function(privFuncParam) 
    return 
  end

  self.publicFunctionName = function(publicFuncParam) 
    return 
  end
  
  return self
  
end

--[[
Funktion zum erzeugen des Objektes. Guter Platz für den Aufruf ist 
vielleicht der Install-Event. Aufruf per
avalet.object = avalet.initDummyObject()
(oder halt direkt).
anschließend können die public functions mit avalet.object.publicFunctionName()
und die public variables mit avalet.object.publicVarName angesprochen werden.]]
function avalet.initDummyObject()
	avalet.log("Funktion avalet.initDummyObject()", 1)

  return objObject.new()
  
end
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>initStatistics</name>
			<packageName></packageName>
			<script>--[[

Statistiken, Zähler, etc.

Idee: Tabelle mit functions, die alle als Rückgabewert den anzuzeigenden Text haben. ]]

avalet.statistics = avalet.statistics or {}


function avalet.initStatistics()
  avalet.log("Function avalet.initStatistics()", 1)
  
  
  --[[
  Zum Zähler "Schildzauber":
  Als "Schildzauber" zählen die Zauber, die in avalet.CONSTS.SCHILDZAUBER erfasst sind.
  Bedingungen stehen dort. Ausgelöst wird dieser Zähler durch die Timer, und zwar genauer
  unter "Model --&gt; createTimerModel" und da in der Funktion "avalet.registerTimer()".
  (Und beendet dann dort in "avalet.deregisterTimer()".) ]]
  
  avalet.statistics.counter = avalet.statistics.counter or {
    [1] = {
        ["name"] = "EP",
        ["isActive"] = function() return true end,
        ["func"] = function() return avalet.utilities.thousands(avalet.char.getEP()) end,
        ["last"] = function() return nil end},
    [2] = {
        ["name"] = "Session-EP",
        ["isActive"] = function() return true end,
        ["func"] = function() return avalet.utilities.thousands(avalet.char.getSessionEP()) end,
        ["last"] = function() return avalet.utilities.thousands(avalet.char.getLastSessionEP()) end},
    [3] = {
        ["name"] = "Bonusstunden-EP",
        ["isActive"] = function() return avalet.char.getBonusEPState() end,
        ["func"] = function() return avalet.utilities.thousands(avalet.char.getBonusEP()) end,
        ["last"] = function() return avalet.utilities.thousands(avalet.char.getLastBonusEP()) end},
    [4] = {
        ["name"] = "Schildzauber",
        ["isActive"] = function() return avalet.char.getSchildEPActivityState() end,
        ["func"] = function() return avalet.utilities.thousands(avalet.char.getSchildEP()) end,
        ["last"] = function() return avalet.utilities.thousands(avalet.char.getLastSchildEP()) end},
    [5] = {
        ["name"] = "Kampfdauer",
        ["isActive"] = function() return avalet.fight.getFightStatus() end,
        ["func"] = function() return avalet.fight.getFightDuration() end,
        ["last"] = function() return avalet.fight.getLastFightDuration() end},
    
    --[6] = {["name"] = "", ["func"] = ""},
    --[7] = {["name"] = "", ["func"] = ""},
    --[8] = {["name"] = "", ["func"] = ""},
    --[9] = {["name"] = "", ["func"] = ""},
  }
  
end
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>initTimer</name>
			<packageName></packageName>
			<script>--[[
Timer (und Trigger für Timer)

HINWEIS: Hier geht es um Timer und Trigger. Wenn hier von TRIGGERN geschrieben
wird, dann sind die normalen Mudlet-Trigger gemeint. (Die man sich als Spieler
anlegt, um nicht immer alles selber tippen zu müssen.) Wenn hier von TIMERN 
geschrieben wird, dann sind normalerweise die Timer gemeint, die auf der 
Oberfläche von Avalet angezeigt werden! Die die Laufzeit beispielsweise von 
Schutzzaubersprüchen anzeigen. Es sind NICHT die Mudlet-Timer gemeint!

Hier werden die Daten für die Trigger gesammelt, die letztlich die Timer auf 
der Oberfläche erzeugen sollen.
In den Funktionen weiter unten werden diese Trigger dann erzeugt. Es gibt (derzeit)
vier verschiedene Funktionen, die das tun. Benutzt wird nur eine davon, aber aus 
verschiedenen Gründen lasse ich die anderen drin. Und zwar:
Trigger können als "temporäre" oder als "permantente" Trigger angelegt werden.
"Temporäre" Trigger haben die Eigenschaft, dass sie nicht im Code-Editor (und auch
nicht in dieser Datei hier) auftauchen. Außerdem werden sie durch einen Neustart
von Mudlet gelöscht und neu erzeugt. Dadurch kann man sie leicht aktualisieren.
"Permantente" Trigger stehem in Code-Editor, und können so leichter kontrolliert
und beim Entwickeln von Avalet auch leichter modifiziert werden. Sie überstehen
aber einen Neustart von Mudlet, und da man sie auch nicht ohne weiteres per Lua
löschen kann, ist es sehr viel schwieriger, sie gegebenenfalls zu aktualisieren.
Ich habe Funktionen für beides geschrieben, weil ich zum Debuggen die permanenten
Trigger verwendet habe, für die ausgelieferte Version von Avalet dann aber wieder
auf die temporären Trigger umstelle.
Außerdem gibt es jeweils eine Funktion, bei der alle Trigger auf ein mal beim Start
von Mudlet bzw. bei der Installation von Avalet erzeugt werden. Also die Start- und
die Stop-Trigger für die einzelnen Timer. Und es gibt jeweils eine Funktion, bei der
NUR die Start-Trigger bei der Installation erzeugt werden. Die dazugehörigen STOP-
Trigger werden dann erzeugt, wenn der Start-Trigger ausgelöst wurde. Und dann werden
sie als ONE-TIME-Trigger angelegt, löschen sich also nach einmaligem Auslösen. Das
spart rund die Hälfte der Trigger - und da Trigger die ganze Zeit die Texte mitlesen
müssen, spart es Laufzeit. 
Es gibt also insgesamt vier Funktionen, mit denen die "Trigger für Timer" erzeugt werden.
Verwendet wird aber jeweils nur eine. Fürs debugging lass ich die anderen hier drin.
Außerdem: Die Trigger werden in eine Trigger-Group namens "AvaletTriggerFuerTimer"
geschrieben. Eigentlich kann man eine solche Group von Lua aus erzeugen und die Trigger
dann reinschreiben. Ich hatte dabei aber das Problem, dass die Trigger zwar alle 
richtig geschrieben wurden und auch aktiv waren. Die Trigger-Group war aber per default
deaktiviert. Wodurch auch die in ihr enthaltenen Trigger nicht funktionierten. Die
Trigger-Group war erst nach einem Speichern aktivierbar. Letztlich hab ich die Group
dann fest in Avalet reingeschrieben. Damit hat dann alles funktioniert. Also NICHT so:
permGroup("AvaletTriggerFuerTimer", "trigger") ]]

--[[
function avalonUI.initTimer()
Hier werden die Daten für die Timer gesammelt, aus denen die Trigger erzeugt werden. Und
am Ende dieser Funktion werden sie dann auch erzeugt.
Die Trigger werden entweder als temporäre oder als permanente Trigger erzeugt, aber in 
jedem Fall werden sie "RegexTrigger" sein - die Texte, auf denen die Trigger reagieren
sollen, müssen also reguläre Ausdrücke sein. 
Außerdem ist es notwendig, die Zeichen zur Maskierung von Sonderzeichen ("\") extra einmal
zu maskieren.
Anführungszeichen sind schwierig. Wenn man im Start-String welche hat, kann man die äußeren
gegen ' tauschen. Also: ["start"]='Start-RegExpr'. Die inneren müssen dann maskiert sein,
also: \\". Im stop-Teil funktioniert das aber nicht. Ich vermute, das liegt an der weiteren
Implementierung, also daran, wie die Stop-Timer erzeugt werden. Aber nachgesehen hab ich
nicht. Stattdessen verwende ich ".?" um Anführungszeichen zu finden. So lange das so
taugt.
Bei manchen Timern enthält der Name in der Anzeige die Bezeichnung des Gegenstandes, der 
verzaubert wurde. Beispiel ist der Kleriker-Waffensegen. Da mehrere Waffen parallel einen 
Waffensegen bekommen können, ist das notwendig, um die einzelnen Waffensegen voneinander 
zu unterscheiden. Wenn so eine Timer hinzugefügt werden soll, dann muss der gleichzeitig 
in den VIER(!) Funktionen weiter unten, mit denen die Timer erzeugt werden, ergänzt werden. 
In allen VIER! (Dieses Feature funktioniert nur so lala. Wenn zwei gleiche Waffen jeweils 
einen Waffensegen bekommen, dann kann Avalet da auch nichts mehr auseinanderhalten.)
Die Angabe einer ["duration"] kann entfallen, der Timer wird dann OHNE Fortschrittsanzeige
angezeigt, bis der Stop-Trigger ihn entfernt. (Also die ganze Zeit mit vollen Fortschritts-
balken.) In dem Fall ist UNBEDINGT sicher zu stellen, dass das Löschen des Timers auch
wirklich funktioniert! Die Trigger MIT Laufzeit werden ebenfalls durch einen STOP-Trigger
entfernt, zusätzlich aber auch (derzeit:) 30 Sekunde nach Ende ihrer eingetragenen Laufzeit.
Bei den Trigger MIT Laufzeit ist es also möglich, auf einen STOP-String zu verzichten. Der
muss in dem Fall aber trotzdem hier reingeschrieben werden, und zwar so: ["stop"] = ""
Beim Hinzufügen weiterer Zeilen bitte die alphabetische Sortierung berücksichtigen... 
(Ok, die alphabetische Sortierung ist mist, ich hab keine Ahnung was davon zu welcher
Gilde gehört. Aber jetzt ist das halt so. Also weiter alphabetisch.) 
An den Febronen-Timern ist besonders schwierig, dass man den Namen des Febrons braucht, 
und zwar einmal für die Beschriftung des Timers und dann aber auf jeden Fall um den richtigen 
Timer beenden zu können. Und der Name ist erst beim zaubern (evolieren oder so) bekannt. UND 
zusätzlich steht der Name sicher nur im ersten Text, also nichtmal in dem, durch den der 
Timer gestartet wird. Deshalb gibt es einen Trigger, der den Namen aus dem ersten Text 
zwischenspeichert. Und der Code, der durch den Start-Trigger ausgeführt wird (und der dann 
den Stop-Trigger erzeugt) liest diese Variable aus und setzt sie entsprechend ein. Und damit 
das für mich nicht so langweilig wird funktioniert das nur sehr begrenzt, so dass der Stop-
Trigger dann wieder den Namen des Febron aus dem auslösenden Text extrahieren und an den 
vom Stop-Trigger ausgeführten Code durchreichen muss. Auf komplizierte Weise. Und dann ist 
es auch noch möglich, alle Febronen mit einem einzigen Befehl wieder einzusammeln, was 
wieder ein Sonderfall darstellt. Kurz: Die Febronen-Angelegenheit hier ist ziemlicher Mist. 
Dagegen sind die Waffen der Daemonenkrieger direkt einfach gewesen. Und so sieht der Code 
auch aus. Leider funktioniert nur die Erzeugung von temporären Triggern sowohl für Start 
als auch für Stop mit den Febronen-Timern. ]]
function avalet.initTimer()
  
  local timerStrings = {
    --{["name"]="Name", ["start"]="Start-RegExpr",["stop"]="Stop-RegExpr", ["duration"]="600"},
    --{["name"]="Name", ["start"]="Start-RegExpr",["stop"]="", ["duration"]="600"},
    --{["name"]="Name", ["start"]="Start-RegExpr",["stop"]="Stop-RegExpr"},
    {["name"]="Angriffsfebron", ["start"]="^.*gegen Deine Feinde geruestet.*$", ["stop"]="(Du faengst vorsichtig (alle) Deine Febrone ein|Du faengst Dein Febron .?(febNamePlatzhalter).? ein|Dein Febron .?(febNamePlatzhalter).? ist vom ewigen Herumschwirren erschoepft\\.)", ["duration"]="780"}, 
    {["name"]="Arkanschild", ["start"]="Du wirst von einem Arkanschild umgeben\\.", ["stop"]="Dein Arkanschild loest sich auf\\.", ["duration"]="600"},
    {["name"]="Antimagie", ["start"]="Du hast eine Aura der Antimagie erschaffen\\.", ["stop"]="Die Aura der Antimagie loest sich auf\\.", ["duration"]="60"},
    --{["name"]="Baumwaechter", ["start"]="", ["stop"]="", ["duration"]="1800"},  
    {["name"]="Blaetterhaut", ["start"]="Deine Blaetterhaut sieht nun wieder frischer aus\\.|Deine Haut ist nun mit Blaettern bedeckt, die Dir ein angenehmes Klima|Deine Holzhaut ist nun mit Blaettern bedeckt, die Dir ein angenehmes Klima", ["stop"]="Deine Blaetterhaut loest sich auf\\.", ["duration"]="1800"},  
    {["name"]="Blumenkind", ["start"]="Mit einem Laecheln beendest Du das Ritual\\. Ueberall um Dich wachsen", ["stop"]="Die Blumen fallen von Dir ab\\.", ["duration"]="1800"},  
    {["name"]="Blutrausch", ["start"]="Du laesst einen fuerchterlichen Urschrei von Dir. Es scheint so, als .*", ["stop"]="Die roetlichen Manawolken loesen sich auf\\.", ["duration"]="600"},
    {["name"]="Daemonenhaut", ["start"]="Du bist nun vollkommen in eine Daemonenhaut eingehuellt\\.", ["stop"]="Deine Daemonenhaut loest sich auf\\.", ["duration"]="600"},
    {["name"]="Daemonenschutz", ["start"]="Der Bullrik ist bereit, die Dir geltenden Schlaege, abzufangen\\.",["stop"]="Der Bullrik .* hoert auf Dich zu beschuetzen\\.", ["duration"]="600"},
    {["name"]="Daemonenschwert", ["start"]="Vorsichtig streifst Du mit Deiner Hand ueber (Deinen|Deine|Dein|den)([a-z ,]*)(([A-Za-z\\s]+)\\.)?", ["stop"]="Dein \\w+ verliert seine magische Kraft\\.", ["duration"]="600"},
    {["name"]="Defensivfebron", ["start"]="^.*(Attacken Deiner Gegner|Er wird Dich vor Schlaegen|Schlaegen warnen\\.).*$", ["stop"]="(Du faengst vorsichtig (alle) Deine Febrone ein|Du faengst Dein Febron .?(febNamePlatzhalter).? ein|Dein Defensivfebron .?(febNamePlatzhalter).? ist vom Kampf erschoepft\\.)", ["duration"]="840"}, 
    --{["name"]="Egelschreck", ["start"]="", ["stop"]="", ["duration"]="1800"},  
    {["name"]="Einstimmung", ["start"]="Du hast Dich nun vollends auf .* eingestimmt\\.", ["stop"]="Du (verlierst|beendest) Deine Einstimmung.*\\.", ["duration"]="600"},
    {["name"]="EngelBeschwoeren", ["start"]="Dein Ankh blitzt kurz auf und ein Racheengel erhebt sich\\.", ["stop"]="Der Racheengel verschwindet in einer grellen Lichtsaeule\\."},
    {["name"]="Erdaura", ["start"]="Du hebst Deine Haende, beschreibst einen Halbkreis.*|Die Partikel verdichten sich um Dich\\.", ["stop"]="Dein Staubschleier loest sich auf\\.", ["duration"]="600"},
    {["name"]="EP-Verdoppelung", ["start"]="^Du bekommst nun eine Zeit lang erhoehte Erfahrung\\.$", ["stop"]="", ["duration"]="3600"},
    {["name"]="Feueraura", ["start"]="Du senkst Deine Haende, aber der Schutz der Manawolken.*", ["stop"]="Deine Feueraura loest sich auf\\.", ["duration"]="600"},
    {["name"]="Feueraura III", ["start"]="Die Manawolken verdichten sich um Dich\\.", ["stop"]="Deine Feueraura loest sich auf\\.", ["duration"]="1200"},
    {["name"]="Finsternis", ["start"]="Die Wolkendecke verdunkelt die Sonne nun vollstaendig.*", ["stop"]="Die Wolkendecke zieht wieder auf und es wird heller\\.", ["duration"]="300"},
    {["name"]="Friedfertigkeit", ["start"]="Du fuehlst Dich nun .* friedfertig\\.", ["stop"]="Du fuehlst Dich wieder kaempferischer, ungestuemer\\.", ["duration"]="1800"},
    {["name"]="Fuehrungsfebron", ["start"]="^.*zu leiten, dass sie ihre Aufgaben.*$", ["stop"]="(Du faengst vorsichtig (alle) Deine Febrone ein|Du faengst Dein Febron .?(febNamePlatzhalter).? ein|Dein Fuehrungsfebron .?(febNamePlatzhalter).? ist vom Kampf erschoepft\\.)", ["duration"]="1680"}, 
    {["name"]="Gedankenpeitsche", ["start"]="Du spuerst, wie sich Deine Daemonen ihrem Schicksal hingeben\\.",["stop"]="", ["duration"]="600"},
    {["name"]="GoettlicheFuehrung", ["start"]="Deine Schlaege werden von einem Gott gefuehrt\\.", ["stop"]="Deine goettliche Fuehrung schwindet\\.", ["duration"]="600"},
    --{["name"]="Heilende Hand", ["start"]="", ["stop"]="", ["duration"]="960"},  
    {["name"]="Holzhaut", ["start"]="Deine Haut sieht nun hoelzern und sehr widerstandsfaehig aus\\.|Deine Blaetterhaut sieht nun hoelzern und sehr widerstandsfaehig aus\\.|Deine Blaetterhaut fuehlt sich nun recht hoelzern an\\.|Deine Haut fuehlt sich nun recht hoelzern an\\.|Deine Holzhaut sieht nun wieder frischer aus\\.", ["stop"]="Deine Holzhaut loest sich auf\\.", ["duration"]="1800"},
    --{["name"]="Immunitaet", ["start"]="", ["stop"]="", ["duration"]="1800"},  
    {["name"]="Kampfbeschwoerung", ["start"]="Du wirst von einer heiligen Aura umgeben\\.",["stop"]="Deine heilige Aura loest sich auf\\.", ["duration"]="600"},
    {["name"]="Kampfeslust", ["start"]="Du fragst Dich, wo der naechste Gegner ist, mit dem Du Dich messen koenntest\\.|Du bekommst so langsam richtig Lust auf ein kleines Kraeftemessen\\.", ["stop"]="Du fuehlst Dich wieder ruhiger, besonnener\\.", ["duration"]="1800"},
    {["name"]="Kampfsegen", ["start"]="Du bist motiviert und willig zu kaempfen\\.", ["stop"]="Deine Motivation und Dein Kampfeswille schwinden\\.", ["duration"]="600"},
    {["name"]="Kernschild", ["start"]="Das Glitzern legt sich als schuetzendes Schild ueber Dich\\.", ["stop"]="Dein Kernschild loest sich auf\\.", ["duration"]="1000"},
    --{["name"]="Kesselzwang", ["start"]="", ["stop"]="", ["duration"]="1800"},  
    {["name"]="Knochenschild", ["start"]="Du erhebst Dich wieder, der wirbelnde Schild aus Knochen umgibt Dich", ["stop"]="Deine schuetzende Knochenwolke loest sich auf\\.", ["duration"]="600"},
    --{["name"]="Leben finden", ["start"]="", ["stop"]="", ["duration"]="1800"},  
    {["name"]="Lebensaura", ["start"]="Du oeffnest die Augen, aber der Schutz der Bluetenblaetter umgibt Dich", ["stop"]="Deine Lebensaura loest sich auf\\.", ["duration"]="600"},
    {["name"]="Lebenshaar", ["start"]="Du beendest das Ritual\\. Ueberall auf Dir wachsen nun kurze, weisse Haare\\.", ["stop"]="Dein Lebenshaar loest sich auf\\.", ["duration"]="1800"},  
    {["name"]="Lebenssegen", ["start"]="Du wirst von einem inneren Leuchten erfuellt\\.", ["stop"]="Dein inneres Leuchten erlischt wieder\\.", ["duration"]="600"},
    {["name"]="Licht I", ["start"]="Du erzeugst Dir eine kleine Feuerkugel\\.", ["stop"]="Deine Feuerkugel erlischt\\.", ["duration"]="240"},
    {["name"]="Licht II", ["start"]="Du erzeugst Dir eine kleine Leuchtflamme\\.",["stop"]="Deine Leuchtflamme erlischt\\.", ["duration"]="600"},
    {["name"]="Licht III", ["start"]="Ein grosser Lichtbogen breitet sich ueber Deinem Kopf aus\\.", ["stop"]="Dein Lichtbogen verschwindet\\.", ["duration"]="1200"},
    {["name"]="Luftaura", ["start"]="Du bist in den Watteflocken kaum noch auszumachen\\.", ["stop"]="Deine Watteflocken loesen sich auf\\.", ["duration"]="600"},
    {["name"]="Magieaufladung", ["start"]="Du hast einen Teil Deiner regenerativen Energien in Deine Zauber umgelenkt\\.",["stop"]="Deine Energien fliessen wieder normal\\.", ["duration"]="600"},
    {["name"]="Magiertrance", ["start"]="^Die Welt um Dich herum verliert an Bedeutung. Nur noch Deine Zauber sind$",["stop"]="Du erwachst aus Deiner Trance\\.", ["duration"]="600"},
    {["name"]="Manarausch", ["start"]="Dichte Manawolken bilden nun einen gewaltigen Schutz um Dich herum\\.",["stop"]="Dein Manarausch laesst wieder nach\\."},
    --{["name"]="Narbenheilung", ["start"]="", ["stop"]="", ["duration"]="1800"},  
    {["name"]="Offensivfebron", ["start"]="^.*(zu staerkeren Attacken anzufeuern\\.|Er wird Dich nun staerker|staerker zuschlagen lassen\\.).*$", ["stop"]="(Du faengst vorsichtig (alle) Deine Febrone ein|Du faengst Dein Febron .?(febNamePlatzhalter).? ein|Dein Offensivfebron .?(febNamePlatzhalter).? ist vom Kampf erschoepft\\.)", ["duration"]="840"}, 
    {["name"]="Pflanzenblick", ["start"]="Du siehst die Pflanzen um Dich herum jetzt viel klarer\\.", ["stop"]="Dein besonderer Blick fuer die Pflanzen an Deinem Weg verschwindet wieder\\.", ["duration"]="720"},
    --{["name"]="Puffpilz", ["start"]="", ["stop"]="", ["duration"]="1800"},  
    {["name"]="Regenerationssegen", ["start"]="Du wirst von einem warmen Leuchten umgeben\\.", ["stop"]="Das Dich umgebende Leuchten erlischt wieder\\.", ["duration"]="600"},
    {["name"]="Ruestungsverstaerkung", ["start"]="Erfolgreich hast Du Deinen Daemon in Deine Ruestung gebannt\\.",["stop"]="(.* loest sich von Deiner Ruestung\\.|Daemon aus Deiner Ruestung zu erloesen\\.)", ["duration"]="600"},
    {["name"]="Schild", ["start"]="Du wirst von einem magischen Schild umgeben\\.",["stop"]="Dein magischer Schild loest sich auf\\.", ["duration"]="600"},
    {["name"]="Schutzfebron", ["start"]="Dein Febron .?([A-Za-z\\s]+).? fliegt um Dich herum und bildet einen.*", ["stop"]="(Du faengst vorsichtig (alle) Deine Febrone ein|Du faengst Dein Febron .?(febNamePlatzhalter).? ein|Dein Schutzfebron .?(febNamePlatzhalter).? ist vom Kampf erschoepft\\.)", ["duration"]="840"}, 
    {["name"]="Schwarzschild", ["start"]="Du wirst von einem magischen Schild umgeben, der Dich besser parieren",["stop"]="Dein Schwarzschild loest sich auf\\.", ["duration"]="600"},
    {["name"]="Segen", ["start"]="^Das Ankh auf (Deiner|Deinem|den)([a-z ,]*)([A-Za-z\\s]+) beginnt\\, schwach zu( leuchten\\.)?", ["stop"]="(Dein|Deine)([a-z ,]*)([A-z\\s]+) verliert .* magische Kraft\\.", ["duration"]="600"},
    {["name"]="Steinhaut", ["start"]="Du bist nun vollkommen in eine Steinhaut eingehuellt, .*",["stop"]=".*Du befreist Dich von Deiner Steinhaut.*|.*Deine Steinhaut loest sich auf.*|Das hat Deiner Steinhaut den letzten Rest gegeben, sie loest sich auf\\.", ["duration"]="1800"},
    {["name"]="Sternenstaub", ["start"]="Du wirst von Sternenstaub umgeben\\.",["stop"]="Dein Sternenstaub loest sich auf\\.", ["duration"]="600"},
    {["name"]="Stressfebron", ["start"]=".*(Er beginnt bereits Dich zu nerven|hast.? beginnt .?([A-Za-z\\s]+).? Dich nun).*", ["stop"]="(Du faengst vorsichtig (alle) Deine Febrone ein|Du faengst Dein Febron .?(febNamePlatzhalter).? ein|Dein Stressfebron .?(febNamePlatzhalter).? ist vom Kampf erschoepft\\.)", ["duration"]="840"}, 
    {["name"]="Todesaura", ["start"]="Du senkst Deine Haende, aber der Schutz der schwarzen Schleier.*|Die schwarzen Schleier verdichten sich um Dich\\.",["stop"]="Deine Todesaura loest sich auf\\.", ["duration"]="600"},
    {["name"]="Todeshaar", ["start"]="Du beendest das Ritual\\. Ueberall auf Dir wachsen nun kurze, schwarze Haare\\.", ["stop"]="Dein Todeshaar loest sich auf\\.", ["duration"]="1800"},  
    {["name"]="Todkonvertieren", ["start"]="Du wirst von einem heiligen Schutz umgeben\\.", ["stop"]="Dein heiliger Schutz loest sich auf\\.", ["duration"]="600"},
    {["name"]="Trotz", ["start"]="Du hast nun verbesserte Verteidigungsfertigkeiten\\.", ["stop"]="Deine verbesserten Verteidigungsfertigkeiten schwinden\\.", ["duration"]="600"},
    {["name"]="Vergeltung", ["start"]="Du oeffnest Deine Augen und buendelst Deine Wut\\.", ["stop"]="Die Wut in Dir scheint besiegt\\."},
    {["name"]="Verschmelzung", ["start"]="^Kurz bevor Du die Kontrolle ueber Dich verlierst, rammst Du Dir instinktiv$", ["stop"]="^Der .* loest sich von Dir und Du nimmst wieder Dein urspruengliches$", ["duration"]="600"},
    {["name"]="Waffenleben", ["start"]="^Mit einem Laecheln beendest Du das Ritual\\. (Der|Die|Das)([a-z ,]*)([A-Za-z\\s]+) (ist|sind)( nun)?", ["stop"]="Das Leben in (Deinem|Deinen|Deiner)([a-z ,]*)([A-z\\s]+) zieht sich wieder zurueck\\.", ["duration"]="1800"},  
    {["name"]="Waffenverstaerkung", ["start"]="Erfolgreich hast Du Deinen Daemon in Dein\\S* (?!Ruestung).* gebannt\\.",["stop"]="(.* loest sich von Deine\\S* (?!Ruestung).*\\.|Daemon aus Deiner Waffe zu erloesen\\.)", ["duration"]="600"},
    {["name"]="Wasseraura", ["start"]="Es regnet aus der Wolke auf Dich herab.*",["stop"]="Dein Wasserschleier loest sich auf\\.", ["duration"]="600"},
    {["name"]="Weissschild", ["start"]="Du wirst von einem magischen Schild umgeben, der Dich Deinen Gegner .*", ["stop"]="Dein Weissschild loest sich auf\\.", ["duration"]="600"},
    {["name"]="Windhaut", ["start"]="Du bist nun vollkommen in eine Windhaut eingehuellt\\.",["stop"]="Du befreist Dich von Deiner Windhaut\\.|Deine Windhaut loest sich auf\\.", ["duration"]="600"},
    {["name"]="Zauberwaffe", ["start"]="Du uebertraegst die Energie auf (Dein|Deine|Deinen|den)([a-z ,]*)([A-Za-z\\s]+)\\.",["stop"]="(Der|Die|Das|Dein|Deine) ([a-z ,]*)([A-Za-z\\s]+) verliert [a-z]* Energie\\.", ["duration"]="600"},
    {["name"]="Zorn", ["start"]="Du wirst von kuehlen Winden umgeben\\.", ["stop"]="Die kuehlen Winde, welche Dich umgeben, verschwinden\\.", ["duration"]="600"},
    {["name"]="Orktal - Vorbereitung", ["start"]="\\| einmal zum Angriff blasen.                            \\|", ["stop"]="\\| zweimal zum Angriff blasen.                           \\|", ["duration"]="900"},
    {["name"]="Orktal - Angriff 1 von 3", ["start"]="\\| zweimal zum Angriff blasen.                           \\|", ["stop"]="\\| dreimal zum Angriff blasen.                           \\|", ["duration"]="600"},
    {["name"]="Orktal - Angriff 2 von 3", ["start"]="\\| dreimal zum Angriff blasen.                           \\|", ["stop"]="\\| viermal zum Angriff blasen.                           \\|", ["duration"]="600"},
    {["name"]="Orktal - Angriff 3 von 3", ["start"]="\\| viermal zum Angriff blasen.                           \\|", ["stop"]="\\| Freudenschreie ertoenen aus dem Dorf im Sueden als    \\|", ["duration"]="900"},
  }
 
  --[[
  Jetzt müssen die Timer-Trigger noch erzeugt werden. Dafür gibt es, wie weiter
  oben beschrieben, vier Möglichkeiten:
  1) erzeugt alle Start- und alle Stop-Trigger als temporäre Trigger: ]]
  --avalonUI.createTempTimer(timerStrings)
  --[[
  2) erzeugt alle START-Trigger als temporäre Trigger. Die STOP-Trigger werden 
     vom jeweiligen START-Trigger erzeugt, und zwar als ONE-TIME temp. Trigger: ]]
  avalet.createImprovedTempTimer(timerStrings)
  --[[
  3) erzeugt alle Start- und alle Stop-Trigger als permante Trigger: ]]
  --avalonUI.createPermTimer(timerStrings)
  --[[
  4) erzeugt alle Start-Trigger als permanente Trigger. Die STOP-Trigger werden
     vom jeweiligen START-Trigger erzeugt, und zwar als ONE-TIME-temp.(!) Trigger: ]]
  --avalonUI.createMixedTimer(timerStrings)

end -- function avalonUI.initTimer()



--[[
function avalonUI.createTempTimer(timerStrings)
Hier werden die Start- UND die Stop-Trigger als TEMPORÄRE Trigger erzeugt 
FUNKTIONIERT NICHT MIT DEN FEBRON-TIMERN! ]]
function avalet.createTempTimer(timerStrings)

  for _, v in pairs(timerStrings) do
  
    if v["duration"] == nil then
      v["duration"] = "false"
    end

    local param = ""
    local luaCode = ""
    --[[
    Bei bestimmten Zaubern werden Begriffe aus dem auslösenden Text verwendet, um den
    Namen für den Timer zu bauen. Hier wird der dafür notwendige Parameter gesetzt.
    (Beim Stop-Trigger dann das Gegenstück, damit der richtige Timer gelöscht wird.) ]]
    if v["name"] == "Segen" then param = ", matches[4]" end
    if v["name"] == "Zauberwaffe" then param = ", matches[4]" end
    if v["name"] == "Waffenleben" then param = ", matches[4]" end
    if v["name"] == "Schutzfebron" then param = ", matches[2]" end

    -- START-Trigger:
    luaCode = [[avalet.registerTimer("]]..v["name"]..[[", "]]..v["duration"]..[["]]..param..[[)]]
    tempRegexTrigger(v["start"], luaCode)
    
    -- STOP-Trigger (nur bei Bedarf):
    if v["stop"] ~= "" then
      luaCode = [[avalet.deregisterTimer("]]..v["name"]..[["]]..param..[[)]]
      tempRegexTrigger(v["stop"], luaCode)
    end
  end -- for
end


--[[
function avalonUI.createImprovedTempTimer(timerStrings)
Hier werden die START-Trigger als temporäre Trigger erzeugt. Und zwar so,
dass sie sich beim Auslösen ihren eigenen temporären One-Time-STOP-Trigger
erzeugen ]]
function avalet.createImprovedTempTimer(timerStrings)
  avalet.log("Function avalet.createImprovedTempTimer(timerStrings)", 1)
  --[=[
  Beispiel für einen Timer-Trigger, der sich seinen eigenen Timer-Ende-Trigger setzt:
  permRegexTrigger("Flamme", "AvaletTriggerFuerTimer", {"^Flamme an!$"}, [[registerTimer("Flamme", "60"); tempRegexTrigger("^Flamme aus!$", function() removeTimer("Flamme") end, 1)]])
  Nur der Timer-Ende-Trigger:
  tempRegexTrigger("^Flamme aus!$", function() removeTimer("Flamme") end, 1)
  ]=]
  for _, v in pairs(timerStrings) do

    if v["duration"] == nil then
      v["duration"] = "false"
    end

    local param = ""
    local stopTimer = ""
    local luaCode = ""
    --[[
    Bei bestimmten Zaubern werden Begriffe aus dem auslösenden Text verwendet, 
    um den Namen für den Timer zu bauen. Und zwar ist das bei den Kleriker-
    Segen der Fall, weil die anders nicht zu unterscheiden sind. Hier wird der 
    dafür notwendige Parameter gesetzt. (Beim Stop-Trigger dann das Gegenstück,
    damit der richtige Timer gelöscht wird.) 
    Notiz fuer mich: das Komma wird hier beim 'param' absichtlich (mehrfach) 
    hinzugefuegt, und nicht einmalig erst beim Zusammenbau des endgueltigen 
    Strings. Also versuch nicht schlauer zu sein als du selbst und das 
    'schoener' zu machen! Danke schonmal. ]]
    if v["name"] == "Segen" then param = ", matches[4]" end
    if v["name"] == "Zauberwaffe" then param = ", matches[4]" end
    if v["name"] == "Waffenleben" then param = ", matches[4]" end
    
    --[[
    Um die Febronen-Timer sicher beenden zu können muss der Stop-Trigger den Namen 
    des Febron enthalten. Der Name ist aber erst in dem Moment bekannt, wenn der 
    Start-Trigger den Stop-Trigger erzeugt. Dann steht er in avalet.timerModel.hyrasFebronName.
    Und weil diese temporaeren Trigger offenbar einen eigenen Namensraum haben wird hier
    eine Variable eingefuegt und weiter unten dann wie die Variable gesetzt wird. 
    Das Komma wird hier absichtlich schon hinzugefügt, weil da sonst am Ende ein 'nil' 
    als Parameter an eine Funktion übergeben werden würde, was nicht geht. ]]
    if (string.find(v["name"], "febron") ~= nil) then
      param = ", hyrasFebronName"
      v["stop"] = v["stop"]:gsub("febNamePlatzhalter", "\"..hyrasFebronName..\"")
    end
    
    --[[
    Wenn eine Stop-RegExpr existiert, wird beim Ausloesen des Triggers ein temporaerer 
    One-Time-Stop-Trigger gesetzt. ]]
    if v["stop"] ~= nil and v["stop"] ~= "" then
      --[[Die Sonderzeichen in der RegExp, die den Stop-Timer ausloesen soll, muss 
      einmal extra maskiert werden, weil sie einmal haeufiger verarbeitet werden. ]]
      v["stop"] = string.gsub(v["stop"], [[\]], [[\\]])
      stopTimer = [[tempRegexTrigger("]]..v["stop"]..[[", function() avalet.deregisterTimer("]]..v["name"]..[["]]..param..[[) end, 1)]]
      if (string.find(v["name"], "febron") ~= nil) then
        --[[ Damit die Stop-Timer bei den Febronen auch den richtigen Timer beenden, 
        muessen sie den Namen des Febronen aus dem ausloesenden Text entnehmen. Dafuer
        wird hier der Code noch an den Anfang der Code-Sektion gesetzt. Je nachdem mit 
        welchem Befehl der Febrone eingesammelt wird steht dieser Name dann in matches[]
        3, 4 oder 5. Die anderen beiden sind in dem Fall leere Strings oder nil. ]]
        stopTimer = string.gsub(stopTimer, "function%(%)", [[function() local hyrasFebronName; if (matches[3] and matches[3] ~= "") then hyrasFebronName = matches[3] elseif (matches[4] and matches[4] ~= "") then hyrasFebronName = matches[4] elseif (matches[5] and matches[5] ~= "") then hyrasFebronName = matches[5] end;]])
      end
    end

    -- Zusammenbau und Erzeugen des temporären Triggers:
    luaCode = [[avalet.registerTimer("]]..v["name"]..[[", "]]..v["duration"]..[["]]..param..[[); ]] .. stopTimer
    if (string.find(v["name"], "febron") ~= nil) then
      --[[ Hier wird der Code-Sektion des Start-Triggers eine Zeile hinzugefuegt, die 
      eine Variable ausliest, die beim Start des Febronen-Start-Zaubers belegt wurde. 
      Die lokale Variable wird dann beim Erzeugen des Stop-Timers verwendet, so dass 
      dieser auf den Namen des Febronen reagieren kann. ]]
      luaCode = "local hyrasFebronName = avalet.timerModel.hyrasFebronName; "..luaCode
    end
    avalet.log("Erzeuge Start-Trigger fuer Timer: "..v["name"], 2)
    --cecho("&lt;magenta&gt;\n\ntempRegexTrigger([["..v["start"].."]], [["..luaCode.."]])\n\n")
    tempRegexTrigger(v["start"], luaCode)
      
  end -- for  
end -- avalet.createImprovedTempTimer(timerStrings)



--[[
function avalonUI.createPermTimer(timerStrings)
Hier werden die Start- UND die Stop-Trigger als PERMANENTE Trigger erzeugt
Wenn diese permanenten Trigger von mir beim Entwickeln erzeugt werden, schreibt Mudlet
sie in diese Datei, also in den Code, und speichert sie. Dann würde ich die Datei packen
und als Modul ausliefern und die Trigger wären fest eincodiert. Wenn ich dran denken
würde, die Trigger vor dem Ausliefern immer zu löschen, könnte ich die permantenten Trigger
trotzdem verwenden. Denn dann würden sie zwar auch bei der Installation von Avalet erzeugt
werden. Da Mudlet aber nicht in ein gepacktes Modul schreiben kann, wären sie nach Programm-
ende wieder gelöscht. Und mit der Abfrage, ob sie existieren, würden sie dann beim Programm-
START wieder neu erzeugt werden. Aber da ich da nicht dran denken werde, benutze ich statt
dessen die temporären Trigger. (Und die permanenten Trigger zur zum Debuggen.)
Sollte sich dieser Vorbehalt mal ändern, warum auch immer, dann wäre es vielleicht
besser, die START-Trigger als permanente Trigger auszulegen, die STOP-Trigger dann als 
temporäre. Wie in der Funktion "avalonUI.createMixedTimer()"
FUNKTIONIERT NICHT MIT DEN FEBRON-TIMERN! ]]
function avalet.createPermTimer(timerStrings)

  -- Erzeugt eine sortierte Liste von Triggern. Weil es einfach schöner ist, wenn man die
  -- Liste im Code-Editor von Mudlet sieht. Ist bei temporäten Triggern ja unnötig.
  local sortTimerStrings = function (a, b) return a["name"] &lt; b["name"] end
  table.sort(timerStrings, sortTimerStrings)

  for _, v in pairs(timerStrings) do

    -- Trigger nur erzeugen, wenn sie nicht schon existieren:  
    if not exists(v["name"].."Start", "trigger") then

      if v["duration"] == nil then
        v["duration"] = "false"
      end

      local param = ""
      local luaCode = ""
      --[[
      Bei bestimmten Zaubern werden Begriffe aus dem auslösenden Text verwendet, um den
      Namen für den Timer zu bauen. Und zwar ist das bei den Kleriker-Segen der Fall,
      weil die anders nicht zu unterscheiden sind. Hier wird der dafür notwendige Parameter gesetzt.
      (Beim Stop-Trigger dann das Gegenstück, damit der richtige Timer gelöscht wird.) ]]
      if v["name"] == "Segen" then param = ", matches[4]" end
      if v["name"] == "Zauberwaffe" then param = ", matches[4]" end
      if v["name"] == "Waffenleben" then param = ", matches[4]" end
      if v["name"] == "Schutzfebron" then param = ", matches[2]" end
      
      -- Zusammenbau und Erzeugen des START-Triggers als permanter Trigger:
      luaCode = [[avalet.registerTimer("]]..v["name"]..[[", "]]..v["duration"]..[["]]..param..[[)]]
      permRegexTrigger(v["name"].."Start", "AvaletTriggerFuerTimer", {v["start"]}, luaCode)
    end -- if exists
      
    -- Nur bei Bedarf und wenn er nicht schon existiert: der STOP-Trigger:
    if not exists(v["name"].."Stop", "trigger") and v["stop"] ~= "" then
      -- Zusammenbau und Erzeugen des STOP-Triggers als permanenter Trigger:
      luaCode = [[avalet.deregisterTimer("]]..v["name"]..[["]]..param..[[)]]
      	permRegexTrigger(v["name"].."Stop", "AvaletTriggerFuerTimer", {v["stop"]}, luaCode)
    end -- if exists
  end -- for
end --function avalonUI.createPermTimer(timerStrings)



--[[
function avalonUI.createMixedTimer(timerStrings)
Hier werden die START-Trigger als PERMANENTE Trigger erzeugt. Und zwar so,
dass sie sich beim Auslösen ihren eigenen TEMPORÄREN One-Time-STOP-Trigger
erzeugen
Siehe auch Kommentar zur vorherigen Funktion (createPermTimer())
FUNKTIONIERT NICHT MIT DEN FEBRON-TIMERN! ]]
function avalet.createMixedTimer(timerStrings)
  --[=[
  Beispiel für einen Timer-Trigger, der sich seinen eigenen Timer-Ende-Trigger setzt:
  permRegexTrigger("Flamme", "AvaletTriggerFuerTimer", {"^Flamme an!$"}, [[registerTimer("Flamme", "60"); tempRegexTrigger("^Flamme aus!$", function() removeTimer("Flamme") end, 1)]])
  Nur der Timer-Ende-Trigger:
  tempRegexTrigger("^Flamme aus!$", function() removeTimer("Flamme") end, 1)
  ]=]
  
  --[[
  Erzeugt eine sortierte Liste von Triggern. Weil es einfach schöner ist, wenn man die
  Liste im Code-Editor von Mudlet sieht. Ist bei temporäten Triggern ja unnötig. ]]
  local sortTimerStrings = function (a, b) return a["name"] &lt; b["name"] end
  table.sort(timerStrings, sortTimerStrings)

  for _, v in pairs(timerStrings) do

    --[[
    Eigentlich wäre es sinnvoll, der Trigger würde gelöscht werden, wenn er schon existiert.
    Weil man nur so ein Update der zu triggernden Texte machen kann. Geht aber nicht. Die
    Mudlet-Funktion "killTrigger" kann nur temporäre Trigger löschen. (Evtl. könnte man hier
    über die Trigger-Group löschen, aber dann müsste man die neu erzeugen und das ging auch
    nicht. Siehe oben.) ]]
    if not exists(v["name"], "trigger") then

      if v["duration"] == nil then
        v["duration"] = "false"
      end

      local param = ""
      local stopTimer = ""
      local luaCode = ""
      --[[
      Bei bestimmten Zaubern werden Begriffe aus dem auslösenden Text verwendet, um den
      Namen für den Timer zu bauen. Und zwar ist das bei den Kleriker-Segen der Fall,
      weil die anders nicht zu unterscheiden sind. Hier wird der dafür notwendige Parameter gesetzt.
      (Beim Stop-Trigger dann das Gegenstück, damit der richtige Timer gelöscht wird.) ]]
      if v["name"] == "Segen" then param = ", matches[4]" end
      if v["name"] == "Zauberwaffe" then param = ", matches[4]" end
      if v["name"] == "Waffenleben" then param = ", matches[4]" end
      if v["name"] == "Schutzfebron" then param = ", matches[2]" end
    
      --[[
      Wenn eine Stop-RegExpr existiert, wird beim Auslösen des Triggers ein temporärer 
      One-Time-Stop-Trigger gesetzt. Da ich das folgende schon vor mehr als 20 Minuten 
      geschrieben habe, verstehe ich es jetzt selber nicht mehr. Aber die Ersetzung von 
      "\" durch "\\" muss sein, weil die einzelnen Maskierungen beim verarbeiten entfallen,
      also jeweils immer eine. Und weil beim Stop-Timer-Trigger eine Verarbeitung mehr 
      erfolgt als beim Start-Dings. ]]
      if v["stop"] ~= nil and v["stop"] ~= "" then
        stopTimer = [[; tempRegexTrigger("]]..string.gsub(v["stop"], [[\]], [[\\]])..[[", function() avalet.deregisterTimer("]]..v["name"]..[["]]..param..[[) end, 1)]]
      end
      
      --[[
      Zusammenbau und erzeugen des PERMANENTEN Start-Triggers, der sich einen eigenen 
      TEMPORÄREN Stop-Trigger erzeugt:       ]]
      luaCode = [[avalet.registerTimer("]]..v["name"]..[[", "]]..v["duration"]..[["]]..param..[[)]] .. stopTimer
      permRegexTrigger(v["name"], "AvaletTriggerFuerTimer", {v["start"]}, luaCode)

    end -- if not exists
      
  end -- for  
end -- function avalonUI.createMixedTimer(timerStrings)
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>CONSTANTS</name>
			<packageName></packageName>
			<script>--[[
Ein paar Konstante stehen auch unter "init". Und auch sonst hier und da. ]]

avalet.CONSTS = {}

avalet.CONSTS.LAYOUT = {
  ["NONE"] = 0,        -- Als letzter Ausweg wird einfach gar nichts angezeigt, nur nacktes Mudlet.
  ["MULTIVIEW"] = 1,   -- 1 Spalte (mitte), keine Chats, keine Char- und keine Guild-Infos
  ["REDUCED"] = 2,     -- 2 Spalten (links und mitte, NICHT rechts), keine Chats, keine Char- und keine Guild-Infos
  ["COMPACT"] = 3,     -- 2 Spalten (rechts und mitte, NICHT links), alle Elemente vorhanden
  ["FULL"] = 4,        -- 3 Spalten (links und rechts und mitte), alle Elemente vorhanden
}

--[[
Das hier sind die Zauber, für die als "Schildzauber" die EP gezählt werden.
(Bei den Statistics.) Voraussetzung ist, dass es einen Timer unter gleichem
Namen gibt! Bedingung ist, dass sich die Zauber hier gegenseitig ausschließen.
Da sonst der Zähler nicht weiß, was er zählen soll. (Also hier noch Steinhaut 
reinpacken, weil das ja auch irgendwie ein Schutzzauber ist, geht nicht.) ]]
avalet.CONSTS.SCHILDZAUBER = {
  ["Arkanschild"] = true,
  ["Weissschild"] = true,
  ["Schwarzschild"] = true,
  ["Kampfbeschwoerung"] = true,
  ["Schild"] = true,
  --[""] = true,
  --[""] = true,
  --[""] = true,
  --[""] = true,
}

--[[
Der Name des Tabs, auf dem mehrere Kanäle vereint werden. Konfigurierbar
im Kontextmenü. Warum ich den Namen hier gespeichert hab weiss ich nicht
mehr, aber war vermutlich begründet. Wird jedenfalls verwendet. ]]
avalet.CONSTS.SUMMING_TAB_NAME = "Sammeltab"

--[[
Liste der Kanäle, für die zur Zeit die Kommunikation gesammelt wird.
Aus dieser Liste kann der Spieler sich im Kontextmenü von jedem Tab
aussuchen, welchen Inhalt er auf dem Tab angezeigt bekommen will.
Diese Liste ist durchaus absichtlich genau in dieser Reihenfolge, 
bitte beibehalten. (Alphabetisch plus Console am Ende.) ]]
avalet.CONSTS.CHANNELS = {
  [1] = "Gebruell",
  [2] = "Gilde", 
  [3] = "Gruppe", 
  [4] = "Laber", 
  [5] = "Neuling", 
  [6] = "Reden", 
  [7] = "Sagen", 
  [8] = "Schwafel",
  [9] = "Volk", 
  [10] = "Zuenfte",
}

--[[
Hier die Regionen eintragen, die eine eigene Karte mit einer
fensten Breite haben. Also mit einer Breite, die unabhängig von
der Einstellung im Spielerbuch ist. Diese Liste wird benutzt,
um die Karte besser capturen und auf der Oberfläche anzeigen
zu können. ZUR ZEIT NICHT BENUTZT. ]]
avalet.CONSTS.fixedWidthMap = {
  ["SKALEWAR"] = 9,
}

--[[
Der Abstand zwischen zwei Ticks, also zwischen zwei Mal TP/AP/SP vom MUD. ]]
avalet.CONSTS.TICK_TIMER_FREQUENCY = 40 -- Sekunden
</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Events</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>onKeyPadEvent</name>
				<packageName></packageName>
				<script>--[[
Funktion: onKeyPadEvent()
Für das Laufen per Keypad, für das automatische Schwimmen/Klettern und für das
catchen der letzten Bewegung für den Mapper. (Den es aber noch nicht gibt.)
Dieser Event wird jedesmal ausgelöst, wenn eine Taste des Ziffernblocks gedrückt
wird. Das ist unter "Keybindings" bzw. "Tasten" so definiert.
Hier kommt eine ZAHL an als key, diese Zahl entspricht der gedrückten Ziffer auf
dem Ziffernblock. Und diese Zahl wird dann über den Index des Arrays
(listOfDirections) in eine Richtung umgewandelt! ]]
function avalet.onKeyPadEvent(eventName,key)
  avalet.log("Function avalet.onKeyPadEvent(eventName,key)", 1)
  
  local listOfDirections = {"sw","s","so","w","sc","o","nw","n","no","h","r","rein","raus"}

  avalet.char.setLastMove(listOfDirections[key])

  -- Die Ingame-Map bleibt manchmal hängen, dies behebt das Problem
  avalet.IGMapModel.mapCapture = nil
  
  --[[
  Hier wird das Kommando zur Fortbewegung zusammengesetzt und ans MUD geschickt.
  Zusammengesetzt deshalb, weil mit dem Ziffernblock automatisches klettern bzw.
  automatisches schwimmen möglich ist. Dazu wird in der "locomotion"-Variable
  die Fortbewegungsart (leere Zeichenkette oder 'kletter' oder 'schwimme') hinter-
  legt, und dann wird die Richtung (n, nw, ...) angehängt. Geschrieben wird die
  locomotion-Variable durch den Trigger "AutoKletternSchwimmen". Der hat außerdem
  das zusätzliche Feature, dass er den letzten Laufbefehl nochmal wiederholt, aber
  mit der richtigen Fortbewegungsart. So dass man die erwartete Fortbewegung trotz
  Wechsel der Fortbewegungsart doch macht. Nachteil: hier kommt es leicht zu Bein-
  brüchen. Aber man gewöhnt sich dran. ]]
  local str = ""
  if key &gt; 0 and key &lt; 10 and key ~= 5 then
    str = string.trim(avalet.char.getLocomotion() .. " " .. avalet.char.getLastMove())
  else
    str = avalet.char.getLastMove()
  end
  raiseEvent("charMoveEvent",str)
  send(str, true)

end --function avalet.onKeyPadEvent(eventName,key)
registerAnonymousEventHandler("keyPadEvent", "avalet.onKeyPadEvent")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>onCharMoveEvent</name>
				<packageName></packageName>
				<script>function avalet.onCharMoveEvent(event, direction)

  --cecho("&lt;magenta&gt;charMoveEvent, Richtung: "..tostring(direction).."\n")
end
registerAnonymousEventHandler("charMoveEvent", "avalet.onCharMoveEvent")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>onSysInstall</name>
				<packageName></packageName>
				<script>--[[
Der sysInstall-Event ist ein Standard-Event von Mudlet. Er wird immer dann ausgelöst, wenn
ein Modul bzw. ein Paket installiert wird. Also bei jedem Neustart von Mudlet! Als Parameter
übergeben wird der Paket- bzw. Modulname. Es muss hier also erstmal geprüft werden, ob 
Avalet gemeint ist. Und nicht eins der anderen Pakete, die installiert sind.
Es gibt noch verwandte Events zu sysInstall, nämlich sysInstallModule und sysInstallPackage.
Naheliegender Weise werden die ausgelöst, wenn ein Modul bzw. ein Paket installiert wird. Das
mache ich mir zunutzen, weil Avalet nämlich nur funktioniert, wenn es als "Modul" installiert
wurde. Und nicht als Paket.
Eine andere Besonderheit allerdings betrifft den Befehl 'reloadModule()'. Mit diesem Befehl
wird Mudlet dazu veranlasst, das gewünschte Modul neu zu installieren, also im Grunde für das
entsprechende Modul einen Systemneustart simulieren. Das wäre beim Entwickeln (grade des GUI)
sehr hilfreich und würde den händischen Neustart ersparen. Durch 'reloadModule' wird erstmal
das Modul de-installiert (und so der Event 'sysUninstall' ausgelöst). Und dann wird das Modul
wohl neu installiert. Allerdings nicht bei mir. Bei mir bleibt die Anzeige leer, Avalet wird
nicht sichtbar, es gibt keine Fehlermeldungen - und ich habe nicht rausgefunden, woran das 
liegt. Der Befehl 'reloadModule()' funktioniert also bei Avalet leider nicht. TODO ]]
function avalet.onSysInstall(_, name)
  avalet.log("Function avalet.onSysInstall-Event (Modul: "..name..")", 1)
  --[[
  Hier wird nur geloggt, wenn die Variable avalet.debug oben bei "init" auf 'true' steht. ]]

  -- Erstmal prüfen, ob es Avalet ist, was da installiert wurde:
  if name ~= avalet.MODULE_NAME then return end
  
  --[[
  Seit Mudlet 4.16 ist es möglich, GMCP zu deaktivieren. Das
  geschieht hier jetzt also auch. ]]
  avalet.log("GMCP wird deaktiviert. (Notwendig für Avalet.)", 2)
  setConfig("enableGMCP", false)

  --[[
  Für eine vernünftige Versionierung bzw. für einen irgendwie gearteten
  Update-Mechanismus muss Avalet etwas über die eigene Versionsnummer wissen. ]]
  avalet.loadVersionInformation()

  --[[
  Die Modul-Priorität von Avalet wird auf 1 gesetzt, um später Submodule mit einer
  niedrigeren Priorität (also einer höheren Nummer...) ausstatten zu können. Das
  soll dazu führen, dass die Submodule NACH Avalet installiert werden.
  Tatsächlich wird hier aber die Priorität auf "-1" gesetzt, was zu einem ultimativ
  frühen laden führt. Submodule sollten aber trotzdem eine Priorität &gt; 1 bekommen. ]]
  setModulePriority(name, -1)
  --setModulePriority(name, 1)
  
  --[[
  Es bietet sich ja an, in Mudlet je Character ein Profil anzulegen. Dann kann man
  die Logindaten gleich mit speichern und spart sich die Eingabe von Benutzernamen
  und Passwort. Notwendig ist das aber nicht, und tatsächlich gab es recht früh
  bei der Entwicklung von Avalet auch den User-Wunsch, verschiedene Chars im gleichen
  Profil spielen zu können. Deshalb macht es Sinn, beispielsweise Konfigurationen,
  die das Profil betreffen, extra abzulegen. (Also zum Beispiel welche Tabs im
  Kommunikationsbereich angezeigt werden.) Hier ist das Objekt dafür. ]]
  avalet.profile = avalet.initProfile()
  
  --[[
  Das Objekt für den grade gespielten Character wird erzeugt. Erstmal mit den 
  Default-Werten, also Leerstrings und so. Wenn per ATCP Character-Daten einge-
  troffen sind, werden diese verarbeitet und dann wird das Character-Object auch
  sinnvoll befüllt. (Also wenn der Name des Chars per ATCP geschickt wurde. ]]
  avalet.char = avalet.initCharacter()
  
  --[[
  Im Fight-Objekt werden Kämpfe verwaltet. Hauptsächlich um Kampfdauer (und vllt.
  irgendwann auch mal die Trefferanzahl) auf der Oberfläche anzeigen zu können. ]]
  avalet.fight = avalet.initFight()
  
  --[[
  Der Mapper existiert noch nicht, aber was solls. Stört nicht. Also: ]]
  avalet.mapper = avalet.initMapper()
  
  --[[
  Auch die ganzen statistischen Auswertungen, die ich mir erst noch ausdenken und
  implementieren muss, sind ausgelagert und werden hier einmal initialisiert. An-
  gezeigt werden sie dann später unter den Charakterinformationen oben rechts auf
  der Oberfläche. ]]  
  avalet.initStatistics()

  --[[
  Jetzt wird zunächst das "Model" initialisiert. Ich habe das so genannt in Anlehnung
  an das Model-View-Control-Pattern (MVC), mit dem der Code für die Logik und der Code
  für die grafische Benutzeroberfläche (GUI) getrennt wird. Im Model werden also 
  schonmal die Daten vorbereitet, die dann anschließend von der View, also vom "GUI" 
  angezeigt werden. 
  Das ist auch deshalb wichtig, weil die Oberfläche nach jeder Änderung der Fenstergröße
  neu aufgebaut wird. Und das funktioniert nur, wenn dann auch irgendwo die anzuzeigenden
  Daten herkommen. Aus dem Model nämlich. ]]
  avalet.initModel()
  
  --[[
  Die ausgesprochen Komplexe Umsetzung der "Timer", also der Fortschrittsbalken, mit
  denen zum Beispiel die Laufzeit von Schild-Zaubern (und ähnlichem) visualisiert 
  wird, erfordert auch eine Initialisierung. Vor alle werden dabei die Trigger
  erzeugt, mit denen die anzuzeigenden Zauber (etc.) erkannt werden. Wird so ein Trigger
  ausgelöst, erzeugt der sich dann wiederrum einen Einmal-Trigger, der das Ende des
  Zaubers (etc.) erkennt. Wenn das möglich ist. Aber das wird bei den Timern auch
  nochmal ausführlich beschrieben. MUSS VOR buildUI laufen!]]
  avalet.initTimer()
  
  --[[
  Und nachdem jetzt die Daten für die Anzeige vorbereitet sind, kann die Anzeige
  gebaut werden. Anfangs natürlich mit Platzhaltern bzw. leeren Feldern. Das wird
  dann später aktualisiert. Muss zum Schluss laufen, weil die Funktion crashed 
  wenn die Fenstergröße kein Layout zulaesst. TODO.  ]]
  avaletUI.buildUI()
  
  --[[
  Nach einem Reconnect braucht Avalet den Charakternamen. Nach einem normalen
  Login wird der sehr schnell per ATCP gesendet. Nach einem reconnect (Statue)
  aber nicht. Dieser Name ist für Avalet aber notwendig, um den Charakter zu
  erkennen und die gespeicherten Charakterdaten von Festplatte einlesen und
  anzeigen zu können. Gelöst wird das Problem durch den Trigger, der hier jetzt
  angelegt wird. Der Trigger reagiert, wenn das MUD den Text "Verwende alten 
  Koerper..." schickt, und löst dann einen Event aus. Der aktiv ein ATCP-Update
  von Server anfordert. Damit kommt dann auch der Charaktername und Avalet
  funktioniert wie gewünscht. Warum ich den Trigger hier anlege und nicht einfach
  fest reinschreibe weiß ich auch nicht mehr. Ich vermute: weil ich es kann.
  'name' ist übrigens der Modul-Name, der dieser Funktion als Parameter über-
  geben wird. ]]
  if not exists("OnReconnect", "trigger") then
    local luaCode = [[raiseEvent("afterReconnectEvent")]]
    permRegexTrigger("OnReconnect", name, {"^Verwende alten Koerper\.\.\.$"}, luaCode)
  end
 
end --function avalet.onSysInstall(_, name)
registerAnonymousEventHandler("sysInstall", "avalet.onSysInstall")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>onSysInstallModule</name>
				<packageName></packageName>
				<script>--[[
Diese Funktion wird durch den "sysInstallModule"-Event aufgerufen, also 
bei jedem Neustart von Mudlet. (Weil dann immer das Modul neu installiert
wird.) Hier muss zunächst geschaut werden, ob der Event auch tatsächlich 
Avalet betrifft. (Und kein anderes Modul.) Anschließend findet hier die 
Initialisierung des Moduls statt. ]]
function avalet.onSysInstallModule(_, name)
  avalet.log("Function avalet.onSysInstallModule() (Modul: "..name..")", 1)
  
  -- Erstmal prüfen, ob es Avalet ist, was da installiert wurde:
  if name ~= avalet.MODULE_NAME then return end
  
  --51 Zeichen haben in dem Fenster unten Platz, da sollte die Versionsinfo passen
  local i = ""
  if avalet.VERSION_NR ~= nil and avalet.VERSION_DATE ~= nil then
    i = "Version: "..avalet.VERSION_NR.." ("..avalet.VERSION_DATE..")"
    while i:len() &lt; 51 do i = " " .. i end
  end
  
  local sign = "\n"
  sign = sign .."      __________________________________________________________      \n"
  sign = sign .."     /                                                        / \\     \n"
  sign = sign .."     |                        Modul Avalet                    | |     \n"
  sign = sign .."     \\________________________________________________________\\_/     \n"
  sign = sign .."      |                                                       |       \n"
  sign = sign .."      |  Du hast Avalet installiert, ein Mudlet-Plugin für    |       \n"
  sign = sign .."      |  das MUD Avalon. Eine Hilfe bekommst du mit 'avalet   |       \n"
  sign = sign .."      |  hilfe' angezeigt.                                    |_      \n"
  if i:len() ~= 0 then
    sign = sign .."      |  "..i.."  | |     \n"
  end
  sign = sign .."      \\_______________________________________________________\\_/     \n"
  sign = sign .."                                                                      \n"
  
  cecho("&lt;white:black&gt;"..sign)
   
end --onSysInstallModule
registerAnonymousEventHandler("sysInstallModule", "avalet.onSysInstallModule")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>onSysInstallPackage</name>
				<packageName></packageName>
				<script>--[[
Diese Funktion wird durch den "sysInstallPackage"-Event aufgerufen, also 
bei jedem Neustart von Mudlet - jedenfalls wenn ein Paket installiert ist.
Avalet funktioniert nicht, wenn es als Paket installiert wird - nur als Modul!
Und es gibt keine wirklich gut verwertbare Fehlermeldung in diesem Fall. Deshalb
gibt es hier diese ganz dezente Fehlermeldung.
Auch hier muss zunächst geschaut werden, ob der Event auch tatsächlich Avalet
betrifft. (Und kein anderes Paket oder Modul.) ]]
function avalet.onSysInstallPackage(_, name)
  avalet.log("Function avalet.onSysInstallPackage()", 1)

  -- Erstmal prüfen, ob es Avalet ist, was da installiert wurde:
  if name ~= avalet.MODULE_NAME then return end
  
  cecho("\n\n&lt;magenta&gt;!!!    ACHTUNG: Avalet wurde als Paket installiert!    !!!\n")
  cecho(    "&lt;magenta&gt;!!!        Avalet funktioniert als Paket nicht.        !!!\n")
  cecho(    "&lt;magenta&gt;!!!    Avalet muss jetzt erst deinstalliert werden!    !!!\n")
  cecho(    "&lt;magenta&gt;!!! Anschliessend Avalet bitte als MODUL installieren! !!!\n\n")
  
end
registerAnonymousEventHandler("sysInstallPackage", "avalet.onSysInstallPackage")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>onSysUninstall</name>
				<packageName></packageName>
				<script>--[[
Diese Funktion wird ausgeführt, wenn Avalet DEinstalliert wird. Warum auch
immer jemand so etwas verrücktes tun sollte. Hier wird aufgeräumt. ]]
function avalet.onSysUninstall(_, name)
  avalet.log("Function avalet.onSysUninstall()", 1)
  --cecho("&lt;magenta&gt;Function avalet.onSysUninstall(): "..name)

  -- Erstmal prüfen, ob es Avalet ist, was da deinstalliert wurde:
  if name ~= avalet.MODULE_NAME then return end
  
  -- Bei der Deinstallation von Avalet wird der Zustand des Default Anwendungsfensters
  -- wieder hergestellt. (Also die normale Spiel-Konsole im gesamten Fenster angezeigt.)
  -- Edit: So weit zur Theorie. In der Praxis hat nichts davon funktioniert. TODO.
--[[
  avaletUI.adjContTop:hide()
  avaletUI.adjContBottom:hide()
  avaletUI.adjContLeft:hide()
  avaletUI.adjContRight:hide()
  setBorderTop(0)
  setBorderBottom(0)
  setBorderLeft(0)
  setBorderRight(0)
  setBorderSizes()
  
  -- Die Inhalte der beiden Namespaces können dann wohl auch weg
  avalet = nil
  avaletUI = nil
]]
end -- function onSysUninstall(_, name)
registerAnonymousEventHandler("sysUninstall", "avalet.onSysUninstall")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>onSysLoadEvent</name>
				<packageName></packageName>
				<script>--[[
Der "sysLoadEvent" ist ein Standard-Event von Mudlet.
Er wird ausgelöst, wenn Mudlet das Profil geladen hat. ]]
function avalet.onSysLoadEvent()
	avalet.log("Function avalet.onSysLoadEvent()", 1)
  
  --[[
  Wenn der Profil-Name mit "- DEV" endet, wird hier der Debug-Modus
  aktiviert. DEBUG_PATTERN wird ganz am Anfang dieses Moduls definiert, unter "init".
  Dort kann der Debug-Modus auch gleich aktiviert werden, dann passiert hier nichts. ]]
  if (utf8.match(getProfileName(), avalet.DEBUG_PATTERN)) then
    if avalet.debug ~= true then
      avalet.debug = true
      avalet.log("DEBUG MODE aktiviert!", 0)
    end
  end

  --[[
  Diese Funktion wird ausgeführt, wenn "reloadProfile()" ausgeführt wird.
  Und wäre deshalb ein guter Platz, um das Profil zu initialisieren. TODO ]]
end
registerAnonymousEventHandler("sysLoadEvent", "avalet.onSysLoadEvent")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>onSysExitEvent</name>
				<packageName></packageName>
				<script>--[[
Der "sysExitEvent" ist ein Standard-Event von Mudlet.
Er wird ausgelöst, wenn Mudlet das Profil schließt. ]]
function avalet.onSysExitEvent()
  avalet.log("Function avalet.onSysExitEvent()", 1)

  --[[
  Die Profil-Daten auf Festplatte schreiben. Von dort werden
  sie beim nächsten Start wieder eingelesen. ]]
  avalet.profile.dumpProfile()

  --[[
  Charakter-Daten werden bei der Verarbeitung des 
  "sysDisconnectionEvent"s gesichert. ]]
end
registerAnonymousEventHandler("sysExitEvent", "avalet.onSysExitEvent")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>onSysConnectionEvent</name>
				<packageName></packageName>
				<script>--[[
Der "sysConnectionEvent" ist ein Standard-Event von Mudlet.
Er wird ausgelöst, wenn eine Verbindung zum MUD besteht. Aber davon
abgesehen kann man hier noch nicht viel machen: ATCP funktioniert
hier noch nicht, ein Charakter ist noch nicht verfügbar (noch nicht
angemeldet), ... ]]
function avalet.onSysConnectionEvent()
  avalet.log("Function avalet.onSysConnectionEvent()", 1)

  --[[
  Hier wird das ServerEncoding von ASCII (default in Mudlet) auf
  UTF-8 (recommended in Mudlet) gesetzt. Das hat folgenden Hintergrund:
  Avalon selber kann schon lange mit Umlauten umgehen. Aber Mudlet
  wirft in der default-Konfiguration eine sehr unschöne Fehlermeldung,
  und zwar beim ersten eingegebenen (und abgeschickten) Umlaut nach
  jedem Neustart. Die Umstellung auf UTF-8 behebt das.
  Wird natürlich nur versucht wenn UTF-8 überhaupt zur Verfügung steht
  und die aktuelle Konfiguration auf ASCII seht. ]]
  if table.contains(getServerEncodingsList(), "UTF-8") then
    if getServerEncoding() == "ASCII" then
      setServerEncoding("UTF-8")
      avalet.log("ServerEncoding auf UTF-8 gesetzt!", 2)
    end
  end
  
  --[[
  Wenn man richtig ausloggt (mit 'einschlafen'), Mudlet bzw. den Reiter 
  mit dem Profil dann aber NICHT schliesst, sondern die Verbindung ueber 
  reconnect ('Neu verbinden') wieder herstellt, dann wurde das CharFile 
  nicht neu eingelesen. Das war bisher kein Problem, aber jetzt wird es 
  das vielleicht, deshalb setze ich hier bei einem "connect" den Char-
  Namen auf nil (bzw. eigentlich auf ""). Dadurch wird das CharFile neu 
  eingelesen. ]]
  avalet.log("avalet.onSysConnectionEvent(): setze char.name auf nil", 2)
  if avalet.char.getName() then avalet.char.setName(nil) end
  
end
registerAnonymousEventHandler("sysConnectionEvent", "avalet.onSysConnectionEvent")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>onSysDisconnectionEvent</name>
				<packageName></packageName>
				<script>--[[
Der Event "sysDisconnectionEvent" ist ein Standard-Event von Mudlet.
Er wird ausgelöst, wenn die Verbindung zum MUD abreisst. Das kann sowohl
durch ein logout geschehen als auch durch jeden anderen Verbindungs-
abbruch. ]]
function avalet.onSysDisconnectionEvent()
  avalet.log("Function avalet.onSysDisconnectionEvent()", 1)

  --[[
  Hier wird vorsorglich der Wert gesetzt, der bei der nächsten Verbindungs-
  aufnahme ausgewertet wird. VOR dieser Auswertung wird der Wert aber noch-
  mal überschrieben, wenn diese Verbindungsaufnahme ein "reconnect" ist. ]]
  avalet.char.setLoginIsReconnect(false)

  --[[
  Bei einem Disconnect werden die Character-Daten auf Festplatte geschrieben.
  (Und beim neuen connect wieder eingelesen.) ]]
  avalet.char.saveCharDataToDisk()

end
registerAnonymousEventHandler("sysDisconnectionEvent", "avalet.onSysDisconnectionEvent")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>onSysProtocolEnabled</name>
				<packageName></packageName>
				<script>--[[
Hier wird ATCP konfiguriert - wenn ATCP verfügbar ist.
Was allerdings notwendig für Avalet ist.
Ich hab versucht, hier auch auf "GMCP" zu prüfen und eine
Warnung auszugeben. Aber offenbar wird GMCP nicht wie die
anderen Protokolle aktiviert, ich hatte jedenfalls keinen
Auslöser des "elseif", trotz aktiviertem GMCP. 
Seit Mudlet 4.16 ist es möglich, GMCP zu deaktivieren. Das
geschieht in der Funktion onSysInstall weiter oben. ]]
function avalet.onSysProtocolEnabled(event,arg)
  avalet.log("Function avalet.onSysProtocolEnabled()", 1)

  --avalet.log("GMCP  wird deaktiviert. (Notwendig für Avalet.)", 2)
  --setConfig("enableGMCP", false)

	if arg =="ATCP" then
    avalet.log("Support fuer ATCP ist aktiv, konfiguriere ATCP.", 2)
		sendATCP("ava_set_mapper",1)
		sendATCP("ava_set_channel",1)
		sendATCP("ava_set_comm",1)
		sendATCP("ava_set_rcomm",1)
		sendATCP("ava_set_soul",1)
		sendATCP("ava_set_rsoul",1)
		--sendATCP("ava_set_soundpack",1)
		sendATCP("ava_req_targets",1)
		sendATCP("ava_req_update",1)
		sendATCP("ava_req_graphics_status",1)
	elseif arg=="GMCP" then
		cecho("&lt;magenta&gt;GMCP ist offenbar aktiviert. So wird Avalet nicht funktionieren.\nBitte GMXP in den Einstellungen deaktivieren und neu starten.")
	else
		avalet.log("Support fuer "..arg.." ist aktiv.", 2)
	end
end
registerAnonymousEventHandler("sysProtocolEnabled", "avalet.onSysProtocolEnabled")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>onSysWindowResizeEvent</name>
				<packageName></packageName>
				<script>--[[
Funktion: onSysWindowResizeEvent
Wird ausgeführt, wenn sich die Größe des Mudlet-Fensters ändert. Wird aber auch
ausgeführt, wenn sich nix ändert. Keine Ahnung warum. Jedenfalls wird hier erst-
mal geprüft, ob sich die Größe auch tatsächlich verändert hat. Ist das der Fall,
dann wird die Oberfläche von Avalet neu berechnet und neu gezeichnet. Außerdem 
wird die neue Größe gemerkt, um beim nächsten Funktionsdurchlauf wieder fest-
stellen zu können, ob sich die Größe geändert hat.]]
function avalet.onSysWindowResizeEvent( event, x, y )
  avalet.log("Function avalet.onSysWindowResizeEvent()", 1)
  
  -- Wenn nichts angezeigt wird, muss von Avalet auch nichts berechnet werden
  if getBorderTop()==0 and getBorderBottom()==0 and getBorderLeft()==0 and getBorderRight==0 then
    return
  end
  
  local mainWindowWidth = 0
  local mainWindowHeight = 0
  local somethingHasChanged = false

  -- Aktuelle Fenstergröße holen  
  mainWindowWidth, mainWindowHeight = getMainWindowSize()
  
  -- Sollte der Namespace noch nicht vorgesehen sein, wird er das jetzt
  avaletUI.dimensions = avaletUI.dimensions or {}
  
  -- Hat sich die Breite des Fensters geändert?
  if avaletUI.dimensions.mainWindowWidth ~= mainWindowWidth then
    somethingHasChanged = true
    avaletUI.dimensions.mainWindowWidth = mainWindowWidth
  end
  
  -- Hat sich die Höhe des Fensters geändert?
  if avaletUI.dimensions.mainWindowHeight ~= mainWindowHeight then
    somethingHasChanged = true
    avaletUI.dimensions.mainWindowHeight = mainWindowHeight
  end
  
  -- Wenn sich was geändert hat, dann muss die Oberfläche neu aufgebaut werden.
  if somethingHasChanged then
    avaletUI.buildUI()
  end
   
end
registerAnonymousEventHandler("sysWindowResizeEvent", "avalet.onSysWindowResizeEvent")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>onLogoutEvent</name>
				<packageName></packageName>
				<script>--[[
Dieses Event wird ausgelöst, wenn der Spieler den Charakter richtig ausloggt,
also mit "schlafe ein" etc. Ausgelöst wird dieses Event durch ein Alias auf
die Befehle, mit denen das Ausloggen möglich ist. Außer ich hab einen vergessen.
Derzeit: ^(ende|ende hier|einschlafen|schlaf ein|schlafe ein)$ ]]
function avalet.onLogoutEvent()
  avalet.log("Function avalet.onLogoutEvent()", 1)

  -- der nächste Login wird zwangsläufig ein "richtiger" login sein, kein reconnect
  avalet.char.setLoginIsReconnect(false)

  --[[
  Schonmal die Charakterdaten auf die Platte schreiben. ]]
  avalet.char.saveCharDataToDisk()

  -- Bei einem richtigen logout werden die ChatTab-Verläufe gelöscht:
  avalet.char.flushChatBuffer()

end
registerAnonymousEventHandler("logoutEvent", "avalet.onLogoutEvent")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>onReconnectEvent</name>
				<packageName></packageName>
				<script>--[[
onReconnectEvent wird durch einen Trigger auf "Verwende alten Koerper..." ausgelöst.
Durch den Event werden hier die ATCP-Daten vom MUD angefordert. Das ist notwendig,
da das MUD bei einem Reconnect die ATCP-Daten nicht von selbst erneut schickt. ]]
function avalet.onReconnectEvent()
  avalet.log("Function avalet.onReconnectEvent()", 1)

  -- Dieser Login ist ein klarer Fall von "reconnect"
  avalet.char.setLoginIsReconnect(true)
  
  --[[
  "sendATCP" gibt "true" zurück, und das wird unter Umständen im Hauptfenster
  ausgegeben. Außer man speichert es in einer Variable wie zum Beispiel "_".
  In LUA ist das die Variable für Gelegenheiten, wo man eine braucht, die man dann
  nicht verwenden will. ]]
  _ = sendATCP("ava_req_update")
end
registerAnonymousEventHandler("onReconnectEvent", "avalet.onReconnectEvent")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>onSysSendAllProfiles</name>
				<packageName></packageName>
				<script>--[[
]]
function avalet.onAvaletSendAllProfiles(event, level, sender, message, profil )
  cecho("&lt;magenta&gt;raiseGlobalEvent von "..tostring(sender).."\n")

  -- lua raiseGlobalEvent("sysSendAllProfiles", "ALERT", avalet.char.getName(), "EINSTURZ!!!")

  local width, height = getMainWindowSize()
  local msg = ""
  
  
  createLabel("messageBox",(width/2)-300,(height/2)-100,250,150,1)
  resizeWindow("messageBox",500,150)
  moveWindow("messageBox", (width/2)-300,(height/2)-100 )

  if level == "ALERT" or level == "WARN" then
    setBackgroundColor("messageBox", 255, 0, 0, 200)
  elseif level == "INFORM" then
    setBackgroundColor("messageBox", 255, 255, 0, 200)
  else
    setBackgroundColor("messageBox", 255, 255, 255, 200)
  end
  
  msg = msg .. [[&lt;p style="font-size:35px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="black"&gt;]]..sender..[[ warnt Dich!&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]]
  msg = msg .. [[&lt;p style="font-size:20px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="black"&gt;Und wird Dich gleich rausschmeissen.&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]]
  msg = msg .. [[&lt;p style="font-size:20px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="Gray"&gt;(klicken zum schliessen)&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]]
  --msg = msg .. [[&lt;p style="font-size:20px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="grey"&gt;(klicken zum schliessen)&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]]
  
  
  --echo("messageBox", [[&lt;p style="font-size:35px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="black"&gt;]]..sender..[[ warnt Dich!&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;&lt;p style="font-size:20px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="red"&gt;Und wird Dich gleich rausschmeissen.&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;&lt;p style="font-size:20px"&gt;&lt;b&gt;&lt;center&gt;&lt;font color="grey"&gt;(klicken zum schliessen)&lt;/font&gt;&lt;/center&gt;&lt;/b&gt;&lt;/p&gt;]])
  echo("messageBox", msg)
  
  -- you can also make it react to clicks!
  avalet.messageBoxClicked = function()
      deleteLabel("messageBox")
  end
  
  setLabelClickCallback("messageBox", "avalet.messageBoxClicked")



end
registerAnonymousEventHandler("avaletSendAllProfiles", "avalet.onAvaletSendAllProfiles")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>onTimerAddedEvent</name>
				<packageName></packageName>
				<script>--[[
Funktion: onTimerAddedEvent()
Jemand - und ich sehe hier keinen an, vor allem Twrx nicht - hat sich eine 
Moeglichkeit gewuenscht, gezauberte Schilde mitzuzaehlen. Das zaehlen selbst 
uebernehme ich derzeit nicht, aber ich lasse Avalet immer einen "timerAdded"-
Event werfen, wenn ein Timer hinzugefuegt wurde. Zur freien Verwendung. Die 
Funktion hier dient nur zum debuggen. Den Char-Name schicke ich mit falls im 
Profil verschiedene Chars gespielt werden. ]]
function avalet.onTimerAddedEvent(eventName, charName, timerName)
  avalet.log("avalet.onTimerAddedEvent(eventName, charName, timerName)", 1)
  
  --avalet.log("Timer wurde hinzugefuegt fuer: "..timerName..", Charakter: "..charName..", eventName: "..eventName, 2)

end --function avalet.onTimerAddedEvent(eventName, charName, timerName)
registerAnonymousEventHandler("timerAddedEvent", "avalet.onTimerAddedEvent")</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Misc</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>loadVersionInformation</name>
				<packageName></packageName>
				<script>-- function loadVersionInformation()
function avalet.loadVersionInformation()
  avalet.log("Function avalet.loadVersionInformation()", 1)
  
  local path = avalet.MODULE_HOME_DIR.."version"
  
  local file = io.open(path, "r")
  
  if file == nil then avalet.log("Versionsinformationen nicht gefunden", 2); return end

  local key = 1
  for line in file:lines() do
    if key == 1 then avalet.VERSION_NR = line end
    if key == 2 then avalet.VERSION_DATE = line end
    key = key + 1
  end
    
  file:close()

  avalet.log("Avalet Versionsinformation: "..avalet.VERSION_NR.." vom "..avalet.VERSION_DATE, 2)

  return true

end -- function loadVersionInformation()
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>File I/O</name>
				<packageName></packageName>
				<script>function avalet.readFileFromFS(path, mode)
  avalet.log("Function avalet.readFileFromFS()", 1)

  local data = {}
  local file = io.open(path, mode)
  local line = file:read()
  if line == nil then 
    avalet.log("readFileFromFS: File is nil!", 4) 
  elseif line == "" then
    avalet.log("readFileFromFS: File is ''!", 4) 
  else
    data = yajl.to_value(line)
  end
  file:close()
  return data
end

function avalet.writeDataToFS(path, data, mode)
  avalet.log("avalet.writeDataToFS()", 1)

  local file = io.open(path, mode)
  file:write(yajl.to_string(data))
  file:flush()
  file:close()
  return true
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>CSSMan</name>
				<packageName></packageName>
				<script>-- CSSMan by Vadi. Public domain.

CSSMan = {}
CSSMan.__index = CSSMan

function CSSMan.new(stylesheet)
  local obj  = { stylesheet = {} }
  setmetatable(obj,CSSMan)
  local trim = string.trim

  assert(type(stylesheet) == "string", "CSSMan.new: no stylesheet provided. A possible error is that you might have used CSSMan.new, not CSSMan:new")

  for line in stylesheet:gmatch("[^\r\n]+") do
    local attribute, value = line:match("^(.-):(.-);$")
    if attribute and value then
      attribute, value = trim(attribute), trim(value)
      obj.stylesheet[attribute] = value
    end
  end

  return obj
end

function CSSMan:set(key, value)
  self.stylesheet[key] = value
end

function CSSMan:get(key)
  return self.stylesheet[key]
end

function CSSMan:getCSS(key)
  local lines, concat = {}, table.concat
  for k,v in pairs(self.stylesheet) do lines[#lines+1] = concat({k,": ", v, ";"}) end
  return concat(lines, "\n")
end

function CSSMan:gettable()
  return self.stylesheet
end

function CSSMan:settable(tbl)
  assert(type(tbl) == "table", "CSSMan:settable: table expected, got "..type(tbl))

  self.stylesheet = tbl
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Logger</name>
				<packageName></packageName>
				<script>--[[
Dieses Logging (inklusive auch von Triggern, Timern etc.) basiert erstmal auf einer
Arbeit vom User Wyd aus dem Mudlet-Forum, die ich unter dieser Adresse gefunden habe:
https://forums.mudlet.org/viewtopic.php?t=1424

Anpassungen von mir.

Das Ziel des Avalet-Loggers ist, eine Möglichkeit zu haben, aus verschiedenen
Quellen Ausgaben in verschiedene Dateien umzuleiten. Um diese dann optional in den
Tabs auf der Oberfläche anzeigen zu können.
Quellen für diese Ausleitung sind beispielsweise: 
--&gt; Trigger
--&gt; ATCP
--&gt; Logging-Ausgaben im Code für Debugging und Error-Logging im Betrieb
Und zwar vorzugsweise sowohl aus Avalet heraus als auch durch eventuelle
Sub-Module.
Funktionen sind also:
--&gt; Eine Datei angeben zu können, die innerhalb des Profils gespeichert wird,
    und in die dann die Logausgaben irgendwie in geschickter Weise (Dateigröße?)
    rausgeschrieben werden.
--&gt; Einen Tab im Frontend anlegen können, in dem die Log-Ausgabe, also der Inhalt
    der Datei, in einer Mini-Konsole angezeigt wird. (Muss es nicht geben, einfach
    in eine Datei loggen können sollte auch gehen.)
--&gt; Aus den verschiedenen Quellen in den entsprechenden Logger reinschreiben zu können.
--&gt; Ein intelligenter Umgang mit den Dateien und dem verwendeten Speicher. ]]

Logger = Logger or {
		_currFileNum = 0,

		_fileName = nil,

		_keepOpen = {}
}

function Logger:getLogDirectory()
	if string.char(getMudletHomeDir():byte()) == "/" then _sep = "/" else  _sep = "\\" end
	local logdir = getMudletHomeDir() ..  _sep .. "log" .. _sep
  -- Es gab Probleme mit Leerzeichen im Pfad unter Linux. 
  -- Das hier ist der Versuch, das Problem zu lösen. Indem das Leerzeichen
  -- mit einem "\" maskiert wird. Alternativ müsste man das mit Anführungs-
  -- zeichen um den Pfad rum lösen.
  if _sep == "/" then
    string.gsub(logdir, " ", "\ ")
  end
  
	return logdir
end

function Logger:echo(message)
	cecho("\n&lt;red&gt;Logger: ")
	cecho("&lt;white&gt;" .. message)
end

function Logger:Log(file, val, options)
	options = options or Logger.options or {}

	local line = ""
  if table.contains(options, "timestamp") then
		local time_format = "'['dd'.'MM'.'yyyy' - 'hh':'mm':'ss'.'zzz]: "
		line = line .. getTime(true, time_format)
	end

	if table.contains(options, "split") then
		local maxSize = options.split
		self:_checkFileSize(file, maxSize)
	end
	
	local keepopen = table.contains(options, "keepOpen")

	local f
	
	if not self._keepOpen[file] then
		local filename = self:getLogDirectory()  .. file .. ".txt"
		f = io.open(filename, "a+")
		self._keepOpen[file] = f
	else
		f = self._keepOpen[file]
	end

	line = line .. val
	f:write(line .. "\n")

	if not keepopen then
		self:_closeLog(file)
	end
end

function Logger:CloseLog(file)
	if file then
		self:_closeLog(file)
	else
		for f, _ in pairs(self._keepOpen) do
			self:_closeLog(f)
		end
	end
end

function Logger:SearchLog(file, pattern)
	self:_closeLog(file) -- close the log if its open, so we can access it

	local filename = self:getLogDirectory() .. file .. ".txt"
	if not io.exists(filename) then
		self:echo("File '" .. file .. "' does not exist!")
		return
	end

	local counter = 0

	local numBackups = self:_getCurrentFileNumber(file)

	Logger:echo("Searching for '&lt;green&gt;" .. pattern .. "&lt;white&gt;' in file '" .. file .. "'")
	
	local t = 1;
	local lines = 0
	local r = rex.new(pattern)

	while t &lt;= numBackups do
		local bfilename = self:getLogDirectory() .. file .. "." .. tostring(t) .. ".txt"
		local f = io.open(bfilename, "r")

		for line in f:lines() do
			lines = lines + 1
			if r:match(line) then
				cecho("\n&lt;grey&gt;" .. line .. "  &lt;white&gt;(in " .. file .. "." .. tostring(t) .. ".txt)")
				counter = counter + 1
			end
		end

		f:close()

		t = t + 1
	end

	local f = io.open(filename, "r")

	for line in f:lines() do
		lines = lines + 1
		if r:match(line) then
			cecho("\n&lt;grey&gt;" .. line .. "  &lt;white&gt;(in " .. file .. ".txt)")
			counter = counter + 1
		end
	end

	f:close()

	Logger:echo("Term matched " .. counter .. " times in " .. lines .. " lines.")
end

-- Hinzugefügt von Rofhessa
function Logger:logFileExists(file)
  self:_closeLog(file) -- close the log if its open, so we can access it
	local filename = self:getLogDirectory() .. file .. ".txt"
	if not io.exists(filename) then
    return false
	else
    return true
  end
end


-- Hinzugefügt von Rofhessa
function Logger:ReadLog(file)
	self:_closeLog(file) -- close the log if its open, so we can access it
	debugc("File: "..self:getLogDirectory() .. file .. ".txt\n")
	local filename = self:getLogDirectory() .. file .. ".txt"
	if not io.exists(filename) then
		self:echo("File '" .. file .. "' does not exist!")
		return
	else
		local f = io.open(filename, "r")
		content = ""
    lastdate = ""
		for line in f:lines() do
			if line ~= "" then
				-- "'['dd'.'MM'.'yyyy' - 'hh':'mm':'ss'.'zzz]: "
				-- "[05.04.2020 - 16:45:00.283]: "
				--x = string.gsub("hello world", "%w+", "%0 %0", 1)
				-- ^\[\d{2}\.\d{2}\.\d{4} - (\d{2}:\d{2}:\d{2}).\d{3}\]: (.*)$
				-- "^%[%d{2}%.%d{2}%.%d{4} %- (%d{2}:%d{2}:%d{2})%.%d{3}%]: (.*)$", "[%0]: %1", 1)
				-- %^ITALIC%^schelmisch%^NO_ITALIC%^
        date = string.gsub(line, "^%[(%d+%.%d+%.%d+) %- %d+:%d+:%d+%.%d+%]: .*$", "%1", 1)
        if lastdate ~= date then
          content = content .. "\n\n~~~~~~~~~~~~~~~~~~~~ " .. date .. " ~~~~~~~~~~~~~~~~~~~~\n"
          lastdate = date
        end
				line = string.gsub(line, "^%[%d+%.%d+%.%d+ %- (%d+:%d+:%d+)%.%d+%]: (.*)$", "%1: %2", 1)
				content = content .. "\n" .. line
			end
		end
		return content
	end
end




-- TEST

-- Hinzugefügt von Rofhessa
function Logger:ReadLogWithLineLimit()
  --file = "C:/Users/mstef/.config/mudlet/profiles/Ava - Rofhessa - DEV\log\Sagen.txt"
  file = "Sagen"
	self:_closeLog(file) -- close the log if its open, so we can access it
	debugc("File: "..self:getLogDirectory() .. file .. ".txt\n")
	local filename = self:getLogDirectory() .. file .. ".txt"
	if not io.exists(filename) then
		self:echo("File '" .. file .. "' does not exist!")
		return
	else
		local f = io.open(filename, "r")
		content = ""
    
    --f:seek("end",-24)
    --content = f:read("*a")
    
    --content = f:lines()
    lineCounter = 0
 		 for line in f:lines() do 
  			if line ~= "" then
       lineCounter = lineCounter + 1 
      end
--				-- "'['dd'.'MM'.'yyyy' - 'hh':'mm':'ss'.'zzz]: "
--				-- "[05.04.2020 - 16:45:00.283]: "
--				--x = string.gsub("hello world", "%w+", "%0 %0", 1)
--				-- ^\[\d{2}\.\d{2}\.\d{4} - (\d{2}:\d{2}:\d{2}).\d{3}\]: (.*)$
--				-- "^%[%d{2}%.%d{2}%.%d{4} %- (%d{2}:%d{2}:%d{2})%.%d{3}%]: (.*)$", "[%0]: %1", 1)
--				-- %^ITALIC%^schelmisch%^NO_ITALIC%^
--				line = string.gsub(line, "^%[%d+%.%d+%.%d+ %- (%d+:%d+:%d+)%.%d+%]: (.*)$", "%1: %2", 1)
--				content = content .. "\n" .. line
--			end
		  end
    content = tostring(lineCounter)
		return content
	end--if not io.exists(filename) then
end --function Logger:ReadLogWithLineLimit()

--- TEST ENDE





function Logger:LogSection(file, options)
		if self.trigger_id then 
			Logger:echo("Already logging a section. Do Logger:StopLogging() first")
			return
		end

		options = options or {}
		
		if not table.contains(options, "keepOpen") then table.insert(options, "keepOpen") end
		
		local splitSize = 0
		if table.contains(options, "split") then
			splitSize = options.split
			self:_checkFileSize(file, splitSize)
		end

		-- we don't want to pass this on
		options.split = nil

		self:Log(file, "\n\n", {"keepOpen"})
		self:Log(file, "[[[START OF SECTION]]]", {"timestamp", "keepOpen"})

		self.logging_file = file
		self.options = options
		self.trigger_id = tempRegexTrigger(".*", [[ Logger:Log("]] .. file .. [[", matches[1], Logger.options)]])	
		
		if splitSize ~= 0 then
			self.splitSize = splitSize
			enableTimer("Check File Size")
		end
		Logger:echo("Started logging!")
end

function Logger:StopLogging()
	if self.trigger_id then
		killTrigger(self.trigger_id)
		self:_closeLog(self.logging_file)
		self.trigger_id = nil
		self.options = nil
		self.splitSize = 0
		disableTimer("Check File Size")
		self:Log(self.logging_file, "[[[END OF SECTION]]]", {"timestamp"})

		self.logging_file = nil
		Logger:echo("Logging stopped!")
	end
end

function Logger:_checkFileSize(file, maxSize)
	--Check whether our file size is to big
	if self:_getFileSize(file) &gt;= maxSize then
		-- if it is, we need to rename the current file.txt to file.n.text
		self:_closeLog(file)
		local t = self:_getNextFileNumber(file)
		os.rename(self:getLogDirectory() .. file .. ".txt", self:getLogDirectory() .. file .. "." .. t .. ".txt")
	end
end

function Logger:_getFileSize(file)
	local filename = self:getLogDirectory()  .. file .. ".txt"
	local f = io.open(filename, "r")

	if not f then return 0 end
	local size = f:seek("end")    -- get file size
  	
	f:close()
	return size / 1024 -- We want size in kb's, not bytes
end

function Logger:_getCurrentFileNumber(file)
	local t = 1
	local stop = false
	while not stop do
		local filename = self:getLogDirectory() .. file .. "." .. tostring(t) .. ".txt"
		if io.exists(filename) then
			t = t + 1
		else
			stop = true
		end
	end

	self._currFileNum = t - 1

	return self._currFileNum
end

function Logger:_getNextFileNumber(file)
	local current = self:_getCurrentFileNumber(file)
	self._currFileNum = current + 1
	return self._currFileNum
end


function Logger:_closeLog(file)
	if self._keepOpen[file] then
		self._keepOpen[file]:close()
		self._keepOpen[file] = nil
	end
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>avalet.log</name>
				<packageName></packageName>
				<script>--[[
avalet.log

Beim Entwickeln fehlte mir irgendwann sowas wie log4j, also eine 
konfigurierbare Möglichkeit, Debug-Texte auszugeben. Ohne sie später 
dann immer wieder löschen zu müssen. Das hier ist mein workaround dafür. 
Die log-message hier wird _immer_ in der Debug-Console von Mudlet 
ausgegeben. Die sieht man, wenn man hier im Code-Editor ganz Links 
auf "Fehler" klickt. Und wenn der debug-Modus in Avalet aktiviert ist, 
dann erfolgt die Ausgabe auch im Hauptfenster. Zu diesem
debug-Modus steht was ganz am Anfang, unter "init".

Der Log-Level gewichtet die einzelnen Meldungen. Und durch die Einstellung 
in 'avalet.loglevel' (auch im Abschnitt 'init') kann man sich einstellen, 
wie viele Ausgaben man sehen will. Stellt man 'avalet.loglevel' auf 0, 
dann bekommt man alle Ausgaben angezeigt. Stellt man den Wert auf 2, dann 
bekommt man nur [INFO] und schwerwiegendere Meldungen zu sehen. 

Logging in einer Datei findet derzeit nicht statt. ]]
function avalet.log(message, level)
 
  local color
  local prefix = "[DEBUG] "
  
  -- Ausgabe in der Debug-Console
	debugc(message)
  
  -- Aufbereitung und Ausgabe in der Hauptconsole
  if avalet.debug then
    if level == nil then color = ""
    elseif level == 0 then color = "&lt;green&gt;";   prefix = "[AVALET]  - " --system (immer an!)
    elseif level == 1 then color = "&lt;green&gt;";   prefix = "[DEBUG] "     --allgemeines (minimum normalerweise!)
    elseif level == 2 then color = "&lt;yellow&gt;";  prefix = "[INFO]  "     --informatives
    elseif level == 3 then color = "&lt;red&gt;";     prefix = "[WARN]  "     --warnungen
    elseif level == 4 then color = "&lt;magenta&gt;"; prefix = "[ERROR] "     --schwerwiegendes
    else color = ""
    end
    
    if level == nil or level &gt;= avalet.loglevel then 
      cecho(color..prefix..message.."\n")
    end
  end

end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Utilities</name>
				<packageName></packageName>
				<script>avalet.utilities = {}

-- Formats numbers with german thousands seperator
-- Code originally written by Richard Warburton http://richard.warburton.it
function avalet.utilities.thousands(n)
  local left,num,right = string.match(tonumber(n),'^([^%d]*%d)(%d*)(.-)$')
  return left..(num:reverse():gsub('(%d%d%d)','%1\.'):reverse())..right
end

function avalet.utilities.disp_time(time)
  local minutes = floor(mod(time,3600)/60)
  local seconds = floor(mod(time,60))
  return format("%02d:%02d",minutes,seconds)
end
</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Model</name>
			<packageName></packageName>
			<script>--[[
Die Trennung in "Model" und "View" ist hier etwas künstlich, ein echtes "Model" gibt
es vielfach gar nicht. Unter "Model" sind hier also einfach Funktionen gesammelt, die
unmittelbar in die View schreiben. Und die View ist dann der Code für das GUI an sich.
Wie sich das gehört.

Wichtig: Bei jeder Änderung der Fenstergröße wird die Oberfläche neu berechnet und neu
gemalt. Und zwar gesteuert durch den entsprechenden Event. Dafür reicht es auch schon, 
einen mehrzeiligen Text in die Eingabezeile einzugeben: Die wird dadurch größer, und
das löst den Event aus.
]]</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>initModel</name>
				<packageName></packageName>
				<script>--[[
Hier werden die Funktionen aufgerufen, in denen die Datenmodelle
zu den einzelnen Bereichen auf der Oberfläche erzeugt werden. Das
ist nicht in jedem Fall notwendig, deshalb fehlen hier ein paar
Bereiche.]]

function avalet.initModel()
  avalet.log("Function avalet.initModel()", 1)

  avalet.createIGMapModel()
  avalet.createTimerModel()
  avalet.createUnderAttackModel()
  avalet.createDistressModel()
  avalet.createHDAModel()
  avalet.createVitalsModel()
  avalet.createInfoBoxModel()
  avalet.createChatModel()

end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createIGMapModel</name>
				<packageName></packageName>
				<script>--[[
Datenmodell und dazugehörige Funktionen für den Bereich der Ingame-Map.
Die Map selber wird durch einen MapCapture-Trigger in den Buffer hier ge-
schrieben und dann direkt vom GUI angezeigt. Deshalb finden sich hier
nur die Variablen, aber keine Funktion dazu. Hier werden auch noch mehr
Variablen angelegt, die vom Trigger verwendet werden. Und auch die Doku-
mentation da ist vielleicht hilfreich, wenn es hier was zu ändern gibt. ]]

--Namensraum dazu
avalet.IGMapModel = avalet.IGMapModel or {}

--[[
Hier wird das Datenmodell erzeugt. Ein paar der Variablen benutzt der
Trigger "MapCapture". ]]
function avalet.createIGMapModel()
  avalet.log("Function avalet.createIGMapModel()", 1)

  avalet.IGMapModel.roomID = avalet.IGMapModel.roomID or ""
  avalet.IGMapModel.avalonRoomInv = avalet.IGMapModel.avalonRoomInv or ""

  createBuffer("IGmapBuffer")
  avalet.IGMapModel.mapCapture = false
  avalet.IGMapModel.mapCaptureLen = nil
  avalet.IGMapModel.mapCaptureRows = 0
  avalet.IGMapModel.mapCaptureColumns = 0
  avalet.IGMapModel.roomInvMaxRows = 0

end


--[[
Der ATCP-Wert "AvalonInv" enthält den Rauminhalt. Dazu gehören Spieler ebenso wie
Gegner, Möbel und anderes. Dieser Wert wird nicht automatisch gesendet sondern muss
aktiv angefragt werden. Das macht Avalet automatisch beim Betreten eines Raumes.
Der Wert wird (zur Zeit) dann ins Char-Objekt geschrieben. Und hier weiter ver-
arbeitet. 
Bespielwert:  
hier avalon/spieler/rofhessa "Ruad Rofhessa", avalon/wesen/cb2c195b91d1addd4ea6d40422e12ef7 "Putzteufelchen", avalon/objekt/21d7dc3e612dc0c3547cceebb151e889 "Briefkasten"
  
Die Daten sind also Komma-separiert, nur am Ende ist kein Komma. Vorgehen: "hier " 
entfernen, Rest am Komma zerlegen, dann jede Einheit einzelnd verarbeiten. 
Das Ergebnis wird als HTML-Tabelle erzeugt und dann in einem Label angezeigt. Die
Tabelle hat den Vorteil, dass sie sich auf erfreuliche Weise flexibel verhält. Die
Darstellung erfolgt in zwei Spalten: in der ersten Spalte die Gegner und die Spieler
und in der zweiten Spalte die Gegenstände, Möbel, Loot etc. Die erste Spalte ist genau
so breit, wie es notwendig ist, um deren Inhalt anzuzeigen. Steht also nur der Spieler
"Cairbre" auf einem Feld, dann ist die Spalte breit genug für 7 Zeichen. Steht "Ruad
Rofhessa" auch noch da rum, dann ist sie breiter. Die zweite Spalte nimmt den restlichen
Platz im Label ein und wird evtl. abgeschnitten. Da hier aber normalerweise die ersten
Buchstaben auch genügen, um sich zu orientieren, während andere Spieler und vor allem
Gegner deutlich wichtiger sind und vollständig angezeigt werden, funktioniert das sehr
gut bisher. ]]
function avalet.IGMapModel.processAvalonInv()
  avalet.log("Function avalet.processAvalonInv()", 1)

  local arg = avalet.char.getAvalonRoomInv()
  local objs = {}
  local objType
  local objIID
  local objName

  -- erstmal das führende "hier " abtrennen
  arg = string.gsub(arg, "hier (.*)", "%1")

  -- den Rest in die einzelnen Objekte zerlegen
  for i in string.gmatch(arg, "[^,]+") do

    for objIID, objName in string.gmatch(i, '([^"]+)["]([^"]+)["]') do
      
      objType = string.gsub(objIID, "avalon/([^/]+)/.+", "%1")
      
      table.insert(objs, {["Type"]=objType, ["IID"]=objIID, ["Name"]=objName})
      
    end

  end

  local str = "&lt;div style='vertical-align: top; text-align: left'&gt;&lt;table style='table-layout:fixed;width:90%'&gt;&lt;tr&gt;"
  local word
  
  local strSpieler = ""
  local strWesen = ""
  local strObject = ""
  local strSonstiges = ""
  
  local intLeftSideCounter = 0
  local intRightSideCounter = 0
  
  for k,v in pairs(objs) do
    if v["Type"] == "spieler" then
      strSpieler = strSpieler..v["Name"].."&lt;br&gt;"
      intLeftSideCounter = intLeftSideCounter + 1
    elseif v["Type"] == "wesen" then
      strWesen = strWesen..v["Name"].."&lt;br&gt;"
      intLeftSideCounter = intLeftSideCounter + 1
    elseif v["Type"] == "objekt" then
      strObject = strObject..v["Name"].."&lt;br&gt;"
      intRightSideCounter = intRightSideCounter + 1
    else
      strSonstiges = strSonstiges..v["Name"].."&lt;br&gt;"
      intRightSideCounter = intRightSideCounter + 1
    end
  end
  
  str = str .. "&lt;td style='overflow:hidden;width:40%;padding-right:15px;'&gt;" .. strSpieler .. strWesen .. "&lt;/td&gt;"
  str = str .. "&lt;td style='overflow:hidden;width:40%'&gt;" .. strObject .. strSonstiges .. "&lt;/td&gt;"
  
  str = str .."&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;"

  avalet.IGMapModel.avalonRoomInv = str
  
  --[[
  Die Anzahl der Einträge, die letztlich untereinander stehen werden, wird gemerkt,
  um den Bereich in der View entsprechend groß zu machen. ]]
  local maxRows = math.max(intLeftSideCounter,intRightSideCounter)
  --[[
  Ob sich die Anzahl der Zeilen im Vergleich zum Vorwert verändert hat, ist entscheidend
  dafür, ob das GUI-Element in einer anderen Größe neu gemalt werden muss. Oder ob es
  reicht, den angezeigten Text zu überschreiben. ]]
  local rowCountChange = false
  
  if maxRows ~= avalet.IGMapModel.roomInvMaxRows then
    rowCountChange = true
    avalet.IGMapModel.roomInvMaxRows = math.min(maxRows, 8) -- Max. Zeilenzahl auf 8 gesetzt
  end
  
  raiseEvent("AvalonRoomInvChange", rowCountChange)

end
registerAnonymousEventHandler("AvalonInvChange", "avalet.IGMapModel.processAvalonInv")


--[[
Hier wird die RoomID verarbeitet, wenn sie sich ändert. Also normalerweise wenn
ein neuer Raum betreten wird. Hier passiert nicht viel, aber ich wollte das 
"Model-View-Schema" beibehalten.]]
function avalet.IGMapModel.onRoomIDChange()
  avalet.log("Function avalet.onRoomIDChange()", 1)

  --[[
  Vor allem in der Unterwelt wird der Text zu lang, um ihn in einer Zeile anzuzeigen.
  Deshalb wird vor die Koordinaten ein Zeilenumbruch hinzugefügt. ]]
  local roomID = string.gsub(avalet.char.getAvalonRoomID(), " x=", "&lt;br&gt;x=", 1)
  avalet.IGMapModel.roomID = roomID
  
  raiseEvent("IGMapModelRoomIDChange")

end
registerAnonymousEventHandler("AvalonRoomIDChange", "avalet.IGMapModel.onRoomIDChange")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createTimerModel</name>
				<packageName></packageName>
				<script>--[[
Hier geht es um die Daten, die unmittelbar auf der Oberfläche angezeigt werden.
Also um die Liste mit Timern.
Auf der Oberfläche gibt es immer (derzeit: 9) Timer-Gauges, die aber per default unsichtbar
sind und auch keinen Beschriftungstext enthalten. Diese "Timer-Slots" sind so sortiert, dass
der erste Slot UNTEN ist und der letzte OBEN. DIESE Sortierung findet also nicht hier statt,
sondern ist in der Oberfläche fest eingebaut. (Aber sortiert wird hier schon, nämlich nach
Restlaufzeit.) ]]

-- Initialisierung von allem hier.
function avalet.createTimerModel()
  avalet.log("Function avalet.createTimerModel()", 1)
  
  avalet.timerModel = avalet.timerModel or {}
  avalet.timerModel.dkWaffenDaemonenName = avalet.timerModel.dkWaffenDaemonenName or nil
  avalet.timerModel.hyrasFebronEvo = avalet.timerModel.hyrasFebronEvo or false
  avalet.timerModel.hyrasFebronName = avalet.timerModel.hyrasFebronName or ""
  avalet.listOfTimers = avalet.listOfTimers or {}
end --function avalet.createTimerModel()


--[[
Rückgabewert: die sortierte Timer-Liste als Tabelle
Hier wird die Liste mit den Timern vor der Ausgabe nach Laufzeit sortiert.
Als erstes kommen dabei die Timer ohne Laufzeit, also "permantente Timer". 
Was nicht heißt, dass die länger laufen müssen als die "temporären Timer". 
Da die Liste der Timer auf der Oberfläche von UNTEN nach OBEN ausgegeben wird, 
stehen die "permanenten Timer" dort also UNTEN!. Auch wenn sie hier die ersten
in der sortierten Liste sein werden.
Durch die Sortierung nach Laufzeit ergibt sich bei den temporären Timern manchmal
die Situation, dass ein weiter oben in der Ansicht stehender Timer (= geringe 
Restlaufzeit) noch einen längeren Fortschrittsbalken hat als ein weiter unten 
stehender (= längere Laufzeit). Beispielsweise wird der Timer für "EP-Verdoppelung" 
mit einer Laufzeit von 1 Stunde und einer Restlaufzeit von 12 Minuten nur noch einen 
sehr kurzen Fortschrittsbalken haben, aber trotzdem noch länger laufen als ein 
frischer Arkanschild mit einer Laufzeit von 10 Minuten maximal. Ich fand das manchmal
irritierend und hab überlegt, die Restlaufzeit mit im Timer anzuzeigen. Aber 
eigentlich sind mir das zu viele (letztlich überflüssige) Informationen.
Diese Funktion wird jedesmal ausgeführt, wenn das UI-Element für die Timer aktualisiert
wird. Also einmal pro Sekunde derzeit.
Es werden hier immer maximal 9 Timer zurückgegeben. Mehr ist auf der Oberfläche nicht
geplant. ]]
function avalet.sortListOfTimers()
	avalet.log("Function avalet.sortListOfTimers()", 1)
  
  local sortedListOfTimers = {}
  local remaining = 0
  
  for k, v in pairs(avalet.listOfTimers) do
		
    --[[
    Wenn die "duration" auf "false" gesetzt ist, dann ist es ein Timer ohne Laufzeit, der die ganze
    Zeit mit vollem Fortschrittsbalken angezeigt wird. Und der durch einen Schluss-Trigger gelöscht
    werden muss. Sonst steht er bis zum Neustart von Mudlet in der Timer-Übersicht. ]]
    if v["duration"] == "false" then
      
      --[[
      Damit das mit dem sortieren der Liste klappt, werden hier etwas willkürlich die Werte für
      remaining und duration gesetzt. Wichtig ist, dass die Zahl größer ist als der am längsten
      laufende temporäre Timer. Das ist im Moment "EP-Verdoppelung" mit 3600 Sekunden. ]]
      table.insert(sortedListOfTimers, {["name"] = v["name"], ["remaining"] = 60000, ["duration"] = 60000})

    --[[
    Wenn "duration" NICHT false ist, ist es ein "temporärer Timer" mit abnehmendem Fortschrittsbalken.]]
    else
      
      -- Restlaufzeit frisch berechnen
      remaining = (tonumber(v["duration"]) - ((os.time() - v["starttime"])))

      --[[
      Wenn der Timer aus irgendwelchen Gründen übrig geblieben ist, soll er trotzdem irgendwann 
      gelöscht werden. Gründe könnten sein, dass die Ausgabe des MUDs irgendwie durcheinander geraten
      ist und der Beenden-Trigger deshalb nicht gegriffen hat. Oder ein connection lost oder was auch
      immer. Einen konkreten Grund gab es nicht, das ist eine Vorsichtsmaßnahme.
      Ein temporärer Timer (mit einer Laufzeit) wird also gelöscht, wenn er 30 Sekunden oder mehr über
      seine Laufzeit ist. Unter sehr ungünstigen Umständen (starke lags) kann es sein, dass 30 Sekunden
      nicht reichen. Aber ich glaube, dass das nur extrem selten passieren kann. (Ok, also mittlerweile
      benutze ich das hier länger und WEISS, dass das erstaunlich oft vorkommt. Aber ich denke, es sollte
      trotzdem bei den 30 Sekunden Puffer bleiben, nicht mehr.)
      Wenn der aktuelle Timer abgelaufen ist, dann ist der Schleifendurchlauf damit ja auch beendet. ]]
      if remaining &lt;= -30 then
        avalet.removeTimer(v["name"])
      else
        table.insert(sortedListOfTimers, {["name"] = v["name"], ["remaining"] = remaining, ["duration"] = v["duration"]})
      end
    end
  end

  -- Die fertige Timer-Liste wird jetzt noch nach Laufzeit sortiert
  local sortMyTimers = function(a, b) return a["remaining"] &gt; b["remaining"] end
  table.sort(sortedListOfTimers, sortMyTimers)
  
  -- Jetzt wird dafür gesorgt, dass die Liste maximal 9 Elemente enthält. Mehr wird
  -- auf der Oberfläche nicht angezeigt.
  while #sortedListOfTimers &gt; 9 do
    table.remove(sortedListOfTimers, 1)
  end

  return sortedListOfTimers

end --function avalet.sortListOfTimers()


--[[
Hier wird der KEY des Timers in der Timer-Liste an Hand seines Namens ermittelt. Wenn kein
Timer mit dem Namen zu finden ist, gibt die Funktion nil zurück.
Wenn der Name bspswse "Erdaura" lautet, dann muss gefunden werden:
"Erdaura I", "Erdaura II", "Erdaura III". Analog dazu die anderen Auren. Und Schild I bis V.
Diese Funtion gibt die ERSTE Fundstelle zurück und endet dann. Wenn man mehrere Treffer
erwartet, sollte man die Funktion avalet.findListOfTimerByName() weiter unten verwenden. ]]
function avalet.findTimerByName(name)
	avalet.log("function avalet.findTimerByName(name)", 1)

  --[[
  string.find funktioniert nicht mit Zeichen wie dem Bindestrich. Das führte zu Problemen
  bei dem Timer für "EP-Verdoppelung". Hier die Lösung. ]]
  for k, v in pairs(avalet.listOfTimers) do

      if string.find(v["name"], string.gsub(name, "%-", "%%-")) then return k end
      
  end
  return nil
end --function avalet.findTimerByName(name)


--[[
Hier wird der KEY der Timer in der Timer-Liste an Hand ihres Namens ermittelt. Wenn kein
Timer mit dem Namen zu finden ist, gibt die Funktion eine leere Liste zurück. Diese
Funktion ist für Timer, die für den gleichen Zauber (bzw. die gleiche Funktion) erzeugt
werden. Ein Beispiel dafür ist die Waffenverstaerkung der Daemonenkrieger. Da man als DK
mehrere Daemonen in mehrere Waffen binden kann, kann es auch mehrere Waffenverstaerkungs-
Timer geben. Benannt sind die dann mit "Waffenverstaerkung &lt;Daemonenname&gt;". Die sollen 
hier gefunden werden. ]]
function avalet.findListOfTimerByName(name)
	avalet.log("function avalet.findListOfTimerByName(name)", 1)

  local retList = {}
  --[[
  string.find funktioniert nicht mit Zeichen wie dem Bindestrich. Das führte zu Problemen
  bei dem Timer für "EP-Verdoppelung". Hier die Lösung. ]]
  for k, v in pairs(avalet.listOfTimers) do

      if string.find(v["name"], string.gsub(name, "%-", "%%-")) then 
        table.insert(retList, k) 
      end
      
  end
  return retList
end --function avalet.findTimerByName(name)


--[[
Diese Funktion wird von den Triggern verwendet, die einen Timer erzeugen.
Der Timer wird hier der Tabelle "listOfTimer" hinzugefügt, anschließend
wird die Tabelle mit den sortierten Timern neu erzeugt und die Anzeige
auf der Oberfläche aktualisiert. ]]
function avalet.registerTimer(name, duration, param)
  avalet.log("function avalet.registerTimer(name, duration, param)", 1)

  -- Sonderloesung fuer DKs, weil hier der Name des Daemon verwendet wird.
  if name == "Waffenverstaerkung" then 
    param = avalet.timerModel.dkWaffenDaemonenName
    avalet.timerModel.dkWaffenDaemonenName = nil
  end
  
  --[[
  Sonderloesung fuer Hyraskrieger, weil hier der Febronen-Name verwendet wird.
  Die Texte (bzw. die RexExp-Patterns dafuer) bei den Febronen scheinen mir 
  nicht sicher eindeutig zu sein, ich schliess deshalb hier erstmal false 
  positives aus. Und dann wird der Febronenname als Parameter gesetzt. Das 
  funktioniert so:
  Sowohl 'hyrasFebronEvo' als auch 'hyrasFebronName' werden durch einen Trigger 
  auf die erste Zeile beim evolieren erkannt und gesetzt. Die sollte eindeutig
  sein. Wenn also der eigentliche Start-Trigger auf irgendwas anderes als den 
  gewuenschten Text reagiert, dann wird hier "hyrasFebroEvo" NICHT true sein.
  Zurueckgesetzt werden die Werte hier dann auch. ]]
  if (string.find(name, "febron") ~= nil) then
    if (avalet.timerModel.hyrasFebronEvo ~= true) then
      avalet.log("ABBRUCH weil hyrasFebronEvo nicht 'true' (false positive?)", 3)
      return
    else
      avalet.log("Febronentimer erkannt: "..name..", "..param, 2)
      avalet.timerModel.hyrasFebronEvo = false
      avalet.timerModel.hyrasFebronName = ""
    end
  end

  param = param or nil
  if param ~= nil then
    name = name .. " " .. param
  end
  if duration == false or duration == nil then
    duration = "false"
  end
  
  --[[
  Hier wird der Zähler "Schildzauber" initialisiert. ]]
  if avalet.CONSTS.SCHILDZAUBER[name] then
    avalet.log("Initialisiere SchildzauberEP-Zähler für Zauber: "..name, 2)
    avalet.char.schildEPStart()
  end
  
  if name == "Schild" then
    if string.find(avalet.char.getSchutz(), name .. " V") then
      name = name .. " V"
    elseif string.find(avalet.char.getSchutz(), name .. " IV") then
      name = name .. " IV"
    elseif string.find(avalet.char.getSchutz(), name .. " III") then
      name = name .. " III"
    elseif string.find(avalet.char.getSchutz(), name .. " II") then
      name = name .. " II"
    elseif string.find(avalet.char.getSchutz(), name .. " I") then
      name = name .. " I"
      duration = "180"       -- Schild I hat eine verringerte Dauer
    end
  end
  
  if name == "Weissschild" or name == "Schwarzschild" then
    if string.find(avalet.char.getSchutz(), name .. " II") then
      name = name .. " II"
    elseif string.find(avalet.char.getSchutz(), name .. " I") then
      name = name .. " I"
    end
  end
  
  if name == "Erdaura" or name == "Feueraura" or name == "Lebensaura" or name == "Todesaura" or name == "Luftaura" or name == "Wasseraura" then
    if string.find(avalet.char.getSchutz(), name .. " III") then
      name = name .. " III"
      duration = "1200"
    elseif string.find(avalet.char.getSchutz(), name .. " II") then
      name = name .. " II"
    elseif string.find(avalet.char.getSchutz(), name .. " I") then
      name = name .. " I"
    end
  end
  
  --[[
  Der Zauber "Gedankenpeitsche" der Dämonenkrieger verlängert die Wirkung verschiedener
  anderer DK-Zauber bzw. -Fähigkeiten. Nämlich Ruestungsverstaerkung, Waffenverstaerkung
  und vermutlich auch Verschmelzung, aber dafür ist mein DK noch zu klein.
  Die Dämonenkrieger haben außerdem die nette Fähigkeit, zauber aktualisieren zu können. 
  Konkret kann man "beschützen" (Timer heißt "Daemonenschutz") jederzeit neu zaubern und 
  erhält dann wieder 10 Minuten Schutz. Ohne vorher irgendwas beenden zu müssen.
  Druiden koennen das auch, bei ihren Ritualen. 
  Avalet bildet das so ab, dass die starttime der dazugehörigen Timern resettet wird. ]]
  -- --avalet.findTimerByName(name)["name"] = name, ["starttime"] = os.time(),
  local key = avalet.findTimerByName(name)
  if name == "Daemonenschutz" and key ~= nil then
    avalet.listOfTimers[key]["starttime"] = os.time() 
  elseif name == "Gedankenpeitsche" then
    key = avalet.findTimerByName("Ruestungsverstaerkung")
    if key ~= nil then 
      avalet.listOfTimers[key]["starttime"] = os.time() 
    end
    local keyList = avalet.findListOfTimerByName("Waffenverstaerkung")
    if #keyList &gt; 0 then
      for _, j in pairs(keyList) do
        avalet.listOfTimers[j]["starttime"] = os.time()
      end
    end 
    key = avalet.findTimerByName("Verschmelzung")
    if key ~= nil then
      avalet.listOfTimers[key]["starttime"] = os.time() 
    end 
  -- Und die Druiden-Rituale:
  elseif name == "Baumwaechter" and key ~= nil then 
    avalet.listOfTimers[key]["starttime"] = os.time() 
  elseif name == "Blaetterhaut" and key ~= nil then 
    avalet.listOfTimers[key]["starttime"] = os.time() 
  elseif name == "Blumenkind" and key ~= nil then 
    avalet.listOfTimers[key]["starttime"] = os.time() 
  elseif name == "Egelschreck" and key ~= nil then 
    avalet.listOfTimers[key]["starttime"] = os.time() 
  elseif name == "Friedfertigkeit" and key ~= nil then 
    avalet.listOfTimers[key]["starttime"] = os.time() 
  elseif name == "Heilende Hand" and key ~= nil then 
    avalet.listOfTimers[key]["starttime"] = os.time() 
  elseif name == "Holzhaut" and key ~= nil then 
    avalet.listOfTimers[key]["starttime"] = os.time() 
  elseif name == "Immunitaet" and key ~= nil then 
    avalet.listOfTimers[key]["starttime"] = os.time() 
  elseif name == "Kampfeslust" and key ~= nil then 
    avalet.listOfTimers[key]["starttime"] = os.time() 
  elseif name == "Kesselzwang" and key ~= nil then 
    avalet.listOfTimers[key]["starttime"] = os.time() 
  elseif name == "Leben finden" and key ~= nil then 
    avalet.listOfTimers[key]["starttime"] = os.time() 
  elseif name == "Lebenshaar" and key ~= nil then 
    avalet.listOfTimers[key]["starttime"] = os.time() 
  elseif name == "Todeshaar" and key ~= nil then 
    avalet.listOfTimers[key]["starttime"] = os.time() 
  elseif name == "Narbenheilung" and key ~= nil then 
    avalet.listOfTimers[key]["starttime"] = os.time() 
  elseif name == "Pflanzenblick" and key ~= nil then 
    avalet.listOfTimers[key]["starttime"] = os.time() 
  elseif name == "Puffpilz" and key ~= nil then 
    avalet.listOfTimers[key]["starttime"] = os.time() 
  elseif name == "Waffenleben" and key ~= nil then 
    avalet.listOfTimers[key]["starttime"] = os.time() 
  else

    table.insert(avalet.listOfTimers, {["name"] = name, ["starttime"] = os.time(), ["duration"] = duration})
    -- Fuer Statistik etc.
    -- avalet.onTimerAddedEvent(eventName, charName, timerName)
    raiseEvent("timerAddedEvent", avalet.char.getName(), name)
  
  end
  
  raiseEvent("RecreateTimerView")

end --function avalet.registerTimer(name, duration, param)



--[[ function removeTimer("Magiertrance")
Diese Funktion wird aufgerufen, wenn ein Timer gelöscht werden soll. Also wenn er 
abgelaufen ist (bei denen, die von selbst terminieren) oder wenn das Ereignis ausgelöst
wird, das den Timer beendet. (Das ist der häufigere Fall, weil sich die Anzeige da
letztlich nach dem MUD richtet. Wenn das MUD sagt, dass die KB aus ist, dann ist sie aus.
Viele Zauber sind ohnehin nicht sonderlich pünktlich, aber die Laufzeit kann sich auch 
durch lags verlängern. Teilweise ganz erheblich. Das "von selbst terminieren" ist deshalb
eigentlich unglücklich, geht aber manchmal nicht anders. Beispiel dafür ist die 
"EP-Verdoppelung", die vom MUD nicht abgekündigt wird.)
Speziell die Kleriker-Segen machen hier eine Sonderbehandlung notwendig, womit sich der
Parameter "param" begründet. Da diese Segen (Rüstungssegen, Waffensegen und Schildsegen)
die gleichen Texte ausgeben, und der Trigger deshalb nicht erkennen kann, mit welchem 
Zauber er es zu tun hat. Und da aber beim LÖSCHEN des Timers wichtig ist, nicht den falschen
zu löschen. Versucht der Trigger, den GEGENSTAND, auf den Gezaubert wird, aus dem getriggerten
Text auszulesen. Was auch eigentlich ganz gut gelingt, aber nicht immer schick ist. Dieser
Gegenstands-Name wird dann für den Namen des Timers verwendet. Es ergibt sich also sowas wie
"Segen: Langschwert" oder (schlimmstenfalls) "Segen: Paar Echsenlederhandschuhe". Wenn der Timer
dann später gelöscht werden soll, muss das mit diesem Namen geschehen. Und der steht hier im
Parameter "param". Diese Lösung ist nicht schön, und wenn die Götter mein flehentliches Bitten
erhören, bekommt Avalet hoffentlich künftig den Zauber per ATCP. Aber erstmal ist es jetzt so. ]]
function avalet.removeTimer(name)
  avalet.log("function avalet.removeTimer(name)", 1)
  
  --cecho("&lt;magenta&gt;\nfunction avalet.removeTimer("..name..")\n")

  --[[
  Hier wird der Zähler für die EP-Verdoppelung beendet, wenn der Timer gelöscht wird.
  Das muss geschehen, damit der Zähler als 'inaktiv' (weiss) auf der Oberfläche ange-
  zeigt wird. ]]
  if name == "EP-Verdoppelung" then
    avalet.char.bonusEPStop()
  end

  local key = avalet.findTimerByName(name)
  if key ~= nil then
    --cecho("&lt;magenta&gt;\ngelöscht wird der timer mit dem key: "..key.."\n")
    table.remove(avalet.listOfTimers, key)
  end
  
  -- Die Anzeige auf der Oberfläche erneuern:
  raiseEvent("RecreateTimerView")
end --function avalet.removeTimer(name)



--[[
]]
function avalet.deregisterTimer(name, param)
  avalet.log("function avalet.deregisterTimer(name, param)", 1)

  --[[
  Hier wird der Zähler "Schildzauber" beendet. ]]
  if avalet.CONSTS.SCHILDZAUBER[name] then
    avalet.log("Beende SchildzauberEP-Zähler für Zauber: "..name, 2)
    avalet.char.schildEPStop()
  end
  
  --[[
  Sonderloesung fuer Hyraskrieger, weil hier der Febronen-Name verwendet wird.
  Die Suchstrings bei den Febronen auch (und grade) beim Ende der Laufzeit 
  nicht so pralle, deshalb wird auch hier der Umweg über den Namen gemacht.
  Wieder werden sowohl 'hyrasFebronEvo' als auch 'hyrasFebronName' durch einen 
  Trigger erkannt und gesetzt. Und hier dann gleich noch wieder ge-nil-t. ]]
  if (string.find(name, "febron") ~= nil) then
    --cecho("&lt;magenta&gt;\nEin Febron wird eingesackt: "..name.." "..param.."\n")
    if param == "alle" then
      --cecho("&lt;magenta&gt;\nParam 'alle' wird genilt.\n")
      param = nil
    end
  end

  --[[
  Der Parameter "param" ist optional und wird hier deshalb erstmal zuverlässig gemacht.
  Wenn ein param gegeben ist, wird er zum Teil des Namens. ]]
  param = param or nil
  if param ~= nil then
    name = name .. " " .. param
  end

  avalet.removeTimer(name)
  raiseEvent("RecreateTimerView")
end --function avalet.deregisterTimer(name, param)


--[[
Hier wird der Sekunden-Timer, der die Timer jeweils neu
berechnen lässt, aktiviert bzw. deaktiviert. ]]
function avalet.onRecreateTimerView(event, args)
	avalet.log("function avalet.onRecreateTimerView(event, args)", 1)

  -- Warum auch immer die Anzahl der Elemente in listOfTimers = nil sein sollte...
  if #avalet.listOfTimers ~= nil then
    -- Wenn es Timer in der listOfTimers gibt...
    if #avalet.listOfTimers &gt; 0 then
      -- ... muss auch der Timer laufen, der einmal pro Sekunde die Timer-Anzeige
      -- auf der Oberfläche aktualisiert.
      enableTimer("avaletTimersTimer")
    else
      -- Ohne anzuzeigende Timer in der Liste kann der Aktualisierungs-Timer Pause machen
      disableTimer("avaletTimersTimer")
    end
  else
    disableTimer("avaletTimersTimer")
  end
  -- Schließlich wird noch die Oberfläche aktualisiert.
  avaletUI.recreateTimer()
end --function avalet.onRecreateTimerView(event, args)
registerAnonymousEventHandler("RecreateTimerView", "avalet.onRecreateTimerView")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createUnderAttackIconModel</name>
				<packageName></packageName>
				<script>--[[
]]

function avalet.createUnderAttackModel()
  avalet.log("Function avalet.createUnderAttackModel()", 1)
  --[[
  Das "under attack"-Symbol hat eigentlich nur zwei Zustände.
  Kampf oder kein Kampf. ]]
  avalet.underAttack = false --initialisierung

end --function avalet.createUnderAttackModel()
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createDistressIconModel</name>
				<packageName></packageName>
				<script>function avalet.createDistressModel()
  avalet.log("Function avalet.createDistressModel()", 1)
  
  avalet.distress = avalet.distress or false

end


function avalet.DiseaseChange()
  avalet.log("Function avalet.DiseaseChange()", 1)

  if avalet.char.getFluch() or avalet.char.getKrankheit() or avalet.char.getVergiftung() then
    avalet.distress = true
  else
    avalet.distress = false
  end 

  raiseEvent("DistressModelChange")
end
registerAnonymousEventHandler("DistressChange", "avalet.DiseaseChange")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createHDAModel</name>
				<packageName></packageName>
				<script>--[[
Hunger-/Durst-/Alkohol-Anzeige (HDA)
Die meisten Völker haben 7 unterschiedliche Hunger-Meldungen. Oger und Hobbits haben 13.
Die Meldung mit dem Index 1, das ist die "ist völlig gesättigt"-Meldung, soll auf der
Oberfläche nicht extra angezeigt werden. Die restlichen Meldungen müssen in den auf der
Oberfläche zu sehenden 6 Kästchen angezeigt werden. (Später gibts vielleicht mal
halbe Kästchen.)
Zuordnung also:
Index Oger/Hobbits | Index andere | Kästchen
       1                   1           keins
       2- 3                2           1 (grün)
       4- 5                3           2 (gelb)
       6- 7                4           3 (gelb)
       8- 9                5           4 (gelb)(?)
      10-11                6           5 (rot)
      12-13                7           6 (rot)
Formel also für Oger und Hobbits: math.ceil((Index + 1) / 2) ]]


local HUNGER_TEXT = {
  "Du hast ein unangenehmes Voellegefuehl.",
  "Du hast ausreichend gegessen.",
  "Dein Magen knurrt.",
  "Du verspuerst Hunger.",
  "Dir wird fast schlecht vor Hunger.",
  "Deine Gedanken kreisen nur noch um Deinen Hunger.",
  "Wenn Du jetzt nicht bald was zwischen die Zaehne bekommst ..."
}

-- Hunger-Meldungen für Hobbits.
-- Im MUD ist einer mehrzeilig, und zwar der hier:
-- "Wenn Du nicht langsam etwas isst, wirst Du Deine Vorfahren begruessen"
-- "koennen."
local HUNGER_HOBBIT_TEXT = {
  "Dein Bauch steht dick und rund von Dir ab.",
  "Ein Exxe waere jetzt schon explodiert, aber Du bist gerade mal satt.",
  "Dein Bauch ist schon recht prall.",
  "Du bist schon ein bisschen satt.",
  "Ein Mensch waere jetzt zwar satt, aber Du kannst noch 'ne Menge vertragen.",
  "Du hast gerade mal ausreichend gegessen.",
  "Dein Magen verlangt nach einer Zwischenmahlzeit.",
  "Du koenntest jetzt schon gut etwas zu beissen vertragen.",
  "Du hast das Gefuehl, das letzte Essen waere bereits eine Woche her.",
  "Du kannst Dich kaum auf den Beinen halten vor Hunger.",
  "Ein gefuellter Ochse waere jetzt noch zu wenig zum Essen.",
  "Du hast das Gefuehl, ein riesiges Loch im Bauch zu haben.",
  "Wenn Du nicht langsam etwas isst, wirst Du Deine Vorfahren begruessen koennen."
}


local HUNGER_OGER_TEXT = {
	"Dein prall gefuellter, riesiger Ogerbauch ist Dein ganzer Stolz.",
	"Du fuehlst Dich satt und gluecklich, ganz so wie Fleissig-Oger es verdient.",
	"Ein wenig Platz ist in Deinem Bauch schon noch, aber dieses seltsame Knurren ist verschwunden. Fressen aus Leidenschaft ist nun angesagt.",
	"Mit ausreichend vollem Magen kannst Du Dich wieder auf andere Dinge als die Nahrungsbeschaffung konzentrieren - auf das Toeten aus Spass zum Beispiel.",
	"Ein wenig Lust auf Naschen haettest Du ja schon, ob Du irgendwo ein leichtes Opfer findest? Das schwarze Buch ist eine gute Speisekarte.",
	"Wirklich Hunger hast Du nicht mehr, aber so ein paar kleine Orks wuerden Dir noch munden.",
	"Langsam wird es wieder Zeit fuer einen kleinen Snack wie zum Beispiel eine Kuh oder ein Schaf - sonst faellst Du noch vom Fleisch!",
	"Dein Magen knurrt in regelmaessigen Abstaenden, sehr zur Beunruhigung Deiner Umgebung.",
	"Dein Bauch fuehlt sich leer und hungrig an. Jetzt wird es langsam Zeit fuer eine kleinere Zwischenmahlzeit. Ein Elefant waere jetzt lecker?",
	"So hungrig faellt Dir das Denken schwer. Noch schwerer, als ohnehin schon.",
	"Wenn Du jetzt nicht bald ein Orkdorf leernaschst...",
	"So hungrig wie Du bist, wirst Du zur ernsten Gefahr fuer Deine Umgebung.",
	"Kurz vor dem Verhungern treibt Dich nur noch ein Gedanke an, die Suche nach Fressen!",
}



local DURST_TEXT = {
  "Es schwappt und gluckert in Deinem Bauch.",
  "Du hast ausreichend getrunken.",
  "Du hast ein trockenes Gefuehl in der Kehle.", 
  "Du bist durstig.", 
  "Deine Zunge klebt Dir am Gaumen.",       
  "Du kannst vor Durst kaum noch klar denken.",
  "Wenn Du Dir jetzt nicht bald was zwischen die Kiemen kippst ..."
}

local ALKOHOL_TEXT = {
  "Du bist nuechtern.",
  "Du bist wieder nuechtern.",
  "Du bist angeheitert.",
  "Du hast einen Schwips.", 
  "Du bist betrunken.", 
  "Du hast einen maechtigen Rausch.",
  "Du bist sternhagelvoll.",
  "Die Welt dreht sich um Dich."
}

local function getIndexOf(t,val)
  for k,v in ipairs(t) do 
      if v == val then return k end
  end
  return 0
end


avalet.hda = avalet.hda or {}


function avalet.createHDAModel()
  avalet.log("Function avalet.createHDAModel()", 1)
  
  avalet.hda.hungerIndex = 0
  avalet.hda.durstIndex = 0
  avalet.hda.alkIndex = 0
  
end --function avalet.createHDAModel()


function avalet.onRefreshHDA()
  avalet.log("Function avalet.onRefreshHDA()", 1)
  
  avalet.hda.hungerIndex = getIndexOf(HUNGER_TEXT, avalet.char.getHunger())
  if avalet.hda.hungerIndex == 0 then
    avalet.hda.hungerIndex = getIndexOf(HUNGER_HOBBIT_TEXT, avalet.char.getHunger())
    if avalet.hda.hungerIndex ~= 0 then avalet.hda.hungerIndex = math.ceil((avalet.hda.hungerIndex + 1) / 2) end
  end
  if avalet.hda.hungerIndex == 0 then
    avalet.hda.hungerIndex = getIndexOf(HUNGER_OGER_TEXT, avalet.char.getHunger())
    if avalet.hda.hungerIndex ~= 0 then avalet.hda.hungerIndex = math.ceil((avalet.hda.hungerIndex + 1) / 2) end
  end
  avalet.hda.durstIndex = getIndexOf(DURST_TEXT, avalet.char.getDurst())
  avalet.hda.alkIndex = getIndexOf(ALKOHOL_TEXT, avalet.char.getAlk())
  
  avaletUI.buildHDAUI()

end --function avalet.onRefreshHDA()
registerAnonymousEventHandler("RefreshHDA", "avalet.onRefreshHDA")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createVitalsModel</name>
				<packageName></packageName>
				<script>--[[
Hier werden die "Vitals" berechnet und angezeigt, also die Gauge-
Elemente für TP, ZP, AP, Mana und den Tick. Ausgelöst wird die
Aktualisierung von TP, ZP, AP und Mana durch einen Event, der auf
ATCP-Daten reagiert. Deshalb wird hier also für jedes Element eine
entsprechende Funktion vorgesehen. Der Tick wird anders behandelt.

Das "Tick"-Element ist eigentlich ein Timer, der anzeigt, wann es
wieder TP, AP und ZP vom MUD gibt. Das ist alle 40 Sekunden der Fall.
Die Anzeige funktioniert nicht fehlerfrei - aber wenn es drauf an-
kommt, sollte sie auch zuverlässig sein. Also im Kampf. Schwieriger
wirds wenn die "Vitals" alle auf Maximum sind. Oder wenn der Char 
zwischendurch auf anderem Weg dort Punkte bekommt. (Heilzauber z.B.)

Das "Gauge"-Element von Mudlet wird bei einem "current value" von 0
vollständig gefüllt angezeigt. (Statt vollständig geleert, was ja ein
Punktestand von 0 eigentlich bedeuten würde.) Und ich hab keine Ahnung,
was bei einem negativen Wert passieren würde. Deshalb wird hier jeder
Wert kleiner als 1 auf 1 gesetzt. In dem Text auf dem Gauge muss aber
natürlich der wirkliche Wert stehen, deshalb die unterschiedliche
Behandlung hier.

Ich dokumentier mal nur die erste Funktion, die anderen verhalten sich
analog.
]]

avalet.vitals = avalet.vitals or {}

function avalet.createVitalsModel()
  avalet.log("Function avalet.createVitalsModel()", 1)

  avalet.vitals.health = avalet.vitals.health or {
    ["currentValue"] = 0,
    ["maxValue"] = 0,
    ["valueToDisplay"] = 0,
    ["percent"] = 0
  }

  avalet.vitals.endurance = avalet.vitals.endurance or {
    ["currentValue"] = 0,
    ["maxValue"] = 0,
    ["valueToDisplay"] = 0,
    ["percent"] = 0
  }

  avalet.vitals.spellpoints = avalet.vitals.spellpoints or {
    ["currentValue"] = 0,
    ["maxValue"] = 0,
    ["valueToDisplay"] = 0,
    ["percent"] = 0
  }

  avalet.vitals.mana = avalet.vitals.mana or {
    ["currentValue"] = 0,
    ["maxValue"] = 0,
    ["valueToDisplay"] = 0,
    ["percent"] = 0
  }
  
  --avalet.vitals.tickTime = avalet.vitals.tickTime or 0
  --[[
  Hier drin werden hauptsächlich die letzten Werte gespeichert, damit Veränderungen
  im Vergleich zum letzten Wert ermittelt werden können. Steigende Werte wären ein
  Zeichen für einen Tick, sinkende nicht. ]]
  avalet.vitals.tickTimer = avalet.vitals.tickTimer or {
    ["TP"] = {["maxValue"] = nil, ["lastValue"] = nil, ["thisValue"] = nil, ["time"] = nil}, 
    ["AP"] = {["maxValue"] = nil, ["lastValue"] = nil, ["thisValue"] = nil, ["time"] = nil}, 
    ["ZP"] = {["maxValue"] = nil, ["lastValue"] = nil, ["thisValue"] = nil, ["time"] = nil}
  }
  avalet.vitals.tickTimerList = avalet.vitals.tickTimerList or {}
  avalet.vitals.tickTimerItem = {
    ["time"] = 0,
    ["weight"] = 0,
    --[""] = "",
    --[""] = "",
  }
  
  avalet.vitals.TICK_TIMER_FREQUENCY = avalet.CONSTS.TICK_TIMER_FREQUENCY
  
end --function avalet.createVitalsModel()


function avalet.vitals.updateAllVitals()
  avalet.log("Function avalet.vitals.updateAllVitals()", 1)

  local vitals = avalet.char.getStats()
  
  raiseEvent("VitalsChange", {"TP", vitals.tp,vitals.tp_max})
  raiseEvent("VitalsChange", {"AP",vitals.ap,vitals.ap_max})
  raiseEvent("VitalsChange", {"ZP",vitals.zp,vitals.zp_max})
  raiseEvent("VitalsChange", {"MP",vitals.mp,vitals.mp_max})

end --function avalet.vitals.updateAllVitals()


function avalet.vitals.updateVitalsModel(event, args)
  avalet.log("Function avalet.vitals.updateVitalsModel(event, args)", 1)

  local vital = args[1]

 	local currentValue = args[2]
  local maxValue = args[3]
  
  local valueToDisplay
  local percent
  
  local event = ""
  
  if vital == "TP" then vital = "health" 
  elseif vital == "AP" then vital = "endurance"
  elseif vital == "ZP" then vital = "spellpoints"
  elseif vital == "MP" then vital = "mana"
  end
   
  valueToDisplay, percent = avalet.vitals.processVitalValues(currentValue, maxValue)

  avalet.vitals[vital] = {
    ["currentValue"] = currentValue,
    ["maxValue"] = maxValue,
    ["valueToDisplay"] = valueToDisplay,
    ["percent"] = percent
  }
  
  raiseEvent("VitalsModelChange", vital)

end --function avalet.vitals.updateVitalsModel(event, args)
registerAnonymousEventHandler("VitalsChange", "avalet.vitals.updateVitalsModel")


--[[
Die Verarbeitung der Werte ist für alle vier Gauge-Elemente gleich,
daher ausgelagert. ]]
function avalet.vitals.processVitalValues(currValue, maxValue)
  avalet.log("Function avalet.vitals.processVitalValues(currValue, maxValue)", 1)

  local valueToDisplay = currValue
  -- Negative Werte für das Gauge-Element vermeiden.
	if valueToDisplay &lt; 1 then valueToDisplay = 1 end
	
  --[[
  Bei der Berechnung des Prozentwertes gibt es zwei Besonderheiten.
  Einmal müssen Rundungsfehler abgefangen werden, die auftreten
  wenn currentValue == maxValue. Dieser Fall wird also manuell auf
  "100%" gesetzt. Der andere Fall ist, wenn currentValue kleiner als
  Null ist. Dieser Fall wird hier manuell auf "0%" gesetzt. Alles
  andere wird ausgerechnet. ]]
	local percent = nil
  if currValue == maxValue then
    percent = 100
  elseif currValue &lt;= 0 then
    percent = 0
  else 
    percent = math.floor((100 / maxValue) * currValue)
  end

  return valueToDisplay, percent

end --avaletUI.processVitalValues(currValue, maxValue)

--[[
Der Tick-Timer
... versucht anzuzeigen, wann es wieder einen Schub TP, ZP und AP gibt. Das ist etwa alle 40 Sekunden der Fall.
Da es aber auch aus anderen Gründen diese Punkte geben kann - Tränke, Honig, Lebensaugen... -, muss  irgendwie
sicher gestellt sein, dass der Tick-Timer dadurch nicht durcheinander gerät. Schwierigkeit ist auch, dass es 
diese Punkte natürlich nur gibt, wenn dem Char grade Punkte zum Maximalwert fehlen. Es wäre aber wünschenswert,
die Anzeige auch dann noch eine Zeit lang zu haben, wenn die Punkte wieder voll sind.
Die Motivation zu dieser Funktion ist übrigens, dass es für Magier durchaus einen Unterschied macht, ob sie
Magiertrance laufen haben oder nicht, wenn der Tick kommt. Das sind richtig viele Punkte, die da unter Umständen
verloren gehen. Und manchemal ist eben die Frage, ob man die Magiertrance auslaufen lässt und dann erst erneuert.
Oder ob man sie abbricht, um sie dann früher zu erneuern. Das kann sich durchaus lohnen. Und es gibt auch andere
Situationen, beispielsweise im Kampf, wenn die Frage ist, ob für die nächste Runde noch genug Punkte für die
Angriffszauber vorhanden sein werden oder ob man den Kampf lieber vorher verlässt. Ob diese Funktion auch für
andere Gilden nützlich ist muss ich erst noch ausprobieren. Aber mir würde es auch reichen, wenn sie nur für
Magier interessant wäre.
So ganz richtig funktioniert das noch nicht. Aber selbst wenn ich die kleine Ungenauigkeit noch finde, die sich
im Moment im Nachlauf schnell summiert: um die Funktion deutlich robuster zu machen, müsste man sie vermutlich
auf Stopwatch umstellen. Wegen der Genauigkeit im Millisekunden-Bereich. Und dann die genaue Distanz zwischen
zwei Ticks messen und die dann verwenden statt pauschal "40 Sekunden". Ob sich das lohnt überlege ich mir,
wenn ich ein bisschen damit gespielt habe. 

Erstmal die Hilfsfunktionen]]

function avalet.vitals.addTickTimer(intTime)

  local t = intTime
  local jobDone = false
  
  avalet.log("addTickTimer: #avalet.vitals.tickTimerList: "..tostring(#avalet.vitals.tickTimerList), 2)
  if #avalet.vitals.tickTimerList == 0 then
    avalet.log("addTickTimer: es gibt noch keine tickTimer, füge einen hinzu", 2)
    table.insert(avalet.vitals.tickTimerList, {["time"]=t, ["weight"]=0})
    return
  end
  
  for k, v in pairs(avalet.vitals.tickTimerList) do
    local period = t - v["time"]
    --[[
    Alte Timer laufen noch eine Zeit lang weiter, wenn keine neuen Timer hinzugefügt
    werden. Und schön wäre es, wenn man das einfach so fortführen könnte, also wenn man
    einen sicheren Tick-Timer gefunden hat den einfach immer weiter laufen lassen. Das
    dürfte aber sehr Lag-anfällig sein. Deshalb hab ich das so gelöst, dass ein sehr
    sicherer (=schwergewichtiger) Timer noch eine Zeit lang angezeigt wird, aber ein
    neu hinzukommender Timer alte Timer erstmal löscht. "Alt" ist hier "Tick-Frequenz
    plus 10 Sekunden", etwas willkürlich festgelegt. Muss aber größer als "Tick-Fre-
    quenz" sein. ]]
    local timerIsToOld = false
    if period &gt; (avalet.vitals.TICK_TIMER_FREQUENCY+10) then timerIsToOld = true end
    
    local timerIsNearlyEqual = false
    local diff = period%avalet.vitals.TICK_TIMER_FREQUENCY
    local offset
    
    if diff &lt;= 1 then 
      timerIsNearlyEqual = true
      offset = diff
    end
    if diff == avalet.vitals.TICK_TIMER_FREQUENCY-1 then 
      timerIsNearlyEqual = true
      offset = -1
    end
    
    if timerIsToOld then
      avalet.log("Timer älter als "..tostring(avalet.vitals.TICK_TIMER_FREQUENCY+10).." Sekunden gefunden, lösche Timer", 2)
      avalet.vitals.tickTimerList[k] = nil
       --break
    elseif timerIsNearlyEqual then
      avalet.log("Passenden Timer gefunden, diff: "..tostring(offset)..", erhöhe Gewicht", 2)
      v["weight"] = v["weight"] + 10
      v["time"] = t -- - diff
      jobDone = true
    else
      avalet.log("UNpassenden Timer gefunden, diff="..tostring(period%avalet.vitals.TICK_TIMER_FREQUENCY)..", REDUZIERE Gewicht", 2)
      v["weight"] = v["weight"] - 1
    end -- if
  end -- for
  
  if not jobDone then
    avalet.log("addTickTimer: füge zusätzlichen Timer hinzu", 2)
    table.insert(avalet.vitals.tickTimerList, {["time"]=t, ["weight"]=10})
  end
  
end

function avalet.vitals.getHeaviestTickTimer()
  local t = os.time()
  
  if #avalet.vitals.tickTimerList == 0 then
    return nil
  end

  local sorted = {} 
  for k, v in pairs(avalet.vitals.tickTimerList) do
    --[[
    Wenn der Wert älter ist, das Gewicht aber hoch, kann der TickTimer ja auch noch eine Zeit
    lang anzeigen. Hier wird das Gewicht dabei immer weiter reduziert. Geht das dabei unter
    Null, ist schluss mit anzeige. ]]
    local time = v["time"]
    local weight = v["weight"]
    local timediff = os.time() - time
    if timediff &gt; avalet.vitals.TICK_TIMER_FREQUENCY then 

      -- Runden seit der TickTimer aktuell war:
      local i = math.floor(timediff / avalet.vitals.TICK_TIMER_FREQUENCY)
      -- mit jeder Runde wird das Gewicht des Timers reduziert. So wird
      -- ein sehr sicherer (= gewichtiger) Timer noch eine gewisse Zeit
      -- weiterlaufen, ein leichtgewicht wird schneller verschwinden.
      -- Die Genauigkeit leidet dann übrigens recht schnell.
      weight = math.floor(v["weight"]/(2^i))-10 

    end
 
    if weight &lt; 0 then break end

    table.insert(sorted,{k,v})
  end
 
  if #sorted == 0 then return nil end

  table.sort(sorted, function(a,b) return a[2]["weight"] &gt; b[2]["weight"] end)

  return sorted[1][2]
end


--[[
Und die Hauptfunktion für den Tick-Timer.

Der Ansatz hier ist folgender: Bei jedem Plus an Punkten wird versucht, diesem Ereignis ein "Gewicht" zu geben.
Das Gewicht drückt aus, wie zuverlässig das ein "Tick" ist. Und nicht z.B. Lebensaugen. Dabei werden verschiedene
Faktoren berücksichtigt. Kommen beispielsweise mehr oder weniger gleichzeitig TP, AP und ZP, dann ist es mit
ziemlicher Sicherheit ein "Tick". Kommt nur eins davon, obwohl die anderen Werte auch nicht auf Maximum stehen, ist
es eher kein Tick. Kommt nur eins, die anderen Werte stehen aber auf Maximum, ist es schwieriger. Aber wenn der
letzte Tick zufällig grade 40 Sekunden her ist, ist es vermutlich wieder ein Tick. Das ist der Ansatz, der Rest
muss sich finden. Schwierig auch: Verbraucht man ZP oder TP oder AP im Moment des Ticks. ]]
function avalet.vitals.tickTimerModel(event, args)
  avalet.log("Function avalet.vitals.tickTimerModel(event, args)", 1)
  
  local vital = args[1]

  --[[
  Mana gibts nicht per Tick, ist also hier uninteressant ]]
  if vital == "MP" then return end

 	local currentValue = args[2]
  local maxValue = args[3]
  
  avalet.log("Tick-Timer: vital="..vital..", last="..tostring(avalet.vitals.tickTimer[vital]["lastValue"])..", current="..tostring(currentValue)..", max="..tostring(maxValue), 2)

  if maxValue == 0 then return end
  
  --[[
  Wenn das Model erst noch initialisiert werden muss, gibts noch nichts anzuzeigen.
  Hier wird currentValue zugewiesen (statt z.B. maxValue), damit der nächste Schritt
  hier funktioniert. Beim nächsten Durchlauf. ]]
  if avalet.vitals.tickTimer[vital]["lastValue"] == nil or avalet.vitals.tickTimer[vital]["lastValue"] == 0 then 
    avalet.vitals.tickTimer[vital]["lastValue"] = currentValue
    avalet.vitals.tickTimer[vital]["thisValue"] = currentValue
    return
  else 
    avalet.vitals.tickTimer[vital]["lastValue"] = avalet.vitals.tickTimer[vital]["thisValue"]
    avalet.vitals.tickTimer[vital]["thisValue"] = currentValue
  end
  --[[
  Wenn es zu einem TP-/AP-/ZP-VERLUST kam, interessiert das den TickTimer auch nicht.
  Ebensowenig wenn der Wert sich nicht verändert hat. ]]
  if currentValue &lt;= avalet.vitals.tickTimer[vital]["lastValue"] then
    return 
  end
  
  avalet.vitals.tickTimer[vital]["thisValue"] = currentValue
  avalet.vitals.tickTimer[vital]["maxValue"] = maxValue
  avalet.vitals.tickTimer[vital]["time"] = os.time()
  
  --[[
  Hier ist schon klar, dass es zu einem PLUS kam, ab hier ist es also relevant. Jetzt
  ist nur noch unklar, ob es ein regulärer Tick war, der zu dem Zuwachs geführt hat,
  oder ob es ein Heilzauber, -trank oder etwas ähnliches war. Aber prinzipiell spricht
  hier alles dafür, einen TickTimer zu starten. ]]

  avalet.log("call addTickTimer", 2)
  avalet.vitals.addTickTimer(os.time())

  avalet.log("TickTimerTimer wird aktiviert", 2)
  --avalet.vitals.tickTime = os.time()
  enableTimer("tickTimerTimer")
  avalet.vitals.refreshTickTimer()

end --function avalet.vitals.tickTimerModel(event, args)
registerAnonymousEventHandler("VitalsChange", "avalet.vitals.tickTimerModel")


--[[
Diese Funktion wird sekündlich aufgerufen, so lange der Timer für den TickTimer
läuft ]]
function avalet.vitals.refreshTickTimer()
  avalet.log("Function avalet.vitals.refreshTickTimer()", 1)
  
  local tickTimer = avalet.vitals.getHeaviestTickTimer()
  
  if tickTimer == nil then avalet.log("tickTimer ist NIL, disable Timer", 2); disableTimer("tickTimerTimer"); return end
  --display(tickTimer)
  local remaining = os.time() - tonumber(tickTimer["time"])

  remaining = remaining%41
  
  avaletUI.Tick:setValue(math.min(40, tonumber(remaining)),40, [[]])
  avaletUI.ABTick:setValue(math.min(40, tonumber(remaining)),40, [[]])
  
end --function avalet.vitals.refreshTickTimer()</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createInfoBoxModel</name>
				<packageName></packageName>
				<script>--[[

Infobox rechts oben

Die Infobox ist für Informationen, die der Spieler sich vielleicht etwas länger
ansehen will als das im (Kampf-)Scroll möglich ist. Dazu gehören zunächst Spiel-
stand, Inventar und die Gruppeninformationen, außerdem die Ausgabe von "ruebersicht"
der Runenschmiede. Weiter sind natürlich denkbar und könnten dann auch leicht 
hinzugefügt werden.
Die Default-Anzeige mit den Charakterinformationen war ursprünglich nur eine 
Übergangslösung, bis der Info-Bereich richtig Implementiert ist. Die Werte in 
dieser Default-Anzeige haben allerdings die Eigenschaft, dass sie per ATCP gesendet
werden und deshalb aktualisierbar sind. Im Gegensatz zum Spielstand beispielsweise,
der eben nur eine Momentaufnahme ist und dann altert.


In der Infobox werden Informationen angezeigt, die wichtig sind und nicht im 
Scroll untergehen sollen. Dazu gehören Spielstand, Inventar, Gruppeninformationen 
und die Ausgabe von "ruebersicht" der Runenschmiede. Die Idee ist, dass das Spiel 
ja weiterhin im Hauptfenster stattfindet. Und das diese ganzen Informationen ja auch
altern. Es bringt also nichts, beispielsweise den Spielstand längere Zeit im Info-Bereich
anzuzeigen. Jedenfalls nicht, wenn die dort gezeigten Informationen nicht auch 
(automatisch) aktualisiert werden können. Der Spieler muss also immer wieder diese
Informationen abrufen und sollte auch nicht den Eindruck gewinnen, dass Avalet ihm 
einen aktuellen Zustand anzeigen kann. (Also außer eben in dem Moment, wo die Information
durch den Spieler von Server abgerufen wird.) Deshalb werden die Informationen nur 
eine Zeit lang angezeigt. Und nach Ablauf dieser Zeit wieder durch den Default-Text 
ersetzt. Außer der Spieler ruft in dieser Zeit andere Informationen ab, die in der 
Infobox angezeigt werden. Dann werden diese an die alten Daten angehängt und der
Timer, der auf die Default-Anzeige zurückschaltet, wird zurückgesetzt. ]]

-- Namespace für die InfoBox
avalet.infoBox = avalet.infoBox or {}

--[[
Diese Funktion erzeugt das Datenmodell für den Bereich "Charakterinformationen".
Das ist der Bereich, der in der rechten Spalte oben als default angezeigt wird. 
Wenn dieses Model erzeugt wird, hat Avalet noch keine Informationen über den
gespielten Charakter. Hier kann also noch nichts angezeigt werden. Die Anzeige
wird aktualisiert, sobald anzuzeigende Daten vorhanden sind. Die Aktualisierung
erfolgt durch die Funktion "avalet.updateInfoBoxDefault()". ]]
function avalet.createInfoBoxModel()
  avalet.log("Function avalet.createInfoBoxModel()", 1)
  
  --avalet.infoBox = "\nWarte auf Daten..."
  avalet.infoBox.default = ""
  --avalet.infoBox.injectionBuffer = ""
  avalet.infoBox.injectionTimerID = nil
  --avalet.infoBox.showGuildInfo = false
  
  createBuffer("InjectionBuffer")
  avalet.infoBox.injectionBufferRows = 0
  
end --function avalet.createInfoBoxModel()



function avalet.infoBox.renewInfoBoxModel(event, args)
  avalet.log("Function avalet.infoBox.renewInfoBoxModel(event, args)", 1)

  if avalet.infoBox.injectionTimerID == nil then
    avalet.infoBox.updateInfoBoxDefault()
    raiseEvent("InfoBoxModelChange")
  end
end
registerAnonymousEventHandler("CharacterInfoChange", "avalet.infoBox.renewInfoBoxModel")
registerAnonymousEventHandler("StatisticsChange", "avalet.infoBox.renewInfoBoxModel")
registerAnonymousEventHandler("RenewInfoBox", "avalet.infoBox.renewInfoBoxModel")


function avalet.infoBox.flushInjectionBuffer(event, args)
  avalet.log("Function avalet.infoBox.flushInjectionBuffer(event, args)", 1)

  --avalet.infoBox.default = avalet.infoBox.injectionBuffer
  --avalet.infoBox.injectionBuffer = ""
  avalet.infoBox.setInjectionTimer(10)
  --raiseEvent("InfoBoxModelChange")
  
end
registerAnonymousEventHandler("InjectionBufferChange", "avalet.infoBox.flushInjectionBuffer")
--raiseEvent("InfoboxInjectionBufferChange", args)


function avalet.infoBox.setInjectionTimer(intSecondsOrNil)
  avalet.log("Function avalet.infoBox.setInjectionTimer(intSecondsOrNil)", 1)

  local sec = intSeconds
  
  if sec == nil then sec = 10 end

  --[[
  Timer setzen, der nach 'sec' Sekunden wieder default herstellt
  Timer muss zurückgesetzt werden, wenn vor Ablauf dieser Zeit
  der Buffer wieder in die InfoBox geschrieben wird ]]
  if avalet.infoBox.injectionTimerID ~= nil then
    killTimer(avalet.infoBox.injectionTimerID)
  end
  
  avalet.infoBox.injectionTimerID = tempTimer(sec, function() avalet.infoBox.injectionTimerID=nil; raiseEvent("RenewInfoBox"); avalet.log("Infobox-Default wieder herstellen.", 2); end, false)

end


--[[
Diese Funktion setzt den Text zusammen, der als default-Anzeige im Bereich der
"Charakterinformationen" ausgegeben wird. Aufgerufen wird die Funktion durch
einen Event, den das Charakter-Objekt auslöst, wenn sich hier relevante Daten
geändert haben. ]]
function avalet.infoBox.updateInfoBoxDefault()
  avalet.log("avalet.infoBox.updateInfoBoxDefault()", 1)

  local content = ""
	avalet.infoBox.default = "\n"

  local name = avalet.char.getName()
  local vollername = avalet.char.getVollerName()
  local nation = avalet.char.getNation()
  local gilde = avalet.char.getGilde()
  local zuenfte = avalet.char.getZuenfte()
  local alter = avalet.char.getAlter()
  local portfolio = avalet.char.getPortfolio()
  local level = avalet.char.getLevel()
  local gesinnung = avalet.char.getGesinnung()
  local sessionEP = avalet.char.getSessionEP()
  local bonusEP = avalet.char.getBonusEP()  
  
  -- inner function processZuenfte()
  local processZuenfte = function(str)
      
      local strZuenfte = str
			local tblZuenfte = {}
			for i in string.gmatch(strZuenfte, "%w+") do
				table.insert(tblZuenfte, i)
			end			
			strZuenfte = ""
			for k,v in pairs(tblZuenfte) do
				if k == #tblZuenfte and k &gt; 1 then
					strZuenfte = strZuenfte .. " und "
				end
				strZuenfte = strZuenfte .. v
				if k &lt; #tblZuenfte - 1 then
					strZuenfte = strZuenfte .. ", "
				end
			end
    
    return strZuenfte
  end
  
  -- inner function processAlter()
  local processAlter = function(str)
    --[[
    Also ich habe keinen regulären Ausdruck gefunden, der Stunden und Minuten sowohl
    in der Mitte der Zeichenkette als auch am Anfang zuverlässig erkennt. Bestenfalls
    wurde dabei nur eine Ziffer übernommen (also "8 Minuten" statt "28 Minuten").
    Deshalb die mehrstufige Lösung. Wer da besser ist als ich --&gt; mail me! Testfälle:
    "38 Tage 40 Stunden 21 Minuten 41 Sekunden 3306101",
    "3 Tage 6 Stunden 2 Minuten 4 Sekunden 3306101",
    "6 Stunden 21 Minuten 41 Sekunden 3306101",
    "38 Tage 21 Minuten 41 Sekunden 3306101",
    "21 Minuten 41 Sekunden 3306101",
    "38 Tage 6 Stunden 41 Sekunden 3306101", ]]
    local strAlter = str
    
    local tage = ""
    -- "string.gsub" gibt die Fundstelle zurück im Erfolgsfall, sonst den ganzen String
    tage = string.gsub(strAlter, "^(%d+%sTage?)%s.*", "%1", 1)
    if tage == strAlter then
      tage = "0 Tage"
    end
    
    local stunden = ""
    stunden = string.gsub(strAlter, ".*%s(%d+%sStunden?)%s.*", "%1", 1)
    if stunden == strAlter then
      stunden = string.gsub(strAlter, "^(%d+%sStunden?)%s.*", "%1", 1)
      if stunden == strAlter then
        stunden = "0 Stunden"
      end
    end
    
    local minuten = ""
    minuten = string.gsub(strAlter, ".*%s(%d+%sMinuten?)%s.*", "%1", 1)
    if minuten == strAlter then
      minuten = string.gsub(strAlter, "^(%d+%sMinuten?)%s.*", "%1", 1)
      if minuten == strAlter then
        minuten = "0 Minuten"
      end
    end
    
    --Sekunden werden nicht angezeigt. (Anzeige ist nicht aktuell genug für Sekunden.)
    --local sekunden = ""
    --sekunden = string.gsub(str, ".*%s(%d+%sSekunden?)%s.*", "%1", 1)
    --if sekunden == str then
    --  sekunden = "0 Sekunden"
    --end
    
    strAlter = tage .. " " .. stunden .. " und " .. minuten
    
    return strAlter
      
  end
  
  --[[
  Hier gehts los mit der Erstellung des Default-Textes ]]
  
  -- Wenn es noch keine Char-Daten gibt, dann ist hier schon Schluss
	if vollername == nil or string.len(vollername) == 0 then 
    avalet.log("Keine Character-Daten vorhanden", 2)

		content = "\nWarte auf Daten...\n"
    
  -- Andernfalls wird hier jetzt die Ausgabe zusammengesetzt
  else
    --avalet.log("Ausgabe wird vorbereitet", 1) 

    content = ""
		content = content .. "&lt;b&gt;&lt;white&gt;In Avalon bist Du bekannt als\n\n" .. vollername .. "&lt;/b&gt;\n\n"

    if nation ~= nil and string.len(nation) ~= 0 then
 				content = content .. "Du stammst aus dem Volk der "..nation..".\n"
    end

		if string.len(gilde) ~= 0 then
			if gilde == "keine" then
				content = content .. "Du bist noch in keiner Gilde.\n"
			else
				if gilde == "Druiden" then
					content = content .. "Du bist in der " .. gilde .. "gilde.\n"
				elseif gilde == "Magier" then
					content = content .. "Du bist in der " .. gilde .. "gilde.\n"
				else
					content = content .. "Du bist in der Gilde der " .. gilde .. ".\n"
				end
			end
		end
    
		if string.len(zuenfte) == 0 then
			content = content .. "Du uebst noch keine Berufe aus.\n"
		else
			content = content .. "Du gehoerst den Zuenften " .. processZuenfte(zuenfte) .. " an.\n"
		end

    if string.len(alter) ~= 0 then
      content = content .. "Du bist etwa " .. processAlter(alter) .. " alt.\n"
    end
    
		if string.len(portfolio) ~= 0 then
			if (portfolio ~= "keines") then
				if portfolio == name then
					content = content .. "Du bist Erstie in Deinem Portfolio.\n\n"
				else
					content = content .. "Du bist Zweitie im Portfolio von " .. string.title(portfolio) .. ".\n\n"
				end
			end
		end
    
		if string.len(level) ~= 0 then
			content = content .. "Du hast Level " .. level .. " erreicht.\n"
		end

		if string.len(gesinnung) ~= 0 then
			content = content .. "\nDeine Gesinnung ist " .. gesinnung .. ".\n\n\n"
		end
    
    -- Und unten drunter die Statistiken
    if avalet.statistics.counter ~= nil then

      -- from the lua docs    
      local function pairsByKeys (t, f)
        local a = {}
        for n in pairs(t) do table.insert(a, n) end
        table.sort(a, f)
        local i = 0                -- iterator variable
        local iter = function ()   -- iterator function
          i = i + 1
          if a[i] == nil then return nil
          else return a[i], t[a[i]]
          end
        end
        return iter
      end
      
      --[[
      Mir ist nicht ganz klar, warum ich hier zwei Listen hab... Ich denke, ich 
      dachte mal, dass ich anders die String-Längen nicht gezählt bekomme. Aber
      eigentlich würde ich jetzt glauben, dass das auch anders geht. Zeit zum
      Überarbeiten hab ich aber auch grad nicht. TODO ]]
      
      local statistics = {}
      local maxLengthName = 0
      local maxLengthValue = 0
      
      for i, j in pairs(avalet.statistics.counter) do
        local k = j["func"]
        local l = j["last"]
        local name = j["name"]
        local state = j["isActive"]
        local value = k()
        local last = l()
        local isActive = state()
        local lengthName = string.len(name)
        local lengthValue = string.len(value)
        table.insert(statistics, i, {["name"]=name, ["isActive"]=isActive, ["value"]=value, ["last"]=last})
        if maxLengthName &lt; lengthName then maxLengthName = lengthName end 
        if maxLengthValue &lt; lengthValue then maxLengthValue = lengthValue end
      end

      -- Wegen dem Doppelpunkt wird der maximal lange Name noch eins länger
      -- (und alle anderen auch natürlich):
      maxLengthName = maxLengthName + 1
      
      for u,v in pairsByKeys(statistics) do
      
        local name = v["name"]..":"
        local value = tostring(v["value"])
        local last = tostring(v["last"])
        local color = ""
        if v["isActive"] then color = "&lt;green&gt;" else color = "&lt;white&gt;" end

        while name:len() &lt; maxLengthName do name = name.." " end
        while value:len() &lt; maxLengthValue do value = " "..value end
        
        if last == "nil" or last == "0" or last == "" then
          last = ""
        else
          last = " &lt;white&gt;("..last..")"
        end

        content = content .. "&lt;b&gt;&lt;white&gt;" .. name .. "&lt;/b&gt; " .. color .. value..last.."\n"
      end

--[=[
      -- Wenn man sich die Längenanpassung sparen würde, weil man beispielsweise
      -- eine HTML-Tabelle für die Anzeige verwendet, dann würde das hier alles
      -- seit der local function ersetzten können: TODO
      for u,v in pairsByKeys(avalet.statistics.counter) do
        local func = v["func"]
        content = content .. "&lt;b&gt;" .. v["name"] .. ":&lt;/b&gt; " .. tostring(func()).."\n"
      end
]=]
    end

    --content = content .. "&lt;b&gt;Lag-Koeffizient:&lt;/b&gt; n/a\n"
    
    content = content .. "\n&lt;white&gt;(Diese Anzeige aufrufen mit 'cinfo')"
    
	end
  
  avalet.infoBox.default = content
  raiseEvent("RefreshInfoBoxGUI")
  
end --function avalet.updateInfoBoxDefault()
registerAnonymousEventHandler("RefreshCharacterInfo", "avalet.infoBox.updateInfoBoxDefault")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createGuildInfoModel</name>
				<packageName></packageName>
				<script>--[[
Hier wird das Model für die Ausgabe der Gilden-Information erzeugt. Dort
werden derzeit nur die Daten angezeigt, die sich Runenschmiede schicken
lassen können, wenn sie "ruebersicht" eingeben. ]]

-- Namespace für diesen Bereich
avalet.guildInfo = avalet.guildInfo or {}


function avalet.createGuildInfoModel()
  avalet.log("avalet.createGuildInfoModel()", 1)

end


function avalet.guildInfo.processGuildInfo()
  avalet.log("avalet.guildInfo.processGuildInfo()", 1)

  if (avalet.char.getGilde() == "Runenschmiede") then

    avalet.guildInfo.processRuniGuildInfo()
  
  else
    cecho("&lt;magenta&gt;SPOOKY: avaletGildenInfo per ATCP erhalten.\n")
  end

end
registerAnonymousEventHandler("GuildInfoChange", "avalet.guildInfo.processGuildInfo")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>RuniGuildInfoModel</name>
				<packageName></packageName>
				<script>function avalet.guildInfo.processRuniGuildInfo()
  avalet.log("avalet.guildInfo.processRuniGuildInfo()", 1)

  local runiGildenInfo = {}
  local guildInfoScreenName = nil
  
  local jsonFormattedGuildInfo = avalet.char.getGildenInfo()

  runiGildenInfo = yajl.to_value(jsonFormattedGuildInfo)
  avalet.guildInfo.createRuniGuildInfoModel(runiGildenInfo)
  
  -- Hier den Timer setzten wenn es verschiedene Guild-Infos gibt, die
  -- verschieden lang angezeigt werden sollen.
  --avalet.infoBox.setInjectionTimer(15)
  
  raiseEvent("RuniGuildInfoChange")

end --avalet.guildInfo.processRuniGuildInfo()


--createRuniInfoBoxModel
function avalet.guildInfo.createRuniGuildInfoModel(runiGildenInfo)
  avalet.log("avalet.guildInfo.createRuniGuildInfoModel(runiGildenInfo)", 1)

  local runiGuildInfo = runiGildenInfo

  avalet.guildInfo.runiGuildInfoModel = avalet.guildInfo.runiGuildInfoModel or {}

  local RUNE_NOCH_SEHR_GUT = "noch sehr gut"
  local RUNE_NOCH_GUT = "noch gut"
  local RUNE_NOCH_GANZ_GUT = "noch ganz gut"
  local RUNE_NOCH_AUSREICHEND = "noch ausreichend"
  local RUNE_KAUM_NOCH = "kaum noch"
  
  local RUNE_COLOR = {
    [RUNE_NOCH_SEHR_GUT]    = "#00ff00",
    [RUNE_NOCH_GUT]         = "#00ff00",
    [RUNE_NOCH_GANZ_GUT]    = "#00b300",
    [RUNE_NOCH_AUSREICHEND] = "#ff3300",
    [RUNE_KAUM_NOCH]        = "#800000"
  }
  
  local BESCHAEDIGT_NICHT = "nicht"
  local BESCHAEDIGT_SEHR_LEICHT = "sehr leicht"
  local BESCHAEDIGT_LEICHT = "leicht"
  local BESCHAEDIGT_RECHT = "recht"
  local BESCHAEDIGT_SCHWER = "schwer"
  local BESCHAEDIGT_SEHR_SCHWER = "sehr schwer"
  --local BESCHAEDIGT_ZERBROCHEN = ""
  
  local ITEM_COLOR = {
    [BESCHAEDIGT_NICHT]       = "#00ff00",
    [BESCHAEDIGT_SEHR_LEICHT] = "#00ff00",
    [BESCHAEDIGT_LEICHT]      = "#00b300",
    [BESCHAEDIGT_RECHT]       = "#00b300",
    [BESCHAEDIGT_SCHWER]      = "#ff3300",
    [BESCHAEDIGT_SEHR_SCHWER] = "#800000"
  }
  
  local ITEM_TYPE_WEAPON = "Waffe"
  local ITEM_TYPE_SHIELD = "Schild"
  local ITEM_TYPE_HEAD = "Kopf"
  local ITEM_TYPE_BODY = "Koerper"
  local ITEM_TYPE_LEGS = "Bein"
  local ITEM_TYPE_ARMS = "Arm"
  
  local CHARGE_POSITIVE = "positiv"
  local CHARGE_NEGATIVE = "negativ"
  local CHARGE_NONE = "neutral"
  
  local CHARGE_SYMBOL = {
    [CHARGE_POSITIVE] = "&amp;#43;",    --"&amp;#91;&amp;#x2002;&amp;#43;&amp;nbsp;&amp;#93;&amp;nbsp;",   --[ + ]
    [CHARGE_NEGATIVE] = "&amp;minus;",   --"&amp;#91;&amp;nbsp;&amp;minus;&amp;nbsp;&amp;#93;&amp;nbsp;",  --[ - ] --&amp;#45;
    [CHARGE_NONE]     = "&amp;nbsp;"                                                     --"&amp;#91;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;#93;&amp;nbsp;"   --[   ]
  }    

  local objItem = {
    iName = "",
    iID = "",
    iType = "",
    iState = "",
    iColor = "",
    iRunes = {},
    iShow = false,
  }
  
  local objRune = {
    rName  = "",
    rCharge = "",
    rChargeSymbol = "",
    rState = "",
    rColor = ""
  }
  
  avalet.guildInfo.runiGuildInfoModel["iWeapon"] = objItem
  avalet.guildInfo.runiGuildInfoModel["iShield"] = objItem
  avalet.guildInfo.runiGuildInfoModel["iHead"]   = objItem
  avalet.guildInfo.runiGuildInfoModel["iBody"]   = objItem
  avalet.guildInfo.runiGuildInfoModel["iLegs"]   = objItem
  avalet.guildInfo.runiGuildInfoModel["iArms"]   = objItem

  avalet.guildInfo.runiGuildInfoModel.HammerCharge = avalet.guildInfo.runiGuildInfoModel.HammerCharge or CHARGE_POSITIVE

  avalet.guildInfo.runiGuildInfoModel.HammerCharge = runiGuildInfo["ladung"]
  
  avalet.guildInfo.runiGuildInfoModel.maxNumbDispRunes = 0

  local weaponCounter = 0
  local item = nil
  local runen = nil
  local runes_pos = nil
  local runes_neg = nil
  local runes_neu = nil

  for _, v in pairs(runiGuildInfo["items"]) do

    for _, w in pairs (v["typ"]) do

      item = {}
  
      item.iName = v["item"]
      item.iID = v["id"]
      item.iType = w--v["typ"]
      item.iState = v["zustand"]
      item.iColor = ITEM_COLOR[v["zustand"]]
      if v["zustand"]==BESCHAEDIGT_SCHWER or v["zustand"]==BESCHAEDIGT_SEHR_SCHWER then item.iShow=true else item.iShow=false end
      
      runen = {}
      runes_pos = {}
      runes_neg = {}
      runes_neu = {}

      for _, x in pairs (v["runen"]) do

        local rune = {}
        rune.rName = x["name"]
        rune.rCharge = x["ladung"]
        rune.rChargeSymbol = CHARGE_SYMBOL[x["ladung"]]
        rune.rState = x["zustand"]
        rune.rColor = RUNE_COLOR[x["zustand"]]
        if x["zustand"]==RUNE_NOCH_AUSREICHEND or x["zustand"]==RUNE_KAUM_NOCH then item.iShow=true end

        if rune.rCharge == CHARGE_POSITIVE then
          table.insert(runes_pos, rune)
        elseif rune.rCharge == CHARGE_NEGATIVE then
          table.insert(runes_neg, rune)
        else
          table.insert(runes_neu, rune)
        end 

        rune = nil
        
      end

      -- Die einzelnen Runen-Listen werden jetzt noch alphabetisch sortiert
      local sortMyRunes = function(a, b) return a["rName"] &lt; b["rName"] end
      table.sort(runes_pos, sortMyRunes)
      table.sort(runes_neg, sortMyRunes)
      table.sort(runes_neu, sortMyRunes)
      
      for _, y in pairs (runes_pos) do
        table.insert(runen, y)
      end
      runes_pos = {}
      
      for _, y in pairs (runes_neu) do
        table.insert(runen, y)
      end
      runes_neu = {}
        
      for _, y in pairs (runes_neg) do
        table.insert(runen, y)
      end
      runes_neg = {}
      
      item.iRunes = runen
      runen = {}

      --[[
      Nur für die tatsächlich anzuzeigenden Items wird hier die Anzahl der Runen
      gezählt. Damit wird später bestimmt, wie hoch das Anzeigeelement sein muss,
      damit alle anzuzeigenden Runen sichtbar sind. ]]
      if item.iShow then 
        avalet.guildInfo.runiGuildInfoModel.maxNumbDispRunes = math.max(avalet.guildInfo.runiGuildInfoModel.maxNumbDispRunes, #item.iRunes)
      end

      if w == ITEM_TYPE_WEAPON then

        if weaponCounter == 0 then
        
          avalet.guildInfo.runiGuildInfoModel["iWeapon"] = item
          weaponCounter = 1
        elseif weaponCounter == 1 then
          avalet.guildInfo.runiGuildInfoModel["iShield"] = item
          weaponCounter = 2
        else
          cecho("&lt;magenta&gt;\nFEHLER in der Funktion avaletUI.createRuniInfoBoxModel() - Waffenzähler ist: "..weaponCounter.."/n")
        end
        
      elseif w == ITEM_TYPE_SHIELD then
        avalet.guildInfo.runiGuildInfoModel["iShield"] = item
      elseif w == ITEM_TYPE_HEAD then
        avalet.guildInfo.runiGuildInfoModel["iHead"] = item
      elseif w == ITEM_TYPE_BODY then
        avalet.guildInfo.runiGuildInfoModel["iBody"] = item
      elseif w == ITEM_TYPE_LEGS then
        avalet.guildInfo.runiGuildInfoModel["iLegs"] = item
      elseif w == ITEM_TYPE_ARMS then
        avalet.guildInfo.runiGuildInfoModel["iArms"] = item
      else
        cecho("&lt;magenta&gt;\nFEHLER in der Funktion avaletUI.createRuniInfoBoxModel() - Gegenstandstyp ist: "..w.."/n")
      end
      item = nil
      item = objItem
    end
  end
 
end



--[[
Hier werden Testdaten erzeugt. Da ich keinen Runenschmied zum testen hatte, habe ich
mir so geholfen. Beim Aufruf (mit einem Alias z.B.) erzeugt diese Funktion Daten,
die denen entsprechen, die auch per ATCP geschickt werden. Und mit diesen Daten wird
dann auch der Event ausgelöst, den ATCP-Daten ebenfalls auslösen würden.
Erzeugt wird hier mit einer gewissen Zufälligkeit, jeder Aufruf wird also ein anderes
Ergebnis  ergeben. Diese Funktion funktioniert mittlerweile allerdings nur noch
bei Runenschmieden. (Ist aber immer noch hilfreich zum debuggen.) ]]
function avalet.ruebersichtTEST()
  avalet.log("avalet.ruebersichtTEST()", 1)

  local ITEM = { "Langschwert", "Grossschild", "Helm", "Panzer", "Handschuhe", "Stiefel" }
  local RUNE_STATE = { "noch sehr gut", "noch gut", "noch ganz gut", "noch ausreichend", "kaum noch" }
  local ITEM_STATE = { "nicht", "sehr leicht", "leicht", "recht", "schwer", "sehr schwer" }
  local RUNE_CHARGE = { "positiv", "negativ", "neutral" } --Reihenfolge nicht verändern!

  local function getRunes(intAnzahlRunen)
  
    local str = ""
    str = str .. '"Rune1":{"zustand":"'.. RUNE_STATE[math.random(1,5)] ..'","ladung":"'.. RUNE_CHARGE[math.random(1,3)] ..'","name":"Rune1"}'
    for i=2, intAnzahlRunen, 1 do
      str = str .. ', "Rune'..tostring(i)..'":{"zustand":"'.. RUNE_STATE[math.random(1,5)] ..'","ladung":"'.. RUNE_CHARGE[math.random(1,3)] ..'","name":"Rune'..tostring(i)..'"}'
    end

    return str
  end

  jsonFormattedGuildInfo = ''
  jsonFormattedGuildInfo = jsonFormattedGuildInfo .. '{"items": ['
  jsonFormattedGuildInfo = jsonFormattedGuildInfo .. '{"typ":["Waffe"],"zustand":"'.. ITEM_STATE[math.random(1,6)] ..'","runen":{'..getRunes(math.random(1,6))..'},"item":"Langschwert"}, '
  jsonFormattedGuildInfo = jsonFormattedGuildInfo .. '{"typ":["Waffe"],"zustand":"'.. ITEM_STATE[math.random(1,6)] ..'","runen":{'..getRunes(math.random(1,6))..'},"item":"Grossschild"}, '
  jsonFormattedGuildInfo = jsonFormattedGuildInfo .. '{"typ":["Koerper"],"zustand":"'.. ITEM_STATE[math.random(1,6)] ..'","runen":{'..getRunes(math.random(1,6))..'},"item":"Silberpanzer"}, '
  jsonFormattedGuildInfo = jsonFormattedGuildInfo .. '{"typ":["Kopf"],"zustand":"'.. ITEM_STATE[math.random(1,6)] ..'","runen":{'..getRunes(math.random(1,6))..'},"item":"Helm"}, '
  jsonFormattedGuildInfo = jsonFormattedGuildInfo .. '{"typ":["Bein"],"zustand":"'.. ITEM_STATE[math.random(1,6)] ..'","runen":{'..getRunes(math.random(1,6))..'},"item":"Paar Stiefel"}, '
  jsonFormattedGuildInfo = jsonFormattedGuildInfo .. '{"typ":["Arm"],"zustand":"'.. ITEM_STATE[math.random(1,6)] ..'","runen":{'..getRunes(math.random(1,6))..'},"item":"Paar Handschuhe"}],'
  jsonFormattedGuildInfo = jsonFormattedGuildInfo .. '"ladung": "'..RUNE_CHARGE[math.random(1,2)]..'"}'

  raiseEvent("AvalonGildenInfo", jsonFormattedGuildInfo)

end --function avalet.ruebersichtTEST()

</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createChatModel</name>
				<packageName></packageName>
				<script>--[[
Hier findet die Verarbeitung der ein- und ausgehenden Kommunikation über die Kanäle
(laber, sagen, reden, etc.) statt. Ebenso die Emotes. Diese Daten erreichen Avalet
per ATCP, und dort findet auch schon eine erste Bearbeitung statt! Also ggf. dort
anfangen zu gucken, wo was gemacht wird. (Ich schreibe das insbesondere für den Fall,
dass mal ein neues Volk oder eine neue Gilde oder eine neue Zunft eingebaut wird.
Dann wird nämlich dort eine Änderung nötig sein.)
Die Daten werden hier für die Anzeige vorbereitet. Die Anzeige selbst geschieht dann
unter Avalet --&gt; View --&gt; buildChatUI. ]]

-- Sub-Namespace für die Chats
avalet.chats = avalet.chats or {}

function avalet.createChatModel()
  avalet.log("Function avalet.createChatModel()", 1)

  -- Speicherplatz für den Inhalt der einzelnen Tabs
  avalet.chats.chats = avalet.chats.chats or {}

  -- Legt für jeden Kanal einen Speicherplatz für die anzuzeigenden Inhalte an.
  for k,v in pairs(avalet.CONSTS.CHANNELS) do
    avalet.chats.chats[v] = {}
    --avalet.chats.chats[k] = {}
  end
  
  -- Speicherplatz für den Sammeltab hinzufügen
  avalet.chats.chats[avalet.CONSTS.SUMMING_TAB_NAME] = {}

end --function avalet.createchatModel()


--[[
In der per ATCP empfangenen Kommunikation gibt es Formatierungsanweisungen,
die hier rausgefiltert werden. ]]
local clearMessage = function(str)
  local message = str
  message = string.gsub(message, "%%%^ITALIC%%%^", "")
  message = string.gsub(message, "%%%^NO_ITALIC%%%^", "")
  message = string.gsub(message, "%%%^NC_html_begin_colour%(%#[A-Za-z0-9]+%)%%%^", "")
  message = string.gsub(message, "%%%^NC_html_end_colour%%%^", "")
  return message
end


--[[
Hier wird die Kommunikation verarbeitet, die über die Comm-Kanäle per ATCP eingehen.
Eine erste Verarbeitung fand schon beim Eingang der Nachricht statt, also bei
ATCP --&gt; atcp (Trennung von channel und message nämlich, aber auch die Zuordnung von
einzelnen Kanälen zu Sammelbegriffen, bspswse "vr" zu "Volk". 
Was hier ankommt wird einmal in der für den Kanal vorgesehenen Tabelle gespeichert.
Und zusätzlich in ein Logfile geschrieben. ]]
function avalet.chats.processNewMessage(channel, message)
  avalet.log("Function avalet.chats.processNewMessage(channel, message)", 1)

  -- Die Nachricht kann Steuercode enthalten, der wird hier entfernt
  message = clearMessage(message)
  
  local logfilename = ""
  if avalet.char.name ~= nil and avalet.char.name ~= "" then
    logfilename = string.title(avalet.char.name) .. channel
  else
    logfilename = channel
  end
  
  Logger:Log(logfilename, message, {"timestamp", split = 4000})

  local timestamp = getTime(true, "'['dd'.'MM'.'yyyy' - 'hh':'mm':'ss'.'zzz]: ")

  local line = ""

  -- Hier können auch Comm-Nachrichten landen, für die es keinen Tab gibt. Also:
  -- (Mittlerweile sollte das nicht mehr vorkommen, aber man weiß ja nie)
  if avalet.chats.chats[channel] ~= nil then
    --[[
    Die Tabelle der einzelnen Chat-Tabs wird auf 500 Elemente begrenzt.
    Um Speicher zu sparen. Die Zahl kann sich noch ändern, aber 500 schien
    mir erstmal ausreichend zu sein. Wenn die Tabelle länger ist, wird
    hier jeweils das erste Element entfernt. ]]
    while #avalet.chats.chats[channel] &gt;= 500 do
      table.remove(avalet.chats.chats[channel], 1)
    end

    -- Timestamp vor die Zeile und ab damit in die Tabelle:
    line = timestamp .. message --.. "\n"
    table.insert(avalet.chats.chats[channel], line)

    --[[
    Wenn der channel, über den eine Nachricht eingegangen ist, in der Liste
    für den Sammeltab steht, muss dessen Tabelle auch ergänzt werden. ]]
    local collectionList = avalet.profile:getCollectionList()
    for _,v in pairs(collectionList) do
      if v == channel then
        table.insert(avalet.chats.chats[avalet.CONSTS.SUMMING_TAB_NAME], line)
        break
      end
    end

    -- Aufbereitet wird die Anzeige bei der Ausgabe. Dafür sorgt:
    raiseEvent("RefreshChatUI", channel)
  end  
end

</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>View</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>STYLE_SHEETS</name>
				<packageName></packageName>
				<script>CSSMan = CSSMan or {}
avaletUI.CSS = {}

avaletUI.CSS.base = CSSMan.new([[
	background-color: rgba(0,0,0,100);
	border-style: solid;
	border-width: 1px;
	border-radius: 10px;
	border-color: white;
	margin-left: 10px;
	margin-right: 10px;
  
]])
  
avaletUI.CSS.frameworkTabs = CSSMan.new([[
  display:none;
  visibility: hidden;
  margin: 0pt;
  
]])
  
 -- CSS Boxes
avaletUI.CSS.boxCSS = CSSMan.new([[
	background-color: rgba(0,0,0,100);
	border-style: solid;
	border-width: 1px;
	border-radius: 10px;
	border-color: white;
  margin-top: 5px;
  margin-bottom: 5px;
  margin-left: 5px;
  margin-right: 5px;
]])

 -- CSS Overlay Boxes
avaletUI.CSS.overlayCSS = CSSMan.new([[
	background-color: rgba(50,50,50,200);
	border-style: solid;
	border-width: 1px;
	border-radius: 10px;
	border-color: white;
	margin: 10px;
]])

-- CSS Tab-Element ---------------------------------------------

avaletUI.CSS.chatsBodyCSS = CSSMan.new([[
	background-color: rgb(0,0,0);
]])

avaletUI.CSS.chatsBodyTabsCSS = CSSMan.new([[
	background-color: rgb(0,0,0);
]])

avaletUI.CSS.MenuTabCSS = CSSMan.new([[
	background-color: rgb(0,0,0);
  border: 1px solid white;
  border-radius: 10px;
	margin-right: 1px;
	margin-left: 1px;
]])

avaletUI.CSS.MenuTabCurrentCSS = CSSMan.new([[
	background-color: rgba(96,96,96,255);
  color: black;
  font: bold;
  border: 2px solid white;
  border-radius: 10px;
	margin-right: 1px;
	margin-left: 1px;
]])
--rgb(50,0,50);
avaletUI.CSS.MenuTabMarkedCSS = CSSMan.new([[
	background-color: rgba(96,96,96,120);
  border: 1px solid white;
  border-radius: 10px;
	margin-right: 1px;
	margin-left: 1px;
]])

-- CSS Top Menu ------------------------------------------------

avaletUI.CSS.MenuLabelCSS = CSSMan.new([[
	background-color: rgba(0,0,0,100);
	font-weight: bold;
	font-size: 16pt;
	color: white;
]])

-- CSS Counter -------------------------------------------------

avaletUI.CSS.counterCSS = CSSMan.new([[
	background-color: black;
	border-style: solid;
	border-width: 1px;
	border-radius: 10px;
	border-color: black;
	margin: 5px;
]])

-- CSS Hunger-/Durst-/Alk-Anzeige ------------------------------

avaletUI.CSS.HDACSS = CSSMan.new([[
	background-color: rgb(0,0,0);
	border-style: solid;
	border-width: 1px;
	border-radius: 2px;
	border-color: white;
	margin-right: 1px;
	margin-left: 1px;
]])

avaletUI.CSS.HDABottomBarCSS = CSSMan.new([[
	background-color: rgb(0,0,0);
	border-style: solid;
	border-width: 1px;
	border-radius: 0px;
	border-color: white;
	margin-right: 0px;
	margin-left: 0px;
]])

avaletUI.CSS.HDAGreenCSSbla = CSSMan.new([[
	background-color: rgb(0,255,0);
	border-style: solid;
	border-width: 1px;
	border-radius: 10px;
	border-color: white;
	border-top-left-radius: 10px;
	border-top-right-radius: 10px;
	margin-right: 1px;
	margin-left: 1px;
]])

avaletUI.CSS.HDAYellowCSSbla = CSSMan.new([[
	background-color: rgb(255,255,0);
	border-style: solid;
	border-width: 1px;
	border-radius: 10px;
	border-color: white;
	border-top-left-radius: 10px;
	border-top-right-radius: 10px;
	margin-right: 1px;
	margin-left: 1px;
]])

avaletUI.CSS.HDARedCSSbla = CSSMan.new([[
	background-color: rgb(255,0,0);
	border-style: solid;
	border-width: 1px;
	border-radius: 10px;
	border-color: white;
	border-top-left-radius: 10px;
	border-top-right-radius: 10px;
	margin-right: 1px;
	margin-left: 1px;
]])

avaletUI.CSS.HDABlankCSSbla = CSSMan.new([[
	background-color: rgb(0,0,0);
	border-style: solid;
	border-width: 1px;
	border-radius: 2px;
	border-color: white;
	margin-right: 1px;
	margin-left: 1px;
]])

avaletUI.CSS.IconsCSS = CSSMan.new([[
	background-color: rgb(0,0,0);
	border-style: solid;
	border-width: 1px;
	border-radius: 2px;
	border-color: white;
	margin-right: 1px;
	margin-left: 1px;
  background-position: center center;
  background-repeat: no-repeat;
  background-origin: margin;

]])

-- CSS Gauges --------------------------------------------------

avaletUI.CSS.GaugeBackCSS = CSSMan.new([[
	background-color: rgba(0,0,0,0);
	border-style: solid;
	border-color: white;
	border-width: 1px;
	border-radius: 5px;
	padding: 5px;
	width: 30%;
	height: 80%;
]])

avaletUI.CSS.GaugeFrontCSS = CSSMan.new([[
	background-color: rgba(0,0,0,0);
	border-style: solid;
	border-color: white;
	border-width: 1px;
	border-radius: 5px;
	padding: 5px;
	width: 30%;
	height: 80%;
]])

avaletUI.CSS.BottomBarGaugeBackCSS = CSSMan.new([[
	background-color: rgba(0,0,0,0);
	border-style: solid;
	border-color: white;
	border-width: 1px;
	border-radius: 0px;
	padding: 0px;
	width: 30%;
	height: 80%;
]])

avaletUI.CSS.BottomBarGaugeFrontCSS = CSSMan.new([[
	background-color: rgba(0,0,0,0);
	border-style: solid;
	border-color: white;
	border-width: 1px;
	border-radius: 0px;
	padding: 0px;
	width: 30%;
	height: 80%;
]])

avaletUI.CSS.GaugeTextCSS = CSSMan.new([[
	padding: 0px;
	font-weight: bold;
  font-size: 8pt;
]])

avaletUI.CSS.GaugeTimerTextCSS = CSSMan.new([[
  padding-left: 5px;
]])
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildUI</name>
				<packageName></packageName>
				<script>-- 
function avaletUI.buildUI()
  avalet.log("Function avaletUI.buildUI()", 1)

  -- Unmengen an Werten, mit denen dann das GUI aufgebaut wird, werden berechnet.
  avaletUI.calculateUI()
  
  -- Die Container und einige Label, aus denen die Oberfläche besteht, werden
  -- erzeugt und angeordnet. Damit ist das GUI aufgebaut.
  avaletUI.initUI()

  --[[
  Manche Inhalte von Avalon sprengen die Fensterbreite bzw. sind halt abhängig von der
  Breite der Hauptconsole, wie sie in den Mudlet-Einstellungen gesetzt sind. Für Avalet
  bietet es sich an, diese Einstellung auf die tatsächliche Breite des Hauptfensters
  zu stellen. So ganz sicher bin ich mir nicht, ob das den User nicht irritiert. Aber
  eigentlich halte ich das für sinnvoll. Passiert hier also, testweise. ]]
  local mainWindowColumns = getColumnCount()
  setWindowWrap("main", mainWindowColumns)
  avalet.log("Zeilenumbruch für das Hauptfenster auf "..mainWindowColumns.." Zeichen gesetzt", 2)

  --[[
  Jetzt fehlen noch die Inhalte. Diese Funktionen können auch direkt aufgerufen
  werden, wenn mal Werte neu geschrieben werden müssen, ohne dass die ganze
  Oberfläche neu aufgebaut werden muss. ]]

  avaletUI.buildIGMapUI()
  avaletUI.buildTimerUI()
  avaletUI.buildIconsUI()
  avaletUI.buildHDAUI()
  avaletUI.buildVitalsUI()
  avaletUI.buildInfoBoxUI()
  avaletUI.buildGuildInfoUI()
  avaletUI.buildChatUI()
  
  
  --avaletUI.buildMenuBarUI()

end --function avaletGUI.buildUI()
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>calculateUI</name>
				<packageName></packageName>
				<script>--[[
Funktion: avaletUI.calculateUI
Beim Berechnen der Oberfläche geht es um die Frage, wie viel Platz zur Verfügung
steht und welches Layout in Frage kommt. Avalet bringt drei unterschiedliche
Layouts mit: dreispaltig (default), zweispaltig und einspaltig.
Das dreispaltige Layout erfordert eine eher breites Display, also 16:10 und so.
(Oder natürlich einen großen Monitor.) Die mittlere Spalte ist die Hauptkonsole,
die muss natürlich genügend Zeichen in der
Breite anzeigen. In der rechten Spalte werden ebenfalls Consolen-Ausgaben angezeigt,
so dass diese auch entsprechend viele Zeichen breit sein muss. Allerdings kann hier
die Schriftart kleiner sein als in der Hauptconsole. Und die linke Spalte sollte
natürlich ästhetisch auch ansprechend sein, und nicht total langezogen. Aber da gibt
es noch einen gewissen Spielraum.
Das zweispaltige Layout ist für Displays gedacht, die nicht breit genug sind. Hier
fällt die linke Spalte weg, alle dort zu findenden Anzeigen werden in den anderen 
beiden Spalten untergebracht. Das Display muss also immer noch breit genug sein,
um zwei Konsolen nebeneinander anzuzeigen, aber auch hier eine davon in einer kleineren
Schriftart. Gleichzeitig muss es hoch genug sein, damit von der Hauptconsole noch
genug übrig bleibt. Trotz dort zusätzlich angezeigter Elemente. Dieses Layout ist auch
für Spieler gedacht, die das Anwendungsfenster nicht im Vollbild laufen lassen.
Das einspaltige Layout verzichtet auf die linke und die rechte Spalte, und zeigt die
wichtigsten Elemente oberhalb und unterhalb der Hauptkonsole an. Andere Elemente der
Oberfläche werden in diesem Layout nicht angezeigt, es fällt also etwas weg! Dieses
Layout ist für User gedacht, die ihr Anwendungsfenster noch kleiner ziehen wollen als
es für das zweispaltige Layout notwendig ist. Aber vor allem ist es für die 
Multiview-Funktion von Mudlet gedacht, bei der zwei Profile nebeneinander angezeigt
werden.
Das Problem hier ist, dass sich einfach nicht vorhersagen lässt, wie viel Platz auf dem
Monitor des User ist. Die Auflösung lässt sich abfragen, aber die Auflösung ist nicht
entscheidend. Sondern die Bildschirmdiagonale. Und die lässt sich nicht abfragen. Wenn
jemand 1920 Pixel in der Breite zur Verfügung hat, dann weiss man immer noch nicht, ob
dessen Monitor 5cm breit ist oder 50cm. Und das wäre aber der entscheidende Punkt.
Was sich allerdings mit der Displaygröße (also der Bildschirmdiagonale) ändern dürfte ist
die Schriftart. Die wird sich der User so einstellen, dass die Schrift gut lesbar ist -
nicht zu groß und nicht zu klein. Wenn man also die Schriftgröße kennt und ermitteln kann,
wie viele Pixel ein Buchstabe einnimmt. Und wenn man außerdem noch die Displayauflösung
kennt. Dann kann man versuchen, eine sinnvolle Aufteilung des Monitors zu berechnen. Und
wie es der Zufall so will, stellt Mudlet all diese Infos zur Verfügung.
]]
--[[
übliche Seitenverhältnisse:
3:2   = 1,5
4:3   = 1,3333
5:4   = 1,25 (1280X1024, eher veraltet)
16:9  = 1,77777 (z.b. 2560x1440)
16:10 = 1,6
21:9  = 2,3333
]]
function avaletUI.calculateUI()
  avalet.log("Function avaletUI.calculateUI()", 1)

  avaletUI.dimensions = avaletUI.dimensions or {}
  
  --[[
  Die Größe des MainWindow ist das, worin das Profil des Chars
  in Mudlet angezeigt wird. Also: Fensterhöhe minus der Menüleiste oben.
  Und Fensterbreite ganz. ODER aber auch nicht ganz, wenn nämlich
  Multiview aktiviert ist. Dann werden zwei Profile nebeneinander an-
  gezeigt und das MainWindow ist dann halt nur halb breit.]]
  local widthMainWindow = 0
  local heightMainWindow = 0
  
  widthMainWindow, heightMainWindow = getMainWindowSize()
  
  --[[
  Die MainConsole ist der Ausgabebereich. Also da, wo der Scroll
  stattfindet. ]]
  local widthMainConsole = 0
  local heightMainConsole = 0
  
  widthMainConsole = getMainConsoleWidth()
  -- Das Folgende kann eigentlich nicht funktionieren, weil BorderTop und BorderBottom
  -- noch gar keine Größe haben. Zumindest keine endgültige. Keine Ahnung, warum das 
  -- hier so steht. Mal im Auge behalten.
  heightMainConsole = heightMainWindow - getBorderTop() - getBorderBottom()
  
  --[[
  Die Schriftgröße in der Hauptkonsole ist so, wie sie der User in den
  Einstellungen von Mudlet einstellt.
  Die beiden kleineren Schriftarten werden von Avalet verwendet und
  sind abhängig von der eingestellten Schriftgröße der Hauptkonsole.]]
  local defaultFontSize = getFontSize()
  local smallFontSize = defaultFontSize - 2
  
  local defaultFontWidth = 0
  local defaultFontHeight = 0
  local smallFontWidth = 0
  local smallFontHeight = 0
  
  --[[
  Die Schriftart "Consolas" macht Probleme, deshalb gibts einen
  Korrekturfaktor. Das Problem war, dass die Berechnung der 
  Spaltenbreiten bei dieser Schriftart nicht funktioniert hat.
  (Die Spalten waren erheblich zu klein.) Ich vermute, dass die
  Abfrage der Zeichenbreite in dieser Schriftart nicht funktioniert.
  Mit anderen von mir getesteten Schriftarten gings, aber ich hab
  natürlich auch nicht alle durchprobiert.
  Die Bestimmung der Hauptkonsolen-Breite hat übrigens auch damit
  funktioniert.]]
  local correctionFactor = 1
  if getFont() == "Consolas" then
    correctionFactor = 1.05--1.13
  end
  
  --[[
  Durchschnittliche Höhe bzw. Breite eines Buchstabens aus dem eingestellten
  Font in der eingestellten Font-Größe sowie auch für die kleine und die
  ganz kleine Schriftart. Wird benötigt um zu berechnen, wie groß ein 
  Bereich auf der Oberfläche sein muss, um dort eine bestimmte Anzahl Zeichen
  neben- oder übereinander anzuzeigen.]]
  defaultFontWidth, defaultFontHeight = calcFontSize(defaultFontSize, getFont());
  smallFontWidth, smallFontHeight = calcFontSize(smallFontSize, getFont());
  
  --[[
  Die Breite der Hauptconsole soll so sein, dass die Texte von Avalon
  darin vollständig angezeigt werden. Aber nicht unnötig viel größer.
  Für mich hab ich mal ausgerechnet, dass ich eine Zeilenbreite von
  79 Zeichen brauche. Spieler die diesen komischen Kompass verwenden,
  den Avalon vor dem Prompt anzeigt, brauchen anscheinend eher eine
  Breite von 84 Zeichen. Zur Breite kommt außerdem noch die Scrollbar
  dazu.
  Da ich einerseits dem User ermöglichen möchte, die vollen 84 Zeichen
  zu nutzen, andererseits aber erhebliche Platzprobleme auf meinem
  Display habe, wird Avalet in diesem Bereich skalieren. Wenn möglich,
  werden 84 Zeichen angezeigt. Aber wenn der Platz nicht reicht, dann
  geht Avalet runter auf bis zu 79 Zeichen. Wenn das immer noch nicht reicht,
  dann wird am rechten Rand ein bisschen was abgeschnitten (wenn die rechte
  Spalte angezeigt wird). Und wenn auch das nicht reicht, dann wählt
  Avalet das nächstkleinere Layout aus. So jedenfalls ist der Plan.]]
  -- CPL = Characters per line
  local minCPLMainConsole = 79  -- 79 reicht, 
  local maxCPLMainConsole = 84  -- 84 gibt Ava die volle genutzte Breite
  
  --[[
  Die Breite des Scrollbar (von der Hauptconsole) muss auch berücksichtigt
  werden. Ich nehme mal erstmal eine Breite von 2 Zeichen. ]]
  local widthScrollBar = 2*defaultFontWidth
  
  -- Minimale und maximale Größe der Hauptkonsole.
  local widthMainConsoleMin = (defaultFontWidth * minCPLMainConsole) + widthScrollBar
  local widthMainConsoleMax = (defaultFontWidth * maxCPLMainConsole) + widthScrollBar
  
  --[[ 
  Für die linke Spalte habe ich einfach eine Breite von 27 Zeichen fest-
  gelegt. Bestimmend ist hier eigentlich die Ingame-Map, die nunmal eine
  gewisse Breite hat. Die anderen Elemente kommen auch mit weniger Platz
  zurecht. (Oder bräuchten sehr viel mehr, die schneide ich einfach ab.)
  Auch hier hat sich wieder ein Offset bewährt. ]]
  local minCPLLeftColumn = 27--33
  
  -- Daraus resultierende Spaltenbreite.
  local widthLeftColumn = math.floor(smallFontWidth * minCPLLeftColumn * correctionFactor)

  --[[
  Die rechte Spalte soll ja Ausgaben aus der Hauptconsole anzeigen, also
  sowas wie "Spielstand" und das Inventar und so. Es macht also Sinn, die
  Breite der rechten Spalte so zu bemessen, dass die gleiche Zeichenzahl
  pro Zeile angezeigt werden kann wie in der Hauptkonsole. Allerdings in
  einer kleineren Schriftart - die Seitenbereiche verwenden die "Small"-
  Größe. Da hier der Zeilenumbruch vom MUD vorgegeben wird, könnte die
  rechte Spalt auch problemlos größer ausfallen - da wäre es dann halt
  schwarz. Aber in der rechten Spalte von Avalet werden auch die Kommuni-
  kationstabs angezeigt. Und die machen den Zeilenumbruch selbst. Was
  einerseits praktisch ist, weil man sich nicht drum kümmern muss. Anderer-
  seits werden die Texte auch nicht lesbarer, wenn die sehr in die Breite
  gezogen werden. Deshalb wird die rechte Spalte nicht größer als nötig,
  um den Hauptkonsolen-Text in der Small-Schrift auszugeben. Dadurch ent-
  stehen drei unterschiedliche Situationen.
  1.: das Fenster ist genau richtig groß. Kommt so gut wie nie vor, ist 
  dann aber praktisch, weil nichts gemacht werden muss. 
  2.: das Fenster ist zu klein. Da die Breite der linken Spalte und der
  Hauptkonsole fix sind, geht das dann zulasten der rechten Spalte. Und
  wenn die nicht richtig passt, dann schaltet Avalet auf ein platz-
  sparenderes Layout um.
  3.: das Fenster ist zu groß. Alle drei Spalten haben Platz, und dann ist
  da noch was über. In diesem Fall würde die Hauptkonsole automatisch den 
  maximal möglichen Platz einnehmen. Kann man so lassen, dadurch entsteht
  aber unter Umständen ein größerer leerer Bereich zwischen der Hauptkonsole
  und der rechter Spalte. Und das sieht auch nicht aus. Deshalb gibt es ein
  Kompensationselement, das in diesem Fall den überzähligen Platz am rechten
  Rand einnimmt. ]]
  
  local widthRightColumn = 0
  local widthRightColumnMax = 0
  local widthRightColumnMin = 0

  --[[
  Es gibt eine Ausgleichsfläche, falls zu viel Platz auf dem Monitor ist. Diese
  Fläche wird am rechten Rand, rechts von der rechten Spalte erzeugt. Andernfalls
  würde die rechte Spalte manchmal SEHR breit und der dort angezeigte Text (die
  Kommunikations-Tabs) sehr schlecht lesbar werden. ]]
  local widthCompensation = 0
  
  --[[
  die Breite der rechten Spalte orientiert sich an der Zeichenzahl in der
  Hauptkonsole ]]
  widthRightColumnMin = smallFontWidth * minCPLMainConsole * correctionFactor
  widthRightColumnMax = smallFontWidth * maxCPLMainConsole * correctionFactor

  --[[
  Oberhalb und unterhalb der Hauptconsole gibt es Bereiche, in denen je nach Layout
  ebenfalls Informationen angezeigt werden. Die Höhe für diese Bereiche ist abhängig
  von der eingestellten Schriftgröße. Damit sollte sich die Oberfläche von Avalet
  unterschiedlichen Auflösungen und unterschiedlichen Bildschirmgrößen anpassen können
  - jedenfalls wenn der User eine lesbare Schriftgröße einstellt.
  In manchen Layouts werden die obere und die untere Zeile nicht angezeigt. Das wird 
  aber unter "initUI" geregelt - hier wird nur die Größe ermittelt, die die Zeile
  hätte, wenn sie angezeigt werden würde. (Weil davon andere Werte abhängig sind, die
  auch noch richtig sein müssen, wenn die Zeile gar nicht angezeigt wird.)
  Die Zeilen haben fixe Größen, auch wenn ihr Inhalt tatsächlich über sie hinausragen
  kann (die Timer zum Beispiel). ]]
  local heightTopBar = defaultFontHeight
  local heightBottomBar = defaultFontHeight * 2.5--3.5
 
  --[[
  Avalet kann zwischen verschiedenen Layouts umschalten. Und tut das auch, und
  zwar in Abhängigkeit von der Fensterbreite von Mudlet. (Oder eigentlich von
  der Breite vom Profil - man kann mit Mudlet ja auch zwei Profile nebeneinander
  anzeigen.) Es gibt folgende Layouts:
  Layout FULL (4): das default-Layout mit drei Spalten.
  Layout COMPACT (3): die linke Spalte entfällt, angezeigt wird nur die Hauptconsole 
  und die rechte Spalte. Die Anzeige-Elemente aus der linken Spalte werden aufgeteilt
  und in waagerechten Bereichen oberhalb und unterhalt der Hauptconsole angezeigt.
  Layout REDUCED (2): die RECHTE Spalte entfällt, angezeigt wird nur die Hauptkonsole 
  und die linke Spalte. Einen Ersatz für die rechte Spalte gibt es nicht.
  Layout MULTIVIEW (1): sowohl die linke als auch die rechte Spalte entfallen, angezeigt 
  wird nur die Hauptkonsole. Die Informationen aus der linken Spalte werden wieder auf
  waagerechte Bereiche oberhalb und unterhalb der Hauptconsole verlegt. (Wie bei
  Layout 3.) Die rechte Spalte entfällt wieder ersatzlos. (Wie bei Layout 2.)
  Und dann gibt es noch ein Layout 0 - da wird einfach nur noch die Hauptconsole
  angezeigt. Das geschieht, wenn das Fenster sogar für die Hauptconsole eigentlich
  zu klein ist. Ist also eher ein fallback-Layout. Nochmal zusammengefasst:
  4 = FULL = default, alle Spalten, alle Inhalte
  3 = COMPACT = zwei Spalten (mitte und rechts), alle Inhalte
  2 = REDUCED = zwei Spalten (links und mitte), Inhalte der rechten Spalte entfallen
  1 = MULTIVIEW = eine Spalte, Inhalte der rechten Spalte entfallen
  0 = NONE = fallback für wenn gar nix geht
  ]]
  local LAYOUT = avalet.CONSTS.LAYOUT
  --LAYOUT["NONE"] (= 0), LAYOUT["MULTIVIEW"] (= 1), LAYOUT["REDUCED"] (= 2),
  --LAYOUT["COMPACT"] (= 3), LAYOUT["FULL"] (= 4),
  
  local layout = nil
  
  --[[
  
  Hier wird jetzt ermittelt, welches Layout es denn nun sein soll. 
  ================================================================ ]]

  --[[
  Wenn das Fenster groß genug ist für alle vorgesehenen Elemente (also für alle
  drei Spalten), dann werden einfach alle drei Bereiche in voller Größe angezeigt.
  Und der überzählige Platz geht an die Ausgleichsfläche.]]
  if widthMainWindow &gt; widthLeftColumn + widthMainConsoleMax + widthRightColumnMax then
    avalet.log("calculateUI: Fenster ist mehr als groß genug für alle Elemente", 2)

    layout = LAYOUT["FULL"] 

    widthMainConsole = widthMainConsoleMax
    widthRightColumn = widthRightColumnMax
    widthCompensation = widthMainWindow - (widthLeftColumn + widthMainConsole + widthRightColumn)
    
  --[[
  Reicht der Platz nicht für die maximale Größe, aber für die Version mit weniger Zeichen in
  der Hauptkonsole und in der rechten Spalte, dann wird es halt diese. Da muss dann ermittelt
  werden, wie viele Zeichen maximal gehen. ]]
  elseif widthMainWindow &gt;= widthLeftColumn + widthMainConsoleMin + widthRightColumnMin then
    avalet.log("calculateUI: Fenster ist  nur FAST groß genug für alle Elemente", 2)

    layout = LAYOUT["FULL"] 
    
    --[[
    Die Größe der linken Spalte ist fix. Die Größe der rechten Spalte ist direkt abhängig von
    der Größe der Hauptconsole, da in beiden die gleiche Anzahl Zeichen je Zeile möglich sein
    soll (aber in unterschiedlichen Schriftgrößen). Hier wird vom Maximalwert der Hauptconsole
    (84 Zeichen, siehe oben) runtergezählt, bis der Platz reicht. Somit wird die maximal
    mögliche Zeichenbreite erreicht. ]]
    for i = maxCPLMainConsole, minCPLMainConsole, -1 do
      widthMainConsole = (defaultFontWidth * i) + widthScrollBar
      widthRightColumn = smallFontWidth * i * correctionFactor
      if widthMainWindow &gt;= widthLeftColumn + widthMainConsole + widthRightColumn then
        --[[
        Es kann noch einen kleinen Streifen Platz rechts am Rand geben, der wird
         jetzt noch der rechten Spalte zugeschlagen. ]]
        widthRightColumn = widthMainWindow - widthLeftColumn - widthMainConsole
        break
      end
    end
  --[[
  Wie viel ich auch gerechnet habe - ich bekomme einfach die dreispaltige Anzeige nicht in
  der von mir bevorzugten Schriftart (Consolas) und in der von mir benötigten Schriftgröße (12) 
  auf meinen 15,6 Zoll Monitor. Es fehlen weniger als 50 Pixel in der Breite. Aber ich kann auf
  diese Pixel am rechten Bildrand verzichten. Und das tue ich hier. Die rechte Spalte wird hier
  einfach kleiner gemacht als nötig. ]]
  elseif widthMainWindow + 50 &gt;= widthLeftColumn + widthMainConsoleMin + widthRightColumnMin then
    avalet.log("calculateUI: Fenster ist NICHT groß genug für alle Elemente, wird aber erzwungen.", 2)

    layout = LAYOUT["FULL"] 

    --[[
    Hier wird die oben eingestellte MINIMALE Anzahl Zeichen je Zeile für die Hauptconsole einge-
    stellt. Und dann wird von der rechten Spalte so wenig wie möglich abgeschnitten. Ein Rest
    für eine Ausgleichsfläche kann hier natürlich nicht übrig bleiben. ]]
    widthMainConsole = widthMainConsoleMin
    for i = 1, 50, 1 do
      widthRightColumn = widthRightColumnMin - i
      if widthMainWindow &gt;= widthLeftColumn + widthMainConsole + widthRightColumn then
        break
      end
    end

  --[[
  Reicht der Platz nicht für die dreispaltige Anzeige, dann ja vielleicht für Layout COMPACT.
  Hier wird jetzt zuerst geschaut, ob der Platz wenigstens für die schmale Version (mit weniger
  Zeichen je Zeile) reicht. Und dann erst ermittelt, wie viele Zeichen tatsächlich passen.]]
  elseif widthMainWindow &gt;= widthMainConsoleMin + widthRightColumnMin then
    avalet.log("calculateUI: Fenster ist nur groß genug für Layout COMPACT", 2)
    
    layout = LAYOUT["COMPACT"]  -- In Layout 3 wird die linke Spalte nicht angezeigt.

    for i = maxCPLMainConsole, minCPLMainConsole, -1 do
      -- warum auch immer, aber das hier funktioniert nur ohne correctionFactor:
      widthMainConsole = math.floor((defaultFontWidth * i)) + widthScrollBar
      widthRightColumn = math.floor((smallFontWidth * i)  * 1.05) -- neuer Korrekturfaktor
      widthCompensation = widthMainWindow - (widthMainConsole + widthRightColumn)
      if widthMainWindow &gt;= widthMainConsole + widthRightColumn then
        break
      end
    end

  --[[
  Wenn der Platz jetzt immer noch nicht reichte, dann ja vielleicht für Layout REDUCED.
  Ablauf ist wie bei Layout COMPACT, nur eben mit der linken statt der rechten Spalte.
  (Zur Erinnerung: Die linke Spalte hat eine fixe Größe.)]]
  elseif widthMainWindow &gt;= widthLeftColumn + widthMainConsoleMin then
    avalet.log("calculateUI: Fenster ist nur groß genug für Layout REDUCED", 2)

    layout = LAYOUT["REDUCED"]
 
    for i = maxCPLMainConsole, minCPLMainConsole, -1 do
      widthMainConsole = (defaultFontWidth * i) + widthScrollBar
      widthCompensation = widthMainWindow - (widthLeftColumn + widthMainConsole)
      if widthMainWindow &gt;= widthLeftColumn + widthMainConsole then
        break
      end
    end

  --[[
  Die schmalste Version von Avalet ist die mit einer Spalte.]]
  elseif widthMainWindow &gt;= widthMainConsoleMin then
    avalet.log("calculateUI: Fenster ist nur groß genug für Layout MULTIVIEW", 2)

    layout = LAYOUT["MULTIVIEW"]

    for i = maxCPLMainConsole, minCPLMainConsole, -1 do
      widthMainConsole = (defaultFontWidth * i) + widthScrollBar
      widthCompensation = widthMainWindow - widthMainConsole
      if widthMainWindow &gt;= widthMainConsole then
        break
      end
    end

  --[[
  Wenn die Fensterbreite aber auch für ein 1-spaltiges Avalet nicht mehr
  reicht, dann wird alles ausgeblendet. Und die nackte Hauptkonsole angezeigt.
  (Das wird nicht funktionieren und ist nicht richtig implementiert. Ist auch
  nicht wichtig, denke ich. Wäre sonst aber ein TODO. ]]
  elseif widthMainWindow &gt;= 0 then
    avalet.log("calculateUI: Fenster ist für gar nichts groß genug", 2)

    layout = LAYOUT["NONE"]

  else
    avalet.log("Function calculateUI konnte sich auf kein Layout einigen", 4)
  end
  
  -- Die Kompensationsfläche kann auch Null sein, aber nicht kleiner.
  if widthCompensation &lt; 0 then widthCompensation = 0 end
  
  --[[
  Die ermittelten Werte werden in den globalen Namensraum geschrieben, für spätere Verwendung. 
  ACHTUNG: Wenn aus dem Layout hervorgeht, dass einzelne Bereiche nicht auf der Oberfläche an-
  gezeigt werden (linke Spalte, untere Zeile, ...), dann ist deren Breite HIER NOCH NICHT NULL.
  Auf Null gesetzt wird das erst kurz vorm erzeugen der GUI-Elemente, bei "initUI". Das ist so,
  weil beispielsweise die breite der linken Spalte auch noch in anderen Bereichen verwendet wird,
  auch wenn die linke Spalte selber gar nicht zu sehen sein wird. ]]
  avaletUI.dimensions.widthLeftColumn = widthLeftColumn
  avaletUI.dimensions.heightLeftColumn = heightMainWindow
  avaletUI.dimensions.widthMainConsole = widthMainConsole
  avaletUI.dimensions.widthRightColumn = widthRightColumn
  avaletUI.dimensions.heightRightColumn = heightMainWindow
  avaletUI.dimensions.widthCompensation = widthCompensation
  avaletUI.dimensions.heightTopBar = heightTopBar
  avaletUI.dimensions.heightBottomBar = heightBottomBar
  avaletUI.dimensions.layout = layout
  avaletUI.dimensions.defaultFontWidth = defaultFontWidth
  avaletUI.dimensions.defaultFontHeight = defaultFontHeight
  avaletUI.dimensions.smallFontWidth = smallFontWidth
  avaletUI.dimensions.smallFontHeight = smallFontHeight
  avaletUI.dimensions.widthScrollBar = widthScrollBar
  
end --function avaletUI.calculateUI()
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>initUI</name>
				<packageName></packageName>
				<script>--[[
Hier wird die GUI initialisiert. Das heißt:
1. Die Verteilung wird berechnet. Also die Größe der verschiedenen Elemente. Das
   geschieht in der Funktion avaletUI.calculateUI, die hier gleich als erstes
   aufgerufen wird. Am Ende der Funktion sollten die wesentlichen Werte berechnet
   sein. Insbesondere wird dort auch berechnet, welches Layout verwendet werden 
   soll. Dokumentation und Erklärung zum "Layout" dort. 
2. Anschließend wird in dieser Funktion hier die Grundstruktur der Oberfläche
   mit all ihren Containern und Unter-Containern und einigen Labels erstellt.
   Hier wird das Layout berücksichtigt. Es werden also manche Elemente angezeigt,
   andere nicht - und manche Elemente werden je nach Layout in verschiedenen
   Containern angezeigt. Beispiel: Die Icons für "Under Attack" und "Statuseffekt"
   werden mal in der linken Spalte und mal in dem Bereich unterhalb der Haupt-
   konsole angezeigt. Die Spalten, die NICHT angezeigt werden sollen, werden dabei
   trotzdem erzeugt, aber mit einer Breite (oder Höhe, je nachdem) von Null. Der
   Grund dafür ist, dass die Oberfläche sonst nicht sauber erzeugt wird.
3. Die Inhalte der einzelnen Bereiche, als die angezeigten Werte beispielsweise,
   werden dann wieder in extra Funktionen hinzugefügt. Der Sinn ist, dass die
   gesamte Oberfläche nicht jedesmal berechnet werden muss, wenn sich beispiels-
   weise die TP des Chars ändern. In diesem Fall würde nur die Funktion ausgeführt
   werden, die dieses Element hinzufügt (bzw. dann eben aktualisiert). Die ge-
   samte Oberfläche muss nur berechnet werden, wenn sich ihre Größe ändert (oder
   beim Start.)
]]
function avaletUI.initUI()
  avalet.log("Function avaletUI.initUI()", 1)

  local widthLeftColumn = avaletUI.dimensions.widthLeftColumn
  local heightLeftColumn = avaletUI.dimensions.heightLeftColumn
  local widthRightColumn = avaletUI.dimensions.widthRightColumn
  local heightRightColumn = avaletUI.dimensions.heightRightColumn
  local heightTopBar = avaletUI.dimensions.heightTopBar
  local heightBottomBar = avaletUI.dimensions.heightBottomBar
  local widthMainConsole = avaletUI.dimensions.widthMainConsole
  local widthCompensation = avaletUI.dimensions.widthCompensation
  
  local defaultFontHeight = avaletUI.dimensions.defaultFontHeight


  --[[
  Die Bereiche um die Hauptkonsole rum sind "adjustable Container" (adjCont).
  Diese Art von Containern bietet die Möglichkeit, den User deren Größe selber
  bestimmen zu lassen. Dazu würden ihre Eigenschaften so geändert werden, dass
  auf der Oberfläche ein Rahmen sichtbar ist, der dann mit der Maus zurecht-
  gezogen werden könnte. Das sollte allerdings nicht notwendig sein und ist
  deshalb auch nicht implementiert.
  Die Größe der "AdjustableContainer"-Elemente kann gesichert und wieder hergestellt
  werden. Das sollte mal ein Feature sein, damit die User ihre Rahmengrößen selber
  bestimmen können. Aber das hab ich nicht umgesetzt. Wer User was selber einstellen
  lässt ist schließlich nur zu feige, ihnen die eigenen Entscheidungen aufzuzwingen. :) ]]
  --local adjContSettingsDir = avalet.MODULE_HOME_DIR.."/AdjustableContainerSettings/"

  --[[
  Die Layouts:
  Layout FULL ist das default-Layout mit drei Spalten.
  Layout COMPACT ist das Layout, bei dem die linke Spalte wegfällt und nur
  die Hauptconsole und die rechte Spalte angezeigt wird. Der Inhalt der
  linken Spalte wird oberhalb und unterhalb der Hauptconsole angezeigt.
  Layout REDUCED ist das Layout, bei dem die rechte Spalte wegfällt.
  Layout MULTIVIEW ist das Layout, bei dem die rechte und die linke Spalte wegfallen.
  Der Inhalt der linken Spalte wird wieder oberhalb und unterhalb der Haupt-
  console angezeigt.
  Layout NONE ist das Layout, bei dem nur die nackte Hauptkonsole angezeigt wird,
  also sozusagen "Mudlet naked". Dieses Layout wird angezeigt, wenn so wenig
  Platz ist, dass die Bereiche oberhalb und unterhalb von der Hauptkonsole zu
  wenig Platz hätten. ]]
  local layout = avaletUI.dimensions.layout
  local LAYOUT = avalet.CONSTS.LAYOUT
  --LAYOUTS["MULTIVIEW"] = 1,
  --LAYOUTS["REDUCED"] = 2,
  --LAYOUTS["COMPACT"] = 3,
  --LAYOUTS["FULL"] = 4,

  --[[
  Hier werden ein paar Layout-spezifische Einstellungen vorgenommen. Vor allem werden hier
  die Werte der Bereiche genullt, die das jeweilige Layout nicht anzeigt. ]]
  if layout == LAYOUT["FULL"] then -- Linke Spalte vorhanden, rechte auch.
    -- Wenn die linke Spalte vorhanden ist, dann hat die obere Zeile die Höhe 0.
    heightTopBar = 0
    -- Wenn die linke Spalte vorhanden ist, dann hat die untere Zeile die Höhe 0.
    heightBottomBar = 0

  elseif layout == LAYOUT["COMPACT"] then -- Linke Spalte NICHT vorhanden, rechte schon.
    widthLeftColumn = 0
  
  elseif layout == LAYOUT["REDUCED"] then -- Linke Spalte vorhanden, rechte nicht.
    -- Wenn die linke Spalte vorhanden ist, dann hat die obere Zeile die Höhe 0.
    heightTopBar = 0
    -- Wenn die linke Spalte vorhanden ist, dann hat die untere Zeile die Höhe 0.
    heightBottomBar = 0
    -- Keine rechte Spalte in diesem Layout
    widthRightColumn = 0
  elseif layout == LAYOUT["MULTIVIEW"] then -- Linke Spalte NICHT vorhanden, rechte auch nicht.
    widthLeftColumn = 0
    widthRightColumn = 0
  else  
    --[[
    Regulär kann diesen Teil eigentlich nur das NONE-Layout auslösen. Das ist das
    fallback-Layout für wenn alle Stricke reißen. Hier sollte von Avalet gar nichts
    zu sehen sein. ]]
    widthLeftColumn = 0
    widthRightColumn = 0
    heightTopBar = 0
    heightBottomBar = 0
  end
  

  --[[
  Obere Leiste
  Die obere Leiste wird zur Zeit nicht verwendet. Diese Entscheidung ist aber
  nicht zwingend endgültig. Deshalb existiert sie noch und hat aber die Höhe Null. ]]
  heightTopBar = 0
  avaletUI.adjContTop = Adjustable.Container:new({
    name = "avaletUI.adjContTop", 
    y=0, height = heightTopBar, 
    autoLoad = false, 
    autoSave=false,
    lockStyle = "full",
    locked=true,
  })

    
  --[[
  Untere Leiste
  Die untere Leiste wird nur benötigt, wenn die linke Spalte nicht angezeigt wird.
  Sonst ist ihre Höhe Null.]]
  avaletUI.adjContBottom = Adjustable.Container:new({
    name = "avaletUI.adjContBottom", 
    height = heightBottomBar, y = ((heightBottomBar)*(-1)), 
    autoLoad = false,
    autoSave=false,
    lockStyle = "full", 
    locked=true,
  })
  
  --[[
  Linke Spalte
  Die linke Spalte wird nur in Layout 4 und 2 angezeigt. Bei
  den anderen Layouts existiert sie auch, aber ihre Breite ist
  Null. ]]
  avaletUI.adjContLeft = Adjustable.Container:new({
    name = "avaletUI.adjContLeft", 
    x = 0, y = 0, 
    height = "100%", width = widthLeftColumn, 
    autoLoad = false,
    autoSave=false,
    lockStyle = "full", 
    locked=true,
  })
 
  -- Der Container für die rechten Spalte enthält zusätzlich die Ausgleichsfläche
  avaletUI.adjContRight = Adjustable.Container:new({
    name = "avaletUI.adjContRight", 
    x = ((widthRightColumn+widthCompensation)*-1), y = 0, 
    height = "100%", width = widthRightColumn+widthCompensation, 
    autoLoad = false,
    autoSave=false,
    lockStyle = "full", 
    locked=true,
  })

  avaletUI.adjContTop:attachToBorder("top")
  avaletUI.adjContBottom:attachToBorder("bottom")
  avaletUI.adjContLeft:attachToBorder("left")
  avaletUI.adjContRight:attachToBorder("right")
  
  avaletUI.adjContTop:connectToBorder("left")
  avaletUI.adjContTop:connectToBorder("right")
  avaletUI.adjContBottom:connectToBorder("left")
  avaletUI.adjContBottom:connectToBorder("right")

  
  --[[
  Damit ist die Grundstruktur der Seite erzeugt, also die Bereiche rund um die
  Hauptkonsole rum. Jetzt werden dort noch die Unterbereiche angelegt. Den
  Inhalt dieser Unterbereiche fügen dann jeweils dafür vorgesehene Funktionen
  hinzu. (Aufgerufen in der Funktion avaletUI.buildUI().) ]]
  
 
  --[[ 
  
  Inhalt der linken Spalte
  ======================== ]]
  
  local heightVitalsContainer = math.floor((widthLeftColumn / 16) * 10)
  local heightTimerContainer = defaultFontHeight * 10
  local heightDateTimeContainer = defaultFontHeight * 0
  local heightIGMapContainer = heightLeftColumn - heightVitalsContainer - heightTimerContainer - heightDateTimeContainer
  
  avaletUI.dimensions.heightVitalsContainer = heightVitalsContainer
  
  -- Der Bereich für Datum/Uhrzeit ist derzeit ausgeblendet.
  avaletUI.dateTimeContainer = Geyser.Container:new({
      name="avaletUI.dateTimeContainer", 
      x=0, y=0, 
      height=heightDateTimeContainer, width="100%"
  }, avaletUI.adjContLeft)

  -- Bereich für die Ingame-Map
  avaletUI.igmapContainer = Geyser.Container:new({
      name="avaletUI.igmapContainer", 
      x=0, y=heightDateTimeContainer, 
      height=heightIGMapContainer, width="100%"
  }, avaletUI.adjContLeft)

  -- Bereich für die Timer, die Hunger-/Durst/Alk-Anzeige
  -- und die Icons für Kampf bzw. Krankheiten/Seuchen/Flüche
  avaletUI.timerContainer = Geyser.Container:new({
      name="avaletUI.timerContainer", 
      x=0, y=heightLeftColumn-heightVitalsContainer-heightTimerContainer, 
      height=heightTimerContainer, width="100%"
  }, avaletUI.adjContLeft)

  -- Bereich für die Anzeige von TP, AP, ZP, Mana und dem Tick-Timer
  avaletUI.vitalsContainer = Geyser.Container:new({
      name="avaletUI.vitalsContainer", 
      x=0, y=heightLeftColumn-heightVitalsContainer, 
      height=heightVitalsContainer, width="100%"
  }, avaletUI.adjContLeft)


  --[[
  
  Inhalt der rechten Spalte
  
  ]]  
  
  --[[
  Hier wird noch eine zusätzliche Container-Ebene benötigt, um die Kompensationsfläche
  positionieren zu können. Es gibt also vertikal zwei Container, und in dem linken dann
  die beiden Container für die Inhalte auf der Seite. Der rechte Container bleibt frei.]]
  -- Linker äußerer Container
  avaletUI.contentContainer = Geyser.Container:new({
      name="avaletUI.contentContainer", 
      x=0, y=0, 
      height="100%", width=widthRightColumn
  }, avaletUI.adjContRight)

  -- Oberer innerer Container im linken äußeren Container
  avaletUI.infoBoxContainer = Geyser.Container:new({
      name="avaletUI.infoBoxContainer", 
      x=0, y=0, 
      height="55%", width="100%"
  }, avaletUI.contentContainer)

  -- Unterer innerer Container im linken äußeren Container
  avaletUI.chatBoxContainer = Geyser.Container:new({
      name="avaletUI.chatBoxContainer", 
      x=0, y="55%", 
      height="45%", width="100%"
  }, avaletUI.contentContainer)

  -- Rechter äußerer Container (leer)
  avaletUI.compensationContainer = Geyser.Container:new({
      name="avaletUI.compensationContainer", 
      x=widthRightColumn, y=0, 
      height="100%", width=widthCompensation
  }, avaletUI.adjContRight)


  --[[
  
  Inhalt der Zeile oberhalb von der Hauptconsole (TopBar)
  
  ]]  

  local widthLeftColumn = avaletUI.dimensions.widthLeftColumn
  local widthMainConsole = avaletUI.dimensions.widthMainConsole
  local defaultFontWidth = avaletUI.dimensions.defaultFontWidth


  avaletUI.topBarIGMapContainer = Geyser.Container:new({
      name="avaletUI.topBarIGMapContainer", 
      x=(widthMainConsole - (2*widthLeftColumn) - (2*defaultFontWidth)), y=0, 
      height=0, width=(2*widthLeftColumn)
  })--, avaletUI.adjContTop)

  --[[
  Inhalt der Zeile unterhalb der Hauptconsole (BottomBar) ]]
  local widthScrollBar = defaultFontWidth * 2
  local widthBottomBar = widthMainConsole - widthScrollBar
  local widthBottomVitals = widthBottomBar * 0.45
  local widthBottomIcons = heightBottomBar
  local widthBottomTimerContainer = widthLeftColumn
  local widthBottomHDA = widthBottomBar - widthBottomVitals - (widthBottomIcons * 2) - widthBottomTimerContainer

  avaletUI.bottomBarContainer = Geyser.Container:new({name="avaletUI.bottomBarContainer", x=0, y=0, height="100%", width="100%"}, avaletUI.adjContBottom)

  avaletUI.bottomBarVitals = Geyser.Container:new({
      name="avaletUI.bottomBarVitals",
      x=0, y=0,
      height="100%", width=widthBottomVitals,
  }, avaletUI.bottomBarContainer)
  avaletUI.bottomBarUnderAttack = Geyser.Label:new({name="avaletUI.bottomBarUnderAttack", x=widthBottomVitals, y=0, height=adjContBottomHeight, width=adjContBottomHeight, color="black"}, avaletUI.bottomBarContainer)
  avaletUI.bottomBarDistress = Geyser.Label:new({name="avaletUI.bottomBarDistress", x=widthBottomVitals+widthBottomIcons, y=0, height=adjContBottomHeight, width=adjContBottomHeight, color="black"}, avaletUI.bottomBarContainer)


  avaletUI.bottomBarTimerContainer = Geyser.Container:new({
      name="avaletUI.bottomBarTimerContainer", 
      x=(widthMainConsole - (1*widthLeftColumn) - (2*defaultFontWidth)), y=0, 
      width=widthBottomTimerContainer, height=(heightBottomBar - defaultFontWidth),
  }, avaletUI.bottomBarContainer)

  avaletUI.bottomBarTickContainer = Geyser.Label:new({
      name="avaletUI.bottomBarTickContainer", 
      x=(widthMainConsole - (1*widthLeftColumn) - (2*defaultFontWidth) + 5), y=(heightBottomBar - defaultFontWidth), 
      height=math.floor(avaletUI.dimensions.smallFontWidth * 0.7), width=widthBottomTimerContainer-10, 
  }, avaletUI.bottomBarContainer)


end --function avaletGUI.initUI()
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildIGMapUI</name>
				<packageName></packageName>
				<script>-- Initialisierung der Kartenelemente über der Hauptconsole (default: minimiert)
avaletUI.igMapLeftBoxCollapsed = avaletUI.igMapLeftBoxCollapsed or true
avaletUI.igMapRightBoxCollapsed = avaletUI.igMapRightBoxCollapsed or true
  
--[[
Hier wird der Bereich aufgebaut, der die Ingame-Map samt Raumnamen/Koordinaten und
Rauminventar enthält.
Da dieser Bereich mal in der linken Spalte und mal in einem verschiebbaren Overlay-
Fenster angezeigt wird, gibt es hier viel Code doppelt. Aber letztlich sind die 
Unterschiede zu groß gewesen, um das anders zu lösen. ]]
function avaletUI.buildIGMapUI()
  avalet.log("Function avaletUI.buildIGMapUI()", 1)
  
  local LAYOUT = avalet.CONSTS.LAYOUT
  local layout = avaletUI.dimensions.layout
  
  if layout == LAYOUT["FULL"] or layout == LAYOUT["REDUCED"] then -- Linke Spalte vorhanden

    if avaletUI.igMapLeftBox ~= nil then avaletUI.igMapLeftBox:hide() end
    if avaletUI.igMapRightBox ~= nil then avaletUI.igMapRightBox:hide() end
    if avaletUI.igMapCollapsedLeftBox ~= nil then avaletUI.igMapCollapsedLeftBox:hide() end
    if avaletUI.igMapCollapsedRightBox ~= nil then avaletUI.igMapCollapsedRightBox:hide() end

    avaletUI.buildLeftBarIGMapUI()
    avaletUI.igmapBox:show()

  elseif layout == LAYOUT["COMPACT"] or layout == LAYOUT["MULTIVIEW"] then -- Linke Spalte NICHT vorhanden

    if avaletUI.igmapBox ~= nil then avaletUI.igmapBox:hide() end

    local leftBoxIsCollapsed = avaletUI.igMapLeftBoxCollapsed
    local rightBoxIsCollapsed = avaletUI.igMapRightBoxCollapsed

    avaletUI.buildTopBarIGMapUI()
    avaletUI.buildCollapsedTopBarIGMapUI()

    if leftBoxIsCollapsed then
      avaletUI.igMapLeftBox:hide()
      avaletUI.igMapCollapsedLeftBox:show()
    else
      avaletUI.igMapLeftBox:show()
      avaletUI.igMapCollapsedLeftBox:hide()
    end
    
    if rightBoxIsCollapsed then
      avaletUI.igMapRightBox:hide()
      avaletUI.igMapCollapsedRightBox:show()
    else
      avaletUI.igMapRightBox:show()
      avaletUI.igMapCollapsedRightBox:hide()
    end

  else  
    -- NONE-Layout behandeln: alles ausblenden
    if avaletUI.igmapBox ~= nil then avaletUI.igmapBox:hide() end
    if avaletUI.igMapLeftBox ~= nil then avaletUI.igMapLeftBox:hide() end
    if avaletUI.igMapRightBox ~= nil then avaletUI.igMapRightBox:hide() end
    if avaletUI.igMapCollapsedLeftBox ~= nil then avaletUI.igMapCollapsedLeftBox:hide() end
    if avaletUI.igMapCollapsedRightBox ~= nil then avaletUI.igMapCollapsedRightBox:hide() end
  end
  
  --[[
  Die anderen Werte werden direkt ausgelesen beim malen der GUI-Label. Bei der Map
  muss etwas nachgeholfen werden. (Wenn der Buffer  leer ist passiert einfach nichts. ]]
  avaletUI.onMapChange()
  
end --function avaletUI.buildIGMapUI()


function avaletUI.buildLeftBarIGMapUI()
  avalet.log("Function avaletUI.buildLeftBarIGMapUI()", 1)

  local defaultFontHeight = avaletUI.dimensions.defaultFontHeight
  local smallFontHeight = avaletUI.dimensions.smallFontHeight
  local widthLeftColumn = avaletUI.dimensions.widthLeftColumn
  
  local offset = 15 -- Platz der einzelnen Bereiche zum Rand
  
  local heightRoomID = (defaultFontHeight * 3)
  -- In der linken Spalte soll immer ein gewisser Platz für die Map vorgesehen werden, auch wenn keine vorhanden ist.
  local heightIGMap = smallFontHeight * math.max(11, avalet.IGMapModel.mapCaptureRows)
  local heightRoomInv = defaultFontHeight * avalet.IGMapModel.roomInvMaxRows
  local widthAll = (widthLeftColumn-(2 * offset)) 

  -- Box für den Rahmen
  avaletUI.igmapBox = Geyser.Label:new({
      name="avaletUI.igmapBox", 
      x=0, y=0, 
      height="100%", width="100%", 
      color="black"
  }, avaletUI.igmapContainer)
  avaletUI.igmapBox:setStyleSheet(avaletUI.CSS.boxCSS:getCSS())
  avaletUI.igmapBox:hide()

  -- Bereich für die RoomID (Name und Koordinaten)
  avaletUI.roomID = Geyser.Label:new({
      name="avaletUI.roomID", 
      x=offset, y=offset,
      height=heightRoomID, width=widthAll, 
      color="black", 
      message=avalet.IGMapModel.roomID
  }, avaletUI.igmapBox)
  avaletUI.roomID:setFontSize(getFontSize())
  avaletUI.roomID:setFont(getFont())
  avaletUI.roomID:setStyleSheet([[
    qproperty-alignment: 'AlignHCenter | AlignVCenter';
    background-color: black;
  ]])

  -- Bereich für die Karte
  avaletUI.igmap = Geyser.MiniConsole:new({
      name = "avaletUI.igmap", 
      x=offset, y=heightRoomID+offset, 
      width=widthAll, height=heightIGMap,
      autoWrap = false,
      color = "black",
      scrollBar = false,
      fontSize = tonumber(getFontSize()-2),
    }, avaletUI.igmapBox)
  avaletUI.igmap:setFont(getFont())

  -- Bereich für RoomInv (Chars, Gegner, Leichen, Loot, Möbel, ...)
  avaletUI.roomInv = Geyser.Label:new({
      name="avaletUI.roomInv", 
      x=offset, y=offset+heightRoomID+heightIGMap,
      height=heightRoomInv, width=widthAll,
      color="black", 
      message=avalet.IGMapModel.avalonRoomInv
  }, avaletUI.igmapBox)
  avaletUI.roomInv:setStyleSheet([[
    qproperty-alignment: 'AlignLeft | AlignTop';
    background-color: black;
    ]])
  avaletUI.roomInv:setFontSize(getFontSize()-2)
  avaletUI.roomInv:setFont(getFont())

end --avaletUI.buildLeftBarIGMapUI()

--[[
Hier wird die Karte erzeugt, die über der Hauptconsole am oberen Bildschirmrand liegt. ]]
function avaletUI.buildTopBarIGMapUI()
  avalet.log("Function avaletUI.buildTopBarIGMapUI()", 1)

  local widthLeftColumn = avaletUI.dimensions.widthLeftColumn
  local widthMainConsole = avaletUI.dimensions.widthMainConsole

  local defaultFontHeight = avaletUI.dimensions.defaultFontHeight
  local smallFontHeight = avaletUI.dimensions.smallFontHeight

  local offset = 15 -- Platz der einzelnen Bereiche zum Rand
  
  local heightTitleBar = defaultFontHeight*1.5  -- Die Höhe des Bereiches mit den Fenster-Symbolen
  local heightRoomID = (defaultFontHeight * 2)
  local heightIGMap = smallFontHeight * 12
  local heightRoomInv = defaultFontHeight * avalet.IGMapModel.roomInvMaxRows
  local widthAll = (widthLeftColumn-(2 * offset)) 

  -- Box für den Rahmen
  avaletUI.igMapLeftBox = Geyser.Label:new({
      name="avaletUI.igMapLeftBox", 
      x=0, y=0, 
      height=heightTitleBar+heightRoomID+offset+heightRoomInv+offset, width=widthLeftColumn, 
  }, avaletUI.topBarIGMapContainer)
  avaletUI.CSS.boxCSS:set("background-color", "rgba(0,0,0,255)")
  avaletUI.igMapLeftBox:setStyleSheet(avaletUI.CSS.boxCSS:getCSS())
  --avaletUI.CSS.boxCSS:set("background-color", "rgba(0,0,0,255)")
  avaletUI.igMapLeftBox:hide()
  
  --Minimize/Maximize-Button für den linken Rahmen
  avaletUI.igMapLeftBoxIcons = Geyser.Label:new({
      name="avaletUI.igMapLeftBoxIcons", 
      x=offset, y=0, 
      height=heightTitleBar, width=widthAll,
      fgColor="white",
      message="&amp;#128469;", --&amp;#128470; &amp;#128471;
  }, avaletUI.igMapLeftBox)
  avaletUI.igMapLeftBoxIcons:setColor(0,0,0,50)
  avaletUI.igMapLeftBoxIcons:setAlignment ("right")
  avaletUI.igMapLeftBoxIcons:setFontSize(getFontSize())
  avaletUI.igMapLeftBoxIcons:setClickCallback("avaletUI.toggleTopBarMapView", "Left")

  -- Box für den Rahmen der Karte
  avaletUI.igMapRightBox = Geyser.Label:new({
      name="avaletUI.igMapRightBox", 
      x="50%", y=0, 
      height=(heightTitleBar+heightIGMap+offset), width=widthLeftColumn, 
  }, avaletUI.topBarIGMapContainer)
  avaletUI.CSS.boxCSS:set("background-color", "rgba(0,0,0,255)")
  avaletUI.igMapRightBox:setStyleSheet(avaletUI.CSS.boxCSS:getCSS())
  avaletUI.igMapRightBox:hide()
  
  --Minimize/Maximize-Button für den rechten Rahmen
  avaletUI.igMapRightBoxIcons = Geyser.Label:new({
      name="avaletUI.igMapRightBoxIcons", 
      x=offset, y=0, 
      height=heightTitleBar, width=widthAll,
      fgColor="white",
      message="&amp;#128469;", --&amp;#128470; &amp;#128471;
  }, avaletUI.igMapRightBox)
  avaletUI.igMapRightBoxIcons:setColor(0,0,0,50)
  avaletUI.igMapRightBoxIcons:setAlignment ("right")
  avaletUI.igMapRightBoxIcons:setFontSize(getFontSize())
  avaletUI.igMapRightBoxIcons:setClickCallback("avaletUI.toggleTopBarMapView", "Right")
  
  -- Bereich für die RoomID (Name und Koordinaten)
  avaletUI.topBarRoomID = Geyser.Label:new({
      name="avaletUI.topBarRoomID", 
      x=offset, y=heightTitleBar,
      height=heightRoomID, width=widthAll,
      color="black", 
      message=avalet.IGMapModel.roomID
  }, avaletUI.igMapLeftBox)
  avaletUI.topBarRoomID:setFontSize(getFontSize())
  avaletUI.topBarRoomID:setFont(getFont())
  avaletUI.topBarRoomID:setStyleSheet([[qproperty-alignment: 'AlignHCenter | AlignVCenter';]])

  -- Bereich für die Karte
  avaletUI.topBarIGMap = Geyser.MiniConsole:new({
      name = "avaletUI.topBarIGMap", 
      x=offset, y=heightTitleBar, 
      width = widthAll, height = heightIGMap,
      autoWrap = false,
      color = "black",
      scrollBar = false,
      fontSize = tonumber(getFontSize()-2),
    }, avaletUI.igMapRightBox)
  avaletUI.topBarIGMap:setFont(getFont())
  --avaletUI.topBarIGMap:setColor(0,0,0,255)

  avaletUI.topBarRoomInv = Geyser.Label:new({
      name="avaletUI.topBarRoomInv", 
      x=offset, y=heightTitleBar+heightRoomID+offset,
      height=heightRoomInv, width=widthAll, 
      color="black", 
      message=avalet.IGMapModel.avalonRoomInv
  }, avaletUI.igMapLeftBox)
  avaletUI.topBarRoomInv:setStyleSheet([[qproperty-alignment: 'AlignLeft | AlignTop';]])
  avaletUI.topBarRoomInv:setFontSize(getFontSize()-2)
  avaletUI.topBarRoomInv:setFont(getFont())

end --avaletUI.buildTopBarIGMapUI()


--[[
Hier werden die Bereiche für die Karte über dem Hauptfenster erzeugt, wenn diese minimiert sind. ]]
function avaletUI.buildCollapsedTopBarIGMapUI()
  avalet.log("Function avaletUI.buildCollapsedTopBarIGMapUI()", 1)

  local widthLeftColumn = avaletUI.dimensions.widthLeftColumn
  local defaultFontHeight = avaletUI.dimensions.defaultFontHeight

  local offset = 15 -- Platz der einzelnen Bereiche zum Rand
  
  local heightTitleBar = defaultFontHeight*1.5  -- Die Höhe des Bereiches mit den Fenster-Symbolen
  local widthAll = (widthLeftColumn-(2 * offset)) 

  -- Box für den linken Rahmen
  avaletUI.igMapCollapsedLeftBox = Geyser.Label:new({
      name="avaletUI.igMapCollapsedLeftBox", 
      x=0, y=0, 
      height=heightTitleBar*1.3, width=widthLeftColumn, 
  }, avaletUI.topBarIGMapContainer)
  avaletUI.CSS.boxCSS:set("background-color", "rgba(0,0,0,255)")
  avaletUI.igMapCollapsedLeftBox:setStyleSheet(avaletUI.CSS.boxCSS:getCSS())
  --avaletUI.CSS.boxCSS:set("background-color", "rgba(0,0,0,255)")
  avaletUI.igMapCollapsedLeftBox:hide()
  
  --Minimize/Maximize-Button für den linken Rahmen
  avaletUI.igMapCollapsedLeftBoxIcons = Geyser.Label:new({
      name="avaletUI.igMapCollapsedLeftBoxIcons", 
      x=offset, y=0, 
      height=heightTitleBar, width=widthAll,
      fgColor="white",
      message="&amp;#128471;", --&amp;#128470; &amp;#128469;
  }, avaletUI.igMapCollapsedLeftBox)
  avaletUI.igMapCollapsedLeftBoxIcons:setColor(0,0,0,50)
  avaletUI.igMapCollapsedLeftBoxIcons:setAlignment ("right")
  avaletUI.igMapCollapsedLeftBoxIcons:setFontSize(getFontSize())
  avaletUI.igMapCollapsedLeftBoxIcons:setClickCallback("avaletUI.toggleTopBarMapView", "Left")


  -- Box für den Rahmen der Karte
  avaletUI.igMapCollapsedRightBox = Geyser.Label:new({
      name="avaletUI.igMapCollapsedRightBox", 
      x="50%", y=0, 
      height=heightTitleBar*1.3, width=widthLeftColumn, 
  }, avaletUI.topBarIGMapContainer)
  avaletUI.CSS.boxCSS:set("background-color", "rgba(0,0,0,255)")
  avaletUI.igMapCollapsedRightBox:setStyleSheet(avaletUI.CSS.boxCSS:getCSS())
  --avaletUI.CSS.boxCSS:set("background-color", "rgba(0,0,0,255)")
  avaletUI.igMapCollapsedRightBox:hide()
  
  --Minimize/Maximize-Button für den rechten Rahmen
  avaletUI.igMapCollapsedRightBoxIcons = Geyser.Label:new({
      name="avaletUI.igMapCollapsedRightBoxIcons", 
      x=offset, y=0, 
      height=heightTitleBar, width=widthAll,
      fgColor="white",
      message="&amp;#128471;", --&amp;#128470; &amp;#128469;
  }, avaletUI.igMapCollapsedRightBox)
  avaletUI.igMapCollapsedRightBoxIcons:setColor(0,0,0,50)
  avaletUI.igMapCollapsedRightBoxIcons:setAlignment ("right")
  avaletUI.igMapCollapsedRightBoxIcons:setFontSize(getFontSize())
  avaletUI.igMapCollapsedRightBoxIcons:setClickCallback("avaletUI.toggleTopBarMapView", "Right")

end --avaletUI.buildTopBarIGMapUI()

function avaletUI.toggleTopBarMapView(whichOne)

  if whichOne=="Left" then
    avaletUI.igMapLeftBoxCollapsed = not(avaletUI.igMapLeftBoxCollapsed)
  elseif whichOne =="Right" then
    avaletUI.igMapRightBoxCollapsed = not(avaletUI.igMapRightBoxCollapsed)
  end
  
  avaletUI.buildIGMapUI()

end



--[[
Hier wird die RoomID neu geschrieben, wenn sie sich geändert hat. Wenn Koordinaten dazu-
gehören, dann wird beim Model schon ein Zeilenumbruch vor die Koordinaten eingefügt.
Weil "Unterwelt x=-999 y=-999" zu viel Platz beansprucht. ]]
function avaletUI.onIGMapModelRoomIDChange()
  avalet.log("Function avaletUI.onIGMapModelRoomIDChange()", 1)
  
  local LAYOUT = avalet.CONSTS.LAYOUT
  local layout = avaletUI.dimensions.layout

  if layout == LAYOUT["FULL"] or layout == LAYOUT["REDUCED"] then -- Linke Spalte vorhanden
    avaletUI.roomID:echo(avalet.IGMapModel.roomID)
  elseif layout == LAYOUT["COMPACT"] or layout == LAYOUT["MULTIVIEW"] then -- Linke Spalte NICHT vorhanden
    avaletUI.topBarRoomID:echo(avalet.IGMapModel.roomID)
  end

end
registerAnonymousEventHandler("IGMapModelRoomIDChange", "avaletUI.onIGMapModelRoomIDChange")



--[[
Hier wird der Buffer, in den die gecapturte Map vom entsprechenden Trigger ge-
schrieben wurde, ausgelesen und in den entsprechenden GUI-Bereich geschrieben. 
Der Trigger hätte da auch gleich reinschreiben können, aber man muss glaubhaft
bleiben mit seinem MVC-Pattern! (Ist allerdings auch transparenter so.) ]]
function avaletUI.onMapChange()
  avalet.log("Function avaletUI.onMapChange()", 1)

  if avaletUI.igmap ~= nil then avaletUI.igmap:clear() end
  if avaletUI.topBarIGMap ~= nil then avaletUI.topBarIGMap:clear() end
  
  --[[
  Um einen Buffer auszulesen wird der Cursor an den Anfang der ersten Zeile gesetzt,
  dann die Zeile selektiert, dann die Selektion kopiert und dann als "rich text", 
  also mit den Farbinformationen, in die Miniconsole geschrieben. Und das dann für
  jede Zeile im Buffer. ]]
  for i = 0, avalet.IGMapModel.mapCaptureRows-1, 1 do
    moveCursor("IGmapBuffer", 0, i )
    selectCurrentLine("IGmapBuffer")
    copy("IGmapBuffer")

    local LAYOUT = avalet.CONSTS.LAYOUT
    local layout = avaletUI.dimensions.layout
  
    --[[
    Hier müsste noch die Ausgabe zentriert werden, damit die Karte auch nett mittig
    in ihrem Rahmen sitzt. TODO. Platz wäre bei mir für 26 Zeichen. (Aber das muss
    dann natürlich ausgerechnet werden.) Unter Umständen muss hier auch mehr Aufwand
    betrieben werden, nämlich für den Fall, dass die Karte größer ist als ihr Platz. ]]
    if layout == LAYOUT["FULL"] or layout == LAYOUT["REDUCED"] then -- Linke Spalte vorhanden
      if avaletUI.igmap ~= nil then 
        decho("avaletUI.igmap", copy2decho("IGmapBuffer").."\n")
      end
    elseif layout == LAYOUT["COMPACT"] or layout == LAYOUT["MULTIVIEW"] then -- Linke Spalte NICHT vorhanden
      if avaletUI.topBarIGMap ~= nil then
        decho("avaletUI.topBarIGMap", "  "..copy2decho("IGmapBuffer").."\n")
      end
    end
  end
end
registerAnonymousEventHandler("MapChange", "avaletUI.onMapChange")

--[[
Hier wird RoomInv in die Oberfläche geschrieben, also der Rauminhalt. Da das
Ausgabefeld für RoomInv an den Inhalt (Zeilenzahl) angepasst werden soll,
muss hier entweder nur der Inhalt überschrieben werden (wenn sich die Zeilen-
zahl nicht geändert hat) oder aber das ganze Element muss neu erzeugt werden.
In diesem Fall wird auch der Rest vom Karten-Element neu erzeugt, also einfach
die build-Funktion ausgeführt. ]]
function avaletUI.onRoomInvChange(event, arg)
  avalet.log("Function avaletUI.onRoomInvChange()", 1)

  local rowCountChange = false
  if arg then rowCountChange = arg end
  
  --[[
  Vor allem wenn die Karte über der Hauptconsole angezeigt wird, soll sie so wenig Platz
  wie möglich einnehmen. Deshalb wird das Ausgabefeld für RoomInv der tatsächlichen Textmenge
  angepasst und hat nicht einfach eine fixe Größe. Wenn sich also die Zeilenzahl im Vergleich
  zur derzeit angezeigten Version verändert, dann muss das Label neu gemalt werden. Hier wird
  dann gleich das ganze Map-Element neu gemalt. Verändert sich die Zeilenzahl nicht, muss
  einfach nur der Inhalt neu geschrieben werden. ]]
  if rowCountChange then
    avaletUI.buildIGMapUI()
  else

    local LAYOUT = avalet.CONSTS.LAYOUT
    local layout = avaletUI.dimensions.layout
  
    if layout == LAYOUT["FULL"] or layout == LAYOUT["REDUCED"] then -- Linke Spalte vorhanden
      if avaletUI.roomInv ~= nil then avaletUI.roomInv:echo(avalet.IGMapModel.avalonRoomInv) end
    elseif layout == LAYOUT["COMPACT"] or layout == LAYOUT["MULTIVIEW"] then -- Linke Spalte NICHT vorhanden
      if avaletUI.topBarRoomInv ~= nil then avaletUI.topBarRoomInv:echo(avalet.IGMapModel.avalonRoomInv) end
    end
  end

end
registerAnonymousEventHandler("AvalonRoomInvChange", "avaletUI.onRoomInvChange")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildTimerUI</name>
				<packageName></packageName>
				<script>function avaletUI.buildTimerUI()
  avalet.log("Function avaletUI.buildTimerUI()", 1)
 
  local LAYOUT = avalet.CONSTS.LAYOUT
  local layout = avaletUI.dimensions.layout
      
  if layout == LAYOUT["FULL"] or layout == LAYOUT["REDUCED"] then -- Linke Spalte vorhanden

    if avaletUI.bottomBarTimerBox ~= nil then avaletUI.bottomBarTimerBox:hide() end

    avaletUI.buildLeftColumnTimerUI()
    avaletUI.timerBox:show()
 
  elseif layout == LAYOUT["COMPACT"] or layout == LAYOUT["MULTIVIEW"] then -- Linke Spalte NICHT vorhanden

    if avaletUI.timerBox ~= nil then avaletUI.timerBox:hide() end

    avaletUI.buildBottomBarTimerUI()
    avaletUI.bottomBarTimerBox:show()

  else  
    -- NONE-Layout behandeln
    if avaletUI.timerBox ~= nil then avaletUI.timerBox:hide() end
    if avaletUI.bottomBarTimerBox ~= nil then avaletUI.bottomBarTimerBox:hide() end
  end
  
  -- NUR ZUM TESTEN AUSKOMMENTIERT; DAS HIER IST WICHTIG!!!!!! 
  avaletUI.recreateTimer()
end


function avaletUI.buildLeftColumnTimerUI()
  avalet.log("Function avaletUI.buildTimerUI()", 1)

  local widthLeftColumn = avaletUI.dimensions.widthLeftColumn

  --[[
  Die Größe der Icons für "under attack" und "distress" sind auch
  abhängig von der Schriftgröße. ]]
  local iconWidthHeight = avaletUI.dimensions.defaultFontWidth*3.5
    
  if widthLeftColumn == 0 then iconWidthHeight = 0 end

  avaletUI.timerBox = Geyser.Label:new({
      name="avaletUI.timerBox", 
      x=0, y=0, 
      height="100%", width=(widthLeftColumn-iconWidthHeight)-5
  }, avaletUI.timerContainer)
  avaletUI.timerBox:setStyleSheet(avaletUI.CSS.boxCSS:getCSS())
  avaletUI.timerBox:hide()

  --[[
  Gauges für die Timer
  Hier werden (derzeit) 9 Gauge-Elemente für die Timer erzeugt und positioniert.
  in der Funktion "recreateTimer" werden die Timer dann alle unsichtbar und
  nur die benötigten werden wieder sichtbar und mit Werten beschrieben.
  Eigentlich war geplant, die Timer dynamischer zu gestalten, so dass es auch
  mehr als neun werden könnten. (Der Rest sollte dann etwas zusammen rücken.)
  Aber es scheint nicht möglich zu sein, einmal erzeugte Gauge-Elemente wieder
  zu löschen. (Auf nil setzen wirkt jedenfalls nicht.) Deshalb die statische
  Lösung und das unsichtbar machen. ]]

  --[[
  Eigentlich sollten die Timer auch mal unterschiedliche Farben haben, so dass man
  sie leichter auseinanderhalten kann. Eigentlich sollte es aber auch viel mehr
  Timer geben. (Timer für Schutzzauber, Timer für Auren, Timer für Angriffszauber,
  Timer für Erfahrungsbonus, Timer für dies. Timer für das.) Dafür hatte ich mal
  ein angeblich harmonisches Farbset herausgesucht:
  avaletUI.GaugeFrontColorTimer = "#00575d" --Blue Stone
  avaletUI.GaugeFrontColorTimer = "#00929c" --Persian Green
  avaletUI.GaugeFrontColorTimer = "#66f5ff" --Aquamarine
  avaletUI.GaugeFrontColorTimer = "#993f00" --Brown
  avaletUI.GaugeFrontColorTimer = "#ff6900" --Orange
  avaletUI.GaugeFrontColorTimer = "#ffa566" --Atomic Tangerine ]]
  
  for k = 1, 9, 1 do
  	avaletUI["Timer"..k] = Geyser.Gauge:new({
  		name = "avaletUI.Timer"..k,
  		x = "5%", y = (100-(k*10)-4).."%",--x = "5%", y = (100-(k*11)-0).."%",
  		width="90%", height="9%",--width="90%", height="9%",
  		orientation = "goofy" --Fancy Rückschrittsbalken!
  	}, avaletUI.timerBox)
  	avaletUI["Timer"..k].back:setStyleSheet(avaletUI.CSS.GaugeBackCSS:getCSS())
  	avaletUI.CSS.GaugeFrontCSS:set("background-color", "#00575d")
  	avaletUI["Timer"..k].front:setStyleSheet(avaletUI.CSS.GaugeFrontCSS:getCSS())
    avaletUI["Timer"..k].text:setStyleSheet(avaletUI.CSS.GaugeTimerTextCSS:getCSS())
    --avaletUI["Timer"..k].text:setFontSize(9)
  	avaletUI["Timer"..k]:setValue(0, 600, "&lt;b&gt;Timer "..k.."&lt;/b&gt;")
    --avaletUI.CSS.GaugeTimerTextCSS
  end
  
  --avaletUI.recreateTimer()

end


function avaletUI.buildBottomBarTimerUI()
  avalet.log("Function avaletUI.buildTopBarTimerUI()", 1)
  
  local defaultFontWidth = avaletUI.dimensions.defaultFontWidth
  local defaultFontHeight = avaletUI.dimensions.defaultFontHeight
  local smallFontHeight = avaletUI.dimensions.smallFontHeight
  local heightBottomBar = avaletUI.dimensions.heightBottomBar
  
  --[[
  Die Höhe der Box für die Timer in der BottomBar ist abhängig von der Anzahl der
  grade laufenden Timer. Ab zwei Timer ragt sie in die Hauptcontole hinein, ist also
  höher als die BottomBar. Andererseits soll sie aber immer mindestens ihren Platz
  in der BottomBar geanspruchen, also eine minimale Größe nicht unterschreiten.
  Bei der Positionierung muss die Höhe dann wieder berücksichtigt werden. Auf der Y-Achse
  muss die Box so weit hochgezogen werden, dass sie unten mit ihrem vorgesehenen Platz
  abschliesst. ]]
  local heightBottomBarTimerBox = math.max((heightBottomBar - defaultFontWidth), (#avalet.listOfTimers * defaultFontHeight + smallFontHeight))
  
    -- Box für den Rahmen
  avaletUI.bottomBarTimerBox = Geyser.Label:new({
      name="avaletUI.bottomBarTimerBox", 
      x=0, y=((heightBottomBarTimerBox)*-1),
      height=heightBottomBarTimerBox, width="100%", 
  }, avaletUI.bottomBarTimerContainer)
  avaletUI.CSS.boxCSS:set("background-color", "rgba(0,0,0,0)")
  avaletUI.CSS.boxCSS:set("margin-top", "0px")
  avaletUI.bottomBarTimerBox:setStyleSheet(avaletUI.CSS.boxCSS:getCSS())
  avaletUI.CSS.boxCSS:set("margin-top", "5px")
  avaletUI.bottomBarTimerBox:hide()

  --local maxHeightBottomBarTimerBox = 10 * defaultFontHeight

  for k = 1, 9, 1 do
  	avaletUI["Timer"..k] = Geyser.Gauge:new({
  		name = "avaletUI.Timer"..k,
  		x = "5%", y = (heightBottomBarTimerBox - (k*defaultFontHeight) - 10),
  		width="90%", height=smallFontHeight,
  		orientation = "goofy" --Fancy Rückschrittsbalken!
  	}, avaletUI.bottomBarTimerBox)
  	avaletUI["Timer"..k].back:setStyleSheet(avaletUI.CSS.GaugeBackCSS:getCSS())
  	avaletUI.CSS.GaugeFrontCSS:set("background-color", "#00575d")
  	avaletUI["Timer"..k].front:setStyleSheet(avaletUI.CSS.GaugeFrontCSS:getCSS())
    avaletUI["Timer"..k].text:setStyleSheet(avaletUI.CSS.GaugeTimerTextCSS:getCSS())
    --avaletUI["Timer"..k].text:setFontSize(9)
  	avaletUI["Timer"..k]:setValue(0, 600, "&lt;b&gt;Timer "..k.."&lt;/b&gt;")
    --avaletUI.CSS.GaugeTimerTextCSS
  end


end --avaletUI.buildTopBarTimerUI()

--[[
function recreateTimer()
Diese Funktion baut die Timer-Anzeige auf der Oberfläche neu auf. Das heißt,
sie macht erstmal alle Timer-Gauges unsichtbar, bevor sie die Funktion aufruft,
die neue Timer macht ("refreshTimer()"). Der Sinn ist, dass nicht bei jeder
Aktualisierung der Timer-Gauges diese erstmal unsichtbar gemacht werden. Nötig
ist das ja nur, wenn sich die Anzahl der Timer verändert. ]]
function avaletUI.recreateTimer()
  avalet.log("Function avaletUI.recreateTimer()", 1)
  
  --[[
  Wenn die Timer in der BottomBar angezeigt werden, dann muss das Element neu
  gemalt werden, wenn sich die Anzahl der Timer ändert. Weil dann die Größe des
  Rahmens angepasst werden muss. ]]
  local LAYOUT = avalet.CONSTS.LAYOUT
  local layout = avaletUI.dimensions.layout
  if layout == LAYOUT["COMPACT"] or layout == LAYOUT["MULTIVIEW"] then -- Linke Spalte NICHT vorhanden
    --avaletUI.buildLeftColumnTimerUI()
    avaletUI.buildBottomBarTimerUI()
    avaletUI.bottomBarTimerBox:show()
  end
 
  --[[
  Alle Timer unsichtbar machen und Beschriftung löschen. Es gibt
  9 Gauge-Elemente auf der Oberfläche, also (max) 9 Timer: ]]
  for k = 1, 9, 1 do
    hideWindow("avaletUI.Timer"..k.."_front")
    hideWindow("avaletUI.Timer"..k.."_back")	
    avaletUI["Timer"..k]:setText ("")
  end

  -- Timer-Anzeige neu aufbauen:
  avaletUI.refreshTimer()
end --function recreateTimer()


--[[
function refreshTimer()
Wird durch den Sekunden-Timer direkt aufgerufen
Wird bei anderen Gelegenheiten indirekt über "recreateTimer()" aufgerufen.
Diese Funktion aktualisiert die Anzeige der Timer auf der Oberfläche bzw.
sie sorgt überhaupt für eine Anzeige von Timern auf der Oberfläche.
Wenn sich die Anzahl der anzuzeigenden Timer nicht ändernt, müssen die Gauge-
Elemente vorher nicht unsichtbar gemacht werden. Wenn sich die Anzahl ändert,
wird "recreateTimer()" ausgeführt (und von dort dann diese Funktion). ]]
function avaletUI.refreshTimer()
	avalet.log("Function avaletUI.refreshTimer()", 1)

  --[[
  gleich wieder aussteigen, wenn es gar keine Timer gibt:
  Hintergrund: bei einem Disconnect ist manchmal der TriggerTimer aktiv
  geblieben. Nach dem reconnect ist allerdings die Timer-Liste leer,
  so dass der Timer läuft, aber nichts angezeigt wird. Besser wäre
  vermutlich, die Timer vernünftig zu inititalisieren, also ggf. auch
  Timer weiterlaufen zu lassen. (EP-Verdoppelung war es hier, vielleicht
  weil der Timer nicht durch einen Trigger beendet wird.) TODO  ]]
  if #avalet.listOfTimers == nil or #avalet.listOfTimers == 0 then
      disableTimer("avaletTimersTimer")
  end
  
  -- Erstmal die Timer-Liste sortieren lassen:
	local sortedListOfTimers = avalet.sortListOfTimers()

	local timerSchriftfarbe = "white"
  
  for k, v in pairs(sortedListOfTimers) do
    showWindow("avaletUI.Timer"..k.."_front")
    showWindow("avaletUI.Timer"..k.."_back")		
    --[[
    Der Wert des Gauge-Elements, das die Restzeit anzeigt, darf
    nicht kleiner als 1 werden, sonst kommt die Anzeige durcheinander.
    Außerdem wird die Schriftfarbe verändert:
    "fuchsia" für 0 Sekunden Restlaufzeit und alles drüber hinaus.
    "rot" für 30 bis 1 Sekunde Restlaufzeit.
    "gelb" für 60 bis 30 Sekunden Restlaufzeit.
    "weiß" immer sonst ]]
    if v["remaining"] &lt; 1 then
      v["remaining"] = 1
      timerSchriftfarbe="fuchsia"
    elseif v["remaining"] &lt; 30 then
      timerSchriftfarbe="red"
    elseif v["remaining"] &lt; 60 then
      timerSchriftfarbe="yellow"
    else
      timerSchriftfarbe="white"
    end
    -- Wert des Timers setzen:
    avaletUI["Timer"..k]:setValue(tonumber(v["remaining"]), tonumber(v["duration"]), [[&lt;b&gt;&lt;font color="]]..timerSchriftfarbe..[["&gt;&amp;nbsp;]] .. v["name"] .. [[&lt;/b&gt;&lt;/font&gt;]])
  end
end

</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildIconsUI</name>
				<packageName></packageName>
				<script>--[[
Die Symbole kommen übrigens von https://game-icons.net/ ]]
function avaletUI.buildIconsUI()
  avalet.log("Function avaletUI.buildIconsUI()", 1)

  local imageFolderPath = avalet.IMAGE_FOLDER_PATH
  
  local imgFightNone = imageFolderPath.."sword-clash-white.svg"
  local imgFightUnderAttack = imageFolderPath.."sword-clash-magenta.svg"
  local imgDistressNone = imageFolderPath.."poison-bottle-white.svg"
  local imgDistressAvoidDeath = imageFolderPath.."poison-bottle-magenta.svg"

  imgFightNone = imgFightNone:gsub("[\\/]", "/")
  imgFightUnderAttack = imgFightUnderAttack:gsub("[\\/]", "/")
  imgDistressNone = imgDistressNone:gsub("[\\/]", "/")
  imgDistressAvoidDeath = imgDistressAvoidDeath:gsub("[\\/]", "/")

  if not (io.exists(imgFightNone)) then cecho("&lt;magenta&gt;Bild 'Kampf weiss' fehlt: "..imgFightNone.."\n") end
  if not (io.exists(imgFightUnderAttack)) then cecho("&lt;magenta&gt;Bild 'Kampf magenta' fehlt: "..imgFightUnderAttack.."\n") end
  if not (io.exists(imgDistressNone)) then cecho("&lt;magenta&gt;Bild Giftflasche weiss fehlt: "..imgDistressNone.."\n") end
  if not (io.exists(imgDistressAvoidDeath)) then cecho("&lt;magenta&gt;Bild Giftflasche magenta fehlt: "..imgDistressAvoidDeath.."\n") end
  
  local LAYOUT = avalet.CONSTS.LAYOUT
  local layout = avaletUI.dimensions.layout
  local target = ""
  local iconWidthHeight = avaletUI.dimensions.defaultFontWidth*3.5
    
  if layout == LAYOUT["FULL"] or layout == LAYOUT["REDUCED"] then -- Linke Spalte vorhanden
    
    if avaletUI.bottomBarUnderAttack ~= nil then avaletUI.bottomBarUnderAttack:hide() end
    if avaletUI.bottomBarDistress ~= nil then avaletUI.bottomBarDistress:hide() end
    if avaletUI.iconBottomBarUnderAttack ~= nil then avaletUI.iconBottomBarUnderAttack:hide() end
    if avaletUI.iconBottomBarDistress ~= nil then avaletUI.iconBottomBarDistress:hide() end

    avaletUI.iconContainer = Geyser.Container:new({
        name="avaletUI.iconContainer", 
        x="84%", y="2%", 
        height=2*iconWidthHeight, width=iconWidthHeight-5
    }, avaletUI.timerContainer)
    avaletUI.underAttack = Geyser.Label:new({
        name="avaletUI.underAttack", 
        x=0, y=0, 
        height=iconWidthHeight, width=iconWidthHeight, 
        color="black"
    }, avaletUI.iconContainer)
    avaletUI.distress = Geyser.Label:new({
        name="avaletUI.distress", 
        x=0, y="50%", 
        height=iconWidthHeight, width=iconWidthHeight, 
        color="black"
    }, avaletUI.iconContainer)    
    
    avaletUI.iconContainer:show()

    avaletUI.iconUnderAttack = Geyser.Label:new({
    	name = "avaletUI.iconUnderAttack",
    	x=0, y=0, width=iconWidthHeight,	height=iconWidthHeight,
    }, avaletUI.underAttack)
    
    if avalet.fight.getKampf() == false then
      avaletUI.iconUnderAttack:setStyleSheet(avaletUI.CSS.IconsCSS:getCSS()..[[;border-image: url("]]..imgFightNone..[[");]])
    else
      avaletUI.iconUnderAttack:setStyleSheet(avaletUI.CSS.IconsCSS:getCSS()..[[;border-image: url("]]..imgFightUnderAttack..[[");]])
    end
    
    -- Icon für "Vergiftet/verflucht/erkrankt"
    avaletUI.iconDistress = Geyser.Label:new({
    	name = "avaletUI.iconDistress",
    	x=0, y=0, width=iconWidthHeight,	height=iconWidthHeight,
    }, avaletUI.distress)
    avaletUI.iconDistress:setToolTip("Krankheiten, Gifte, Flüche (funktioniert nicht immer)", "12")
    avaletUI.iconDistress:setDoubleClickCallback(function() avalet.char.setKrankheit(false);avalet.char.setFluch(false);avalet.char.setVergiftung(false) end)
    avaletUI.iconDistress:setStyleSheet("QToolTip{"..avaletUI.CSS.boxCSS:getCSS()..";color:white;}")
  
    if not avalet.distress then
      avaletUI.iconDistress:setStyleSheet("QLabel{"..avaletUI.CSS.IconsCSS:getCSS()..[[;border-image: url("]]..imgDistressNone..[[");}]])
    else
      avaletUI.iconDistress:setStyleSheet("QLabel{"..avaletUI.CSS.IconsCSS:getCSS()..[[;border-image: url("]]..imgDistressAvoidDeath..[[");}]])
    end
    
  elseif layout == LAYOUT["COMPACT"] or layout == LAYOUT["MULTIVIEW"] then -- Linke Spalte NICHT vorhanden
  
    --[[
    Die Label für die Icons in der BottomBar werden in der Funktion "avaletUI.initUI"
    erzeugt. Und zwar sind das:
    avaletUI.bottomBarUnderAttack
    avaletUI.bottomBarDistress ]]
  
    if avaletUI.iconContainer ~= nil then avaletUI.iconContainer:hide() end
    avaletUI.bottomBarUnderAttack:show()
    avaletUI.bottomBarDistress:show()
    
    local widthheight = (avaletUI.dimensions.defaultFontHeight * 2)
    
    avaletUI.iconBottomBarUnderAttack = Geyser.Label:new({
    	name = "avaletUI.iconBottomBarUnderAttack",
    	x=0, y=0, width=widthheight,	height=widthheight,
    }, avaletUI.bottomBarUnderAttack)
    
    if avalet.fight.getKampf() == false then
      avaletUI.iconBottomBarUnderAttack:setStyleSheet(avaletUI.CSS.IconsCSS:getCSS()..[[;border-image: url("]]..imgFightNone..[[");]])
    else
      avaletUI.iconBottomBarUnderAttack:setStyleSheet(avaletUI.CSS.IconsCSS:getCSS()..[[;border-image: url("]]..imgFightUnderAttack..[[");]])
    end

    -- Icon für "Vergiftet/verflucht/erkrankt"
    avaletUI.iconBottomBarDistress = Geyser.Label:new({
    	name = "avaletUI.iconBottomBarDistress",
    	x=0, y=0, width=widthheight,	height=widthheight,
    }, avaletUI.bottomBarDistress)
    avaletUI.iconBottomBarDistress:setToolTip("Krankheiten, Gifte, Flüche (funktioniert nicht immer)", "12")
    avaletUI.iconBottomBarDistress:setDoubleClickCallback(function() avalet.char.setKrankheit(false);avalet.char.setFluch(false);avalet.char.setVergiftung(false) end)
    avaletUI.iconBottomBarDistress:setStyleSheet("QToolTip{"..avaletUI.CSS.boxCSS:getCSS()..";color:white;}")
  
    if not avalet.distress then
      avaletUI.iconBottomBarDistress:setStyleSheet("QLabel{"..avaletUI.CSS.IconsCSS:getCSS()..[[;border-image: url("]]..imgDistressNone..[[");}]])
    else
      avaletUI.iconBottomBarDistress:setStyleSheet("QLabel{"..avaletUI.CSS.IconsCSS:getCSS()..[[;border-image: url("]]..imgDistressAvoidDeath..[[");}]])
    end
  else  
    -- NONE-Layout behandeln: alles ausblenden
  end
end
registerAnonymousEventHandler("UnderAttackChange", "avaletUI.buildIconsUI")
registerAnonymousEventHandler("DistressModelChange", "avaletUI.buildIconsUI")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildHDAUI</name>
				<packageName></packageName>
				<script>--[[
Hunger-Durst-Alk-Anzeige
In den folgenden zwei Funktionen wird die Anzeige für HDA erzeugt.
Und zwar einmal für die linke Spalte und einmal für die alternative
Anzeige unter der Hauptconsole.
Diese beiden Bereiche sind natürlich im Wesentlichen identisch. Ab-
gesehen von der Tatsache, dass ein Element vertikal und ein Element
horizontal ausgerichtet ist. Folglich ist es auch möglich, die An-
zeige in einer Funktion zu regeln. Man muss halt nur mit den Variablen
für x und y und width und height und so rumjonglieren.
Ich habs versucht, und der Code ist dadurch im Grunde unwartbar ge-
worden. Deshalb gibts jetzt zwei Funktionen.]]
function avaletUI.buildHDAUI()
  avalet.log("Function avaletUI.buildHDAUI()", 1)
  
  local LAYOUT = avalet.CONSTS.LAYOUT
  local layout = avaletUI.dimensions.layout


  avaletUI.buildLeftSideHDAUI()
  avaletUI.buildBottomBarHDAUI()
    
  if layout == LAYOUT["FULL"] or layout == LAYOUT["REDUCED"] then -- Linke Spalte vorhanden
    avaletUI.hdaLabel:show()
    avaletUI.bottomBarHDA:hide()
  elseif layout == LAYOUT["COMPACT"] or layout == LAYOUT["MULTIVIEW"] then -- Linke Spalte NICHT vorhanden
    avaletUI.hdaLabel:hide()
    avaletUI.bottomBarHDA:show()
  else  
    -- NONE-Layout behandeln (TODO)
    avaletUI.hdaLabel:hide()
    avaletUI.bottomBarHDA:hide()
  end
  
end



function avaletUI.buildLeftSideHDAUI()
  avalet.log("Function avaletUI.buildLeftSideHDAUI()", 1)

  local iconWidthHeight = avaletUI.dimensions.defaultFontWidth * 3.5
  
  avaletUI.hdaLabel = Geyser.Label:new({
      name="avaletUI.hdaLabel", 
      x="84%", y="38%", 
      height="60%", width=iconWidthHeight, 
      color="black"
  }, avaletUI.timerContainer)


  avaletUI.HDALabelHunger = Geyser.Label:new({
  	name = "avaletUI.HDALabelHunger",
  	x="0%", y="0%", width="33%", height="14%",
    color="black",
    fgcolor="white",
    message="&lt;center&gt;&lt;b&gt;H&lt;/b&gt;&lt;/center&gt;",
  }, avaletUI.hdaLabel)
  
  avaletUI.HDALabelDurst = Geyser.Label:new({
  	name = "avaletUI.HDALabelDurst",
  	x="33%", y="0%", width="33%", height="14%",
    color="black",
    fgcolor="white",
    message="&lt;center&gt;&lt;b&gt;D&lt;/b&gt;&lt;/center&gt;",
  }, avaletUI.hdaLabel)
  
  avaletUI.HDALabelAlkohol = Geyser.Label:new({
  	name = "avaletUI.HDALabelAlkohol",
  	x="66%", y="0%", width="33%", height="14%",
    color="black",
    fgcolor="white",
    message="&lt;center&gt;&lt;b&gt;A&lt;/b&gt;&lt;/center&gt;",
  }, avaletUI.hdaLabel)

  for k = 1, 6, 1 do

    --Hunger-Anzeige
    avaletUI["HDA_H"..k] = Geyser.Label:new({
    	name = "HDA_H"..k,
    	x="0%", y=(k*14+1).."%", width="33%", height="14%",
    }, avaletUI.hdaLabel)--, avaletUI.Left)
    if avalet.hda.hungerIndex &lt;= 1 then
      avaletUI.CSS.HDACSS:set("background-color", "rgb(0,0,0)")
    elseif avalet.hda.hungerIndex &gt; k then
      if avalet.hda.hungerIndex &lt;=2 then
        avaletUI.CSS.HDACSS:set("background-color", "rgb(0,255,0)")
      elseif avalet.hda.hungerIndex &lt;= 4 then
        avaletUI.CSS.HDACSS:set("background-color", "rgb(255,255,0)")
      else
        avaletUI.CSS.HDACSS:set("background-color", "rgb(255,0,0)")
      end
    else   
      avaletUI.CSS.HDACSS:set("background-color", "rgb(0,0,0)")
    end
    avaletUI.CSS.HDACSS:set("border-color", "rgb(255,255,255)")
    avaletUI["HDA_H"..k]:setToolTip("Hunger: "..avalet.char.getHunger().."\nDurst:    "..avalet.char.getDurst().."\nAlkohol: "..avalet.char.getAlk(), "12")
    avaletUI["HDA_H"..k]:setStyleSheet("QLabel{"..avaletUI.CSS.HDACSS:getCSS().."}QToolTip{"..avaletUI.CSS.boxCSS:getCSS()..";color:white;}")

    --Durst-Anzeige    
    avaletUI["HDA_D"..k] = Geyser.Label:new({
    	name = "HDA_D"..k,
    	x="33%", y=(k*14+1).."%", width="33%", height="14%",
    }, avaletUI.hdaLabel)
    if avalet.hda.durstIndex &lt;= 1 then
      avaletUI.CSS.HDACSS:set("background-color", "rgb(0,0,0)")
    elseif avalet.hda.durstIndex &gt; k then
      if avalet.hda.durstIndex &lt;=2 then
        avaletUI.CSS.HDACSS:set("background-color", "rgb(0,255,0)")
      elseif avalet.hda.durstIndex &lt;= 4 then
        avaletUI.CSS.HDACSS:set("background-color", "rgb(255,255,0)")
      else
        avaletUI.CSS.HDACSS:set("background-color", "rgb(255,0,0)")
      end
    else   
      avaletUI.CSS.HDACSS:set("background-color", "rgb(0,0,0)")
    end
    avaletUI.CSS.HDACSS:set("border-color", "rgb(255,255,255)")
    avaletUI["HDA_D"..k]:setToolTip("Hunger: "..avalet.char.getHunger().."\nDurst:    "..avalet.char.getDurst().."\nAlkohol: "..avalet.char.getAlk(), "12")
    avaletUI["HDA_D"..k]:setStyleSheet("QLabel{"..avaletUI.CSS.HDACSS:getCSS().."} QToolTip{"..avaletUI.CSS.boxCSS:getCSS()..";color:white;}")
    
    -- Alkohol-Anzeige:
    avaletUI["HDA_A"..k] = Geyser.Label:new({
    	name = "HDA_A"..k,
    	x="66%", y=(k*14+1).."%", width="33%", height="14%",
    }, avaletUI.hdaLabel)--, avaletUI.Left)
    if (avalet.hda.alkIndex-1) &lt;= 1 then
      avaletUI.CSS.HDACSS:set("background-color", "rgb(0,0,0)")
    elseif (avalet.hda.alkIndex-1) &gt; k then
      if (avalet.hda.alkIndex-1) &gt;=5 then
        avaletUI.CSS.HDACSS:set("background-color", "rgb(255,0,0)")
      elseif (avalet.hda.alkIndex-1) &gt;= 2 then
        avaletUI.CSS.HDACSS:set("background-color", "rgb(255,255,0)")
      else
        avaletUI.CSS.HDACSS:set("background-color", "rgb(0,0,0)")
      end
    else   
      avaletUI.CSS.HDACSS:set("background-color", "rgb(0,0,0)")
    end
    avaletUI["HDA_A"..k]:setToolTip("Hunger: "..avalet.char.getHunger().."\nDurst:    "..avalet.char.getDurst().."\nAlkohol: "..avalet.char.getAlk(), "12")
    if avalet.char.getHangover() then
      avaletUI.CSS.HDACSS:set("border-color", "rgb(255,0,255)")
    else
      avaletUI.CSS.HDACSS:set("border-color", "rgb(255,255,255)")
    end
    avaletUI["HDA_A"..k]:setStyleSheet("QLabel{"..avaletUI.CSS.HDACSS:getCSS().."}QToolTip{"..avaletUI.CSS.boxCSS:getCSS()..";color:white;}")

  end

end --function avaletUI.buildLeftSideHDAUI()

--[[
Dokumentation siehe über der vorherigen Funktion.
Dies hier ist das horizontale Element, das unterhalb
der Hauptkonsole angezeigt wird. Hier wurde die
Reihenfolge vertauscht, so dass H(unger) unten steht
und A(lkohol) oben.
]]
function avaletUI.buildBottomBarHDAUI()
  avalet.log("Function avaletUI.buildBottomBarHDAUI()", 1)
  
  local widthBottomIcons = avaletUI.dimensions.heightBottomBar
  local widthScrollBar = avaletUI.dimensions.widthScrollBar
  local widthMainConsole = avaletUI.dimensions.widthMainConsole
  local widthBottomBar = widthMainConsole - widthScrollBar
  local widthBottomVitals = widthBottomBar * 0.45
  local widthBottomTimerContainer = avaletUI.dimensions.widthLeftColumn
  local widthBottomHDA = widthBottomBar - widthBottomVitals - (widthBottomIcons * 2) - widthBottomTimerContainer


  avaletUI.bottomBarHDA = Geyser.Label:new({
      name="avaletUI.bottomBarHDA", 
      x=widthBottomVitals+(widthBottomIcons*2), y=0, 
      height="100%", width=widthBottomHDA, 
      color="black"
  }, avaletUI.bottomBarContainer)


  avaletUI.ABHDALabelHunger = Geyser.Label:new({
  	name = "avaletUI.ABHDALabelHunger",
  	x="0%", y="0%", width="10%", height="32%",
    color="black",
    fgcolor="white",
    message="&lt;b&gt;H&lt;/b&gt;",
  }, avaletUI.bottomBarHDA)
  avaletUI.ABHDALabelHunger:setFontSize(getFontSize()-4)
  
  avaletUI.ABHDALabelDurst = Geyser.Label:new({
  	name = "avaletUI.ABHDALabelDurst",
  	x="0%", y="34%", width="10%", height="32%",
    color="black",
    fgcolor="white",
    message="&lt;b&gt;D&lt;/b&gt;",
  }, avaletUI.bottomBarHDA)
  avaletUI.ABHDALabelDurst:setFontSize(getFontSize()-4)
  
  avaletUI.ABHDALabelAlkohol = Geyser.Label:new({
  	name = "avaletUI.ABHDALabelAlkohol",
  	x="0%", y="68%", width="10%", height="32%",
    color="black",
    fgcolor="white",
    message="&lt;b&gt;A&lt;/b&gt;",
  }, avaletUI.bottomBarHDA)
  avaletUI.ABHDALabelAlkohol:setFontSize(getFontSize()-4)

  for k = 1, 6, 1 do

    --Hunger-Anzeige
    avaletUI["ABHDA_H"..k] = Geyser.Label:new({
    	name = "ABHDA_H"..k,
    	x=(10+(k-1)*15).."%", y="0%", width="15%", height="32%",
    }, avaletUI.bottomBarHDA)--, avaletUI.Left)
    if avalet.hda.hungerIndex &lt;= 1 then
      avaletUI.CSS.HDACSS:set("background-color", "rgb(0,0,0)")
    elseif avalet.hda.hungerIndex &gt; k then
      if avalet.hda.hungerIndex &lt;=2 then
        avaletUI.CSS.HDACSS:set("background-color", "rgb(0,255,0)")
      elseif avalet.hda.hungerIndex &lt;= 4 then
        avaletUI.CSS.HDACSS:set("background-color", "rgb(255,255,0)")
      else
        avaletUI.CSS.HDACSS:set("background-color", "rgb(255,0,0)")
      end
    else   
      avaletUI.CSS.HDACSS:set("background-color", "rgb(0,0,0)")
    end
    avaletUI.CSS.HDACSS:set("border-color", "rgb(255,255,255)")
    avaletUI["ABHDA_H"..k]:setToolTip("Hunger: "..avalet.char.getHunger().."\nDurst:    "..avalet.char.getDurst().."\nAlkohol: "..avalet.char.getAlk(), "12")
    avaletUI["ABHDA_H"..k]:setStyleSheet("QLabel{"..avaletUI.CSS.HDACSS:getCSS().."}QToolTip{"..avaletUI.CSS.boxCSS:getCSS()..";color:white;}")

    --Durst-Anzeige    
    avaletUI["ABHDA_D"..k] = Geyser.Label:new({
    	name = "ABHDA_D"..k,
    	x=(10+(k-1)*15).."%", y="34%", width="15%", height="32%",
    }, avaletUI.bottomBarHDA)
    if avalet.hda.durstIndex &lt;= 1 then
      avaletUI.CSS.HDACSS:set("background-color", "rgb(0,0,0)")
    elseif avalet.hda.durstIndex &gt; k then
      if avalet.hda.durstIndex &lt;=2 then
        avaletUI.CSS.HDACSS:set("background-color", "rgb(0,255,0)")
      elseif avalet.hda.durstIndex &lt;= 4 then
        avaletUI.CSS.HDACSS:set("background-color", "rgb(255,255,0)")
      else
        avaletUI.CSS.HDACSS:set("background-color", "rgb(255,0,0)")
      end
    else   
      avaletUI.CSS.HDACSS:set("background-color", "rgb(0,0,0)")
    end
    avaletUI.CSS.HDACSS:set("border-color", "rgb(255,255,255)")
    avaletUI["ABHDA_D"..k]:setToolTip("Hunger: "..avalet.char.getHunger().."\nDurst:    "..avalet.char.getDurst().."\nAlkohol: "..avalet.char.getAlk(), "12")
    avaletUI["ABHDA_D"..k]:setStyleSheet("QLabel{"..avaletUI.CSS.HDACSS:getCSS().."} QToolTip{"..avaletUI.CSS.boxCSS:getCSS()..";color:white;}")
    
    -- Alkohol-Anzeige:
    avaletUI["ABHDA_A"..k] = Geyser.Label:new({
    	name = "ABHDA_A"..k,
    	x=(10+(k-1)*15).."%", y="68%", width="15%", height="32%",
    }, avaletUI.bottomBarHDA)--, avaletUI.Left)
    if (avalet.hda.alkIndex-1) &lt;= 1 then
      avaletUI.CSS.HDACSS:set("background-color", "rgb(0,0,0)")
    elseif (avalet.hda.alkIndex-1) &gt; k then
      if (avalet.hda.alkIndex-1) &gt;=5 then
        avaletUI.CSS.HDACSS:set("background-color", "rgb(255,0,0)")
      elseif (avalet.hda.alkIndex-1) &gt;= 2 then
        avaletUI.CSS.HDACSS:set("background-color", "rgb(255,255,0)")
      else
        avaletUI.CSS.HDACSS:set("background-color", "rgb(0,0,0)")
      end
    else   
      avaletUI.CSS.HDACSS:set("background-color", "rgb(0,0,0)")
    end
    avaletUI["HDA_A"..k]:setToolTip("Hunger: "..avalet.char.getHunger().."\nDurst:    "..avalet.char.getDurst().."\nAlkohol: "..avalet.char.getAlk(), "12")
    if avalet.char.getHangover() then
      avaletUI.CSS.HDACSS:set("border-color", "rgb(255,0,255)")
    else
      avaletUI.CSS.HDACSS:set("border-color", "rgb(255,255,255)")
    end
    avaletUI["ABHDA_A"..k]:setStyleSheet("QLabel{"..avaletUI.CSS.HDACSS:getCSS().."}QToolTip{"..avaletUI.CSS.boxCSS:getCSS()..";color:white;}")

  end

end --function avaletUI.buildBottomBarHDAUI()</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildVitalsUI</name>
				<packageName></packageName>
				<script>function avaletUI.refreshTickTimer()
  avalet.log("Function avaletUI.refreshTickTimer()", 1)

-- die letzten 8 sekunden eine andere Farbe (reicht zum magiertrance zaubern) TODO

end
registerAnonymousEventHandler("TickTimerModelChange", "avaletUI.refreshTickTimer")



function avaletUI.refreshVitalsView(event, arg)
  avalet.log("Function avaletUI.refreshVitalsView", 1)

  local vital = arg
  
  local v = {}
  
  v = avalet.vitals[vital]
  
  -- Wenn es noch nichts zum anzeigen gibt, muss auch nichts angezeigt werden
  if v["maxValue"] == 0 then return end
  
  -- maxValue darf nicht 0 sein, sonst gibts Probleme bei der Anzeige (ist immer beim Neustart 0)
  --v["maxValue"] = math.max(v["maxValue"],1)

  local LAYOUT = avalet.CONSTS.LAYOUT
  local layout = avaletUI.dimensions.layout

  if layout == LAYOUT["FULL"] or layout == LAYOUT["REDUCED"] then -- Linke Spalte vorhanden
    if vital == "health" then
      avaletUI.Health:setValue(tonumber(v["valueToDisplay"]), tonumber(v["maxValue"]), "&lt;b&gt;&lt;center&gt;"..tostring(v["currentValue"]).."/".. tostring(v["maxValue"]).."&lt;/center&gt;&lt;/br&gt;&lt;center&gt;TP&lt;/center&gt;&lt;/br&gt;&lt;center&gt;("..v["percent"].."%)&lt;/center&gt;&lt;/b&gt;")
    elseif vital == "endurance" then
  	  avaletUI.Endurance:setValue(tonumber(v["valueToDisplay"]), tonumber(v["maxValue"]), "&lt;b&gt;&lt;center&gt;"..tostring(v["currentValue"]).."/".. tostring(v["maxValue"]).."&lt;/center&gt;&lt;/br&gt;&lt;center&gt;AP&lt;/center&gt;&lt;/br&gt;&lt;center&gt;("..v["percent"].."%)&lt;/center&gt;&lt;/b&gt;")
    elseif vital == "spellpoints" then
    	avaletUI.Spellpoints:setValue(tonumber(v["valueToDisplay"]), tonumber(v["maxValue"]), "&lt;b&gt;&lt;center&gt;"..tostring(v["currentValue"]).."/".. tostring(v["maxValue"]).."&lt;/center&gt;&lt;/br&gt;&lt;center&gt;ZP&lt;/center&gt;&lt;/br&gt;&lt;center&gt;("..v["percent"].."%)&lt;/center&gt;&lt;/b&gt;")
    elseif vital == "mana" then
   	  avaletUI.Mana:setValue(tonumber(v["valueToDisplay"]), tonumber(v["maxValue"]), "&lt;b&gt;&lt;center&gt;"..tostring(v["currentValue"]).."/".. tostring(v["maxValue"]).." Mana ("..v["percent"].."%)&lt;/center&gt;&lt;/b&gt;")
    end
  elseif layout == LAYOUT["COMPACT"] or layout == LAYOUT["MULTIVIEW"] then -- Linke Spalte NICHT vorhanden
    if vital == "health" then
      avaletUI.ABHealth:setValue(tonumber(v["valueToDisplay"]), tonumber(v["maxValue"]), "&lt;b&gt;&lt;center&gt;"..tostring(v["currentValue"]).."/".. tostring(v["maxValue"]).." TP ("..v["percent"].."%)&lt;/center&gt;&lt;/b&gt;")
   elseif vital == "endurance" then
  	  avaletUI.ABEndurance:setValue(tonumber(v["valueToDisplay"]), tonumber(v["maxValue"]), "&lt;b&gt;&lt;center&gt;"..tostring(v["currentValue"]).."/".. tostring(v["maxValue"]).." AP ("..v["percent"].."%)&lt;/center&gt;&lt;/b&gt;")
    elseif vital == "spellpoints" then
    	avaletUI.ABSpellpoints:setValue(tonumber(v["valueToDisplay"]), tonumber(v["maxValue"]), "&lt;b&gt;&lt;center&gt;"..tostring(v["currentValue"]).."/".. tostring(v["maxValue"]).." ZP ("..v["percent"].."%)&lt;/center&gt;&lt;/b&gt;")
    elseif vital == "mana" then
    	avaletUI.ABMana:setValue(tonumber(v["valueToDisplay"]), tonumber(v["maxValue"]), "&lt;b&gt;&lt;center&gt;"..tostring(v["currentValue"]).."/".. tostring(v["maxValue"]).." Mana ("..v["percent"].."%)&lt;/center&gt;&lt;/b&gt;")
    end
  end

end
registerAnonymousEventHandler("VitalsModelChange", "avaletUI.refreshVitalsView")


function avaletUI.buildVitalsUI()

  local LAYOUT = avalet.CONSTS.LAYOUT
  local layout = avaletUI.dimensions.layout
  
  avaletUI.buildLeftColumnVitalsUI()
  avaletUI.buildBottomBarVitalsUI()
    
  if layout == LAYOUT["FULL"] or layout == LAYOUT["REDUCED"] then -- Linke Spalte vorhanden
    avaletUI.vitalsContainer:show()
    avaletUI.bottomBarVitals:hide()
  elseif layout == LAYOUT["COMPACT"] or layout == LAYOUT["MULTIVIEW"] then -- Linke Spalte NICHT vorhanden
    avaletUI.vitalsContainer:hide()
    avaletUI.bottomBarVitals:show()
  else  
    -- NONE-Layout behandeln
    avaletUI.vitalsContainer:hide()
    avaletUI.bottomBarVitals:hide()
  end
  
  avalet.vitals.updateAllVitals()

end


--[[
Gauges für Tick, TP, AP, ZP und Mana ]]  
function avaletUI.buildLeftColumnVitalsUI()
  avalet.log("Function avaletUI.buildVitalsUI()", 1)

  avaletUI.Tick = Geyser.Gauge:new({
    name = "avaletUI.Tick",
    x = "2%", y = "2%", 
    width="97%", height="3%",
  }, avaletUI.vitalsContainer)
  avaletUI.CSS.GaugeBackCSS:set("background-color", "black")
  avaletUI.Tick.back:setStyleSheet(avaletUI.CSS.GaugeBackCSS:getCSS())
  avaletUI.CSS.GaugeBackCSS:set("background-color", "black")
  avaletUI.CSS.GaugeFrontCSS:set("background-color", "green")
  avaletUI.Tick.front:setStyleSheet(avaletUI.CSS.GaugeFrontCSS:getCSS())
  avaletUI.Tick:setValue(40,40, [[]])
  avaletUI.Tick.text:setToolTip("Tick-Timer (experimentell)", "10")


  avaletUI.Health = Geyser.Gauge:new({
    name = "avaletUI.Health",
    x = "2%", y = "7%",
    width="31%", height="70%",
    orientation="vertical",
  }, avaletUI.vitalsContainer)
  avaletUI.Health.back:setStyleSheet(avaletUI.CSS.GaugeBackCSS:getCSS())
  avaletUI.CSS.GaugeFrontCSS:set("background-color", "darkred")
  avaletUI.Health.front:setStyleSheet(avaletUI.CSS.GaugeFrontCSS:getCSS())
  avaletUI.Health.text:setStyleSheet(avaletUI.CSS.GaugeTextCSS:getCSS())
  avaletUI.Health:setValue(100,100,[[&lt;b&gt;&lt;center&gt;TP&lt;/center&gt;&lt;/b&gt;]])

  
  avaletUI.Endurance = Geyser.Gauge:new({
    name = "avaletUI.Endurance",
    x = "35%", y = "7%",
    width="31%", height="70%",
    orientation="vertical",
  }, avaletUI.vitalsContainer)
  avaletUI.Endurance.back:setStyleSheet(avaletUI.CSS.GaugeBackCSS:getCSS())
  avaletUI.CSS.GaugeFrontCSS:set("background-color", "#a35a00")
  avaletUI.Endurance.front:setStyleSheet(avaletUI.CSS.GaugeFrontCSS:getCSS())
  avaletUI.Endurance.text:setStyleSheet(avaletUI.CSS.GaugeTextCSS:getCSS())
  avaletUI.Endurance:setValue(100,100,[[&lt;b&gt;&lt;center&gt;AP&lt;/center&gt;&lt;/b&gt;]])
  
  
  avaletUI.Spellpoints = Geyser.Gauge:new({
    name = "avaletUI.Spellpoints",
    x = "68%", y = "7%",
    width="31%", height="70%",
    orientation="vertical",
  }, avaletUI.vitalsContainer)--BoxVitals)
  avaletUI.Spellpoints.back:setStyleSheet(avaletUI.CSS.GaugeBackCSS:getCSS())
  avaletUI.CSS.GaugeFrontCSS:set("background-color", "darkblue")
  avaletUI.Spellpoints.front:setStyleSheet(avaletUI.CSS.GaugeFrontCSS:getCSS())
  avaletUI.Spellpoints.text:setStyleSheet(avaletUI.CSS.GaugeTextCSS:getCSS())
--  avaletUI.Spellpoints:setValue(100,100, [[&lt;b&gt;&lt;center&gt;999/999&lt;br&gt;ZP&lt;br&gt;(100%)&lt;/center&gt;&lt;/b&gt;]])
  avaletUI.Spellpoints:setValue(100,100, [[&lt;b&gt;&lt;center&gt;ZP&lt;/center&gt;&lt;/b&gt;]])

  
  avaletUI.Mana = Geyser.Gauge:new({
    name = "avaletUI.Mana",
    x = "2%", y = "79%",
    width="97%", height="20%",
  }, avaletUI.vitalsContainer)--BoxVitals)
  avaletUI.Mana.back:setStyleSheet(avaletUI.CSS.GaugeBackCSS:getCSS())
  avaletUI.CSS.GaugeFrontCSS:set("background-color", "#4b0082")
  avaletUI.Mana.front:setStyleSheet(avaletUI.CSS.GaugeFrontCSS:getCSS())
--  avaletUI.Mana:setValue(9999,9999, [[&lt;b&gt;&lt;center&gt;9999/9999 Mana (100%)&lt;/center&gt;&lt;/b&gt;]])
  avaletUI.Mana:setValue(9999,9999, [[&lt;b&gt;&lt;center&gt;Mana&lt;/center&gt;&lt;/b&gt;]])

end --function avaletUI.buildVitalsUI()


function avaletUI.buildBottomBarVitalsUI()
  avalet.log("Function avaletUI.buildBottomBarVitalsUI()", 1)

  local widthMainConsole = avaletUI.dimensions.widthMainConsole
  local defaultFontWidth = avaletUI.dimensions.defaultFontWidth
  local widthScrollBar = defaultFontWidth * 2
  local widthBottomBar = widthMainConsole - widthScrollBar
  local widthBottomVitals = widthBottomBar * 0.45
  local widthBottomVitalsTPandZP = math.floor(widthBottomVitals / 3)
  local widthBottomVitalsAP = (widthBottomVitals - (2 * widthBottomVitalsTPandZP))

  --[[
  Die "BottomBar" hieß mal "ActionBar", daher das "AB"... ]]
  
  avaletUI.ABTick = Geyser.Gauge:new({
    name = "avaletUI.ABTick",
    x = 0, y = 0,
    width="100%", height="100%",
    orientation="horizontal",
  }, avaletUI.bottomBarTickContainer)--avaletUI.BottomBarVitals)
  avaletUI.CSS.GaugeBackCSS:set("background-color", "black")--white
  avaletUI.ABTick.back:setStyleSheet(avaletUI.CSS.GaugeBackCSS:getCSS())
  --avaletUI.CSS.GaugeBackCSS:set("background-color", "black")
  --avaletUI.CSS.GaugeFrontCSS:set("background-color", "#4b0082")
  avaletUI.CSS.GaugeFrontCSS:set("background-color", "green")
  avaletUI.ABTick.front:setStyleSheet(avaletUI.CSS.GaugeFrontCSS:getCSS())
  avaletUI.ABTick:setValue(40,40, [[]])
  avaletUI.ABTick.text:setToolTip("Tick-Timer (experimentell)", "10")

  avaletUI.CSS.GaugeBackCSS:set("background-color", "black")

  avaletUI.ABHealth = Geyser.Gauge:new({
    name = "avaletUI.ABHealth",
    x = 0, y = 0,
    width=widthBottomVitalsTPandZP, height="50%",
    orientation="horizontal",
  }, avaletUI.bottomBarVitals)
  avaletUI.ABHealth.back:setStyleSheet(avaletUI.CSS.BottomBarGaugeBackCSS:getCSS())
  avaletUI.CSS.BottomBarGaugeFrontCSS:set("background-color", "darkred")
  avaletUI.ABHealth.front:setStyleSheet(avaletUI.CSS.BottomBarGaugeFrontCSS:getCSS())
  avaletUI.ABHealth.text:setStyleSheet(avaletUI.CSS.GaugeTextCSS:getCSS())
  avaletUI.ABHealth:setValue(100,100,[[&lt;b&gt;&lt;center&gt;TP&lt;/center&gt;&lt;/b&gt;]])

  
  avaletUI.ABEndurance = Geyser.Gauge:new({
    name = "avaletUI.ABEndurance",
    x = widthBottomVitalsTPandZP, y = 0,
    width=widthBottomVitalsAP, height="50%",
    orientation="horizontal",
  }, avaletUI.bottomBarVitals)
  avaletUI.ABEndurance.back:setStyleSheet(avaletUI.CSS.BottomBarGaugeBackCSS:getCSS())
  avaletUI.CSS.BottomBarGaugeFrontCSS:set("background-color", "#a35a00")
  avaletUI.ABEndurance.front:setStyleSheet(avaletUI.CSS.BottomBarGaugeFrontCSS:getCSS())
  avaletUI.ABEndurance.text:setStyleSheet(avaletUI.CSS.GaugeTextCSS:getCSS())
  avaletUI.ABEndurance:setValue(100,100,[[&lt;b&gt;&lt;center&gt;AP&lt;/center&gt;&lt;/b&gt;]])
  
  
  avaletUI.ABSpellpoints = Geyser.Gauge:new({
    name = "avaletUI.ABSpellpoints",
    x = (widthBottomVitalsTPandZP + widthBottomVitalsAP), y = 0,
    width=widthBottomVitalsTPandZP, height="50%",
    orientation="horizontal",
  }, avaletUI.bottomBarVitals)
  avaletUI.ABSpellpoints.back:setStyleSheet(avaletUI.CSS.BottomBarGaugeBackCSS:getCSS())
  avaletUI.CSS.BottomBarGaugeFrontCSS:set("background-color", "darkblue")
  avaletUI.ABSpellpoints.front:setStyleSheet(avaletUI.CSS.BottomBarGaugeFrontCSS:getCSS())
  avaletUI.ABSpellpoints.text:setStyleSheet(avaletUI.CSS.GaugeTextCSS:getCSS())
  avaletUI.ABSpellpoints:setValue(100,100, [[&lt;b&gt;&lt;center&gt;ZP&lt;/center&gt;&lt;/b&gt;]])

  
  avaletUI.ABMana = Geyser.Gauge:new({
    name = "avaletUI.ABMana",
    x = 0, y = "50%",
    width=widthBottomVitals, height="50%",
    orientation="horizontal",
  }, avaletUI.bottomBarVitals)
  avaletUI.ABMana.back:setStyleSheet(avaletUI.CSS.BottomBarGaugeBackCSS:getCSS())
  avaletUI.CSS.BottomBarGaugeFrontCSS:set("background-color", "#4b0082")
  avaletUI.ABMana.front:setStyleSheet(avaletUI.CSS.BottomBarGaugeFrontCSS:getCSS())
  avaletUI.ABMana:setValue(9999,9999, [[&lt;b&gt;&lt;center&gt;Mana&lt;/center&gt;&lt;/b&gt;]])

end --function avaletUI.buildBottomBarVitalsUI()</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildInfoBoxUI</name>
				<packageName></packageName>
				<script>--[[
Der Charakter-Info-Bereich in der rechten Spalte oben besteht aus
einer Minikonsole, in die verschiedener Text ausgegeben wird. Die
Charakter-Informationen sind dabei eigentlich nur ein Platzhalter,
damit der Bereich beim Start von Avalet (und zwischendurch) nicht
so leer ist. Andererseits sind die Char-Infos eigentlich auch ganz
nett. Und die Statistik-Infos darunter sind eh praktisch.

Es gibt außerdem noch eine alternative Anzeige, und zwar ist das
die "Gilden-Information". Dort wird (derzeit nur) die Ausrüstung
der Runenschmiede angezeigt, wenn die "ruebersicht" eingeben.
Technisch sind das zwei verschiedene Flächen, die jeweils ein- bzw.
ausgeblendet werden.

Die Idee ist, einen Bereich zu haben, in dem Informationen länger
angezeigt werden und in Ruhe betrachtet werden können. Auch wenn
es mal sehr scrollt. Beispielsweise Spielstand oder Inventar oder
Gruppeninformationen. 

Der Bereich ist so gestaltet, dass er nach wenigen Sekunden wieder
auf die Default-Ansicht, also auf die Charakter-Informationen geht.
Der Grund dafür ist, dass die anderen Informationen alle altern.
Und teilweise auch recht schnell. Also sowohl das Inventar als auch
der Spielstand als auch der Zustand der Runi-Ausrüstung verändert
sich ja laufend. Avalon gibt mir aber nicht die Möglichkeit, diese
Veränderungen nachzuvollziehen. (Naja, im Falle des Inventars ginge
das, aber ... wozu der Aufwand.) So dass die Anzeige zwangsläufig
irgendwann fehlerhaft wäre. Weil veraltet. Lediglich die Default-
Ansicht, also die Charakter-Informationen, können aktuell gehalten
werden. Und die statistischen Informationen natürlich auch. Das ist
ja deren Sinn.

Über diesen Bereich gab es immer mal wieder genörgel. Aber ich bin
davon überzeugt, dass der genau so richtig ist. ]]


--avaletUI.infoBoxVisibility = true


function avaletUI.buildInfoBoxUI()
  avalet.log("Function avaletUI.buildInfoBoxUI()", 1)

  avaletUI.infoBox = Geyser.Label:new({
      name="avaletUI.infoBox", 
      x=0, y=0, height="100%", width="100%", 
  }, avaletUI.infoBoxContainer)
  avaletUI.infoBox:setStyleSheet(avaletUI.CSS.boxCSS:getCSS())
  avaletUI.infoBox:setFontSize(getFontSize()-2)
  
  -- Dieses Element wird für die normale Ausgabe benutzt. Also für Ausgabe
  -- des Default-Textes und für die Anzeige von Spielstand, Inventar,
  -- Gruppen-Informationen und ähnlichem Generell ist es das richtige Element
  -- für alles, was direkt aus dem Hauptfenster übernommen wird. Oder für alles,
  -- was reiner Text ist. 
  avaletUI.infoScreen = Geyser.MiniConsole:new({
      name="avaletUI.infoScreen",
      x="2%", y="3%", width="96%", height="94%",
      autoWrap = false,--true,
      color = "black",
      scrollBar = false,
      fontSize = tonumber(getFontSize()-2),
  }, avaletUI.infoBox)
  avaletUI.infoScreen:setFont(getFont())
  --Testweise auskommentiert. TODO
  --setWindowWrap("avaletUI.infoScreen", 79)
  clearWindow("avaletUI.infoScreen")  
  
  raiseEvent("RefreshInfoBoxGUI")

end --function avaletUI.buildInfoBoxUI()


function avaletUI.updateInfoBoxView()
  avalet.log("Function avaletUI.updateInfoBoxView()", 1)
  
  clearWindow("avaletUI.infoScreen")
  showWindow("avaletUI.infoScreen")
  --if avaletUI.guildInfoContainer ~= nil then
  --  avaletUI.guildInfoContainer:hide()
  --end

  avaletUI.infoScreen:cecho(avalet.infoBox.default)
end
registerAnonymousEventHandler("InfoBoxModelChange", "avaletUI.updateInfoBoxView")
registerAnonymousEventHandler("RefreshInfoBoxGUI", "avaletUI.updateInfoBoxView")


--[[
Hier wird der Buffer, in den die gecapturte Map vom entsprechenden Trigger ge-
schrieben wurde, ausgelesen und in den entsprechenden GUI-Bereich geschrieben. 
Der Trigger hätte da auch gleich reinschreiben können, aber man muss glaubhaft
bleiben mit seinem MVC-Pattern! (Ist allerdings auch transparenter so.) ]]
function avaletUI.onInject()
  avalet.log("Function avaletUI.onInject()", 1)

  clearWindow("avaletUI.infoScreen")
  showWindow("avaletUI.infoScreen")
  
  --[[
  Um einen Buffer auszulesen wird der Cursor an den Anfang der ersten Zeile gesetzt,
  dann die Zeile selektiert, dann die Selektion kopiert und dann als "rich text", 
  also mit den Farbinformationen, in die Miniconsole geschrieben. Und das dann für
  jede Zeile im Buffer. Da hier der Index angesprochen wird, ist die erste Zeile
  die Nullte. Und die letzte Zeile wäre 'injectionBufferRows'-1. Da aber die letzte
  Zeile im Buffer die Abbruchbedingung enthält (also den Prompt oder den Kompass),
  wird hier die letzte Zeile nicht mehr ausgegeben. Deshalb 'injectionBufferRows'-2. ]]
  for i = 0, avalet.infoBox.injectionBufferRows-2, 1 do
    moveCursor("InjectionBuffer", 0, i )
    selectCurrentLine("InjectionBuffer")
    copy("InjectionBuffer")
    decho("avaletUI.infoScreen", copy2decho("InjectionBuffer").."\n")
  end
  clearWindow("InjectionBuffer")
  avalet.infoBox.injectionBufferRows = 0
end
registerAnonymousEventHandler("InjectionBufferChange", "avaletUI.onInject")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildGuildInfoUI</name>
				<packageName></packageName>
				<script>--[[
Für die Gilde der Runenschmiede gibt es eine Möglichkeit, sich die
Ausgabe des Befehls "ruebersicht" extra anzeigen zu lassen. Und zwar
dort, wo sonst die Charakterinformationen stehen bzw. wo Inventar
und Spielstand und so angezeigt werden. Also in der rechten Spalte
oben. Die dafür benötigten Daten kommen per ATCP, das Flag heißt
"AvalonGildenInfo". Grundsätzlich ist es natürlich möglich, dass
sich andere Gilden da anschließen. Deshalb gibt es in Avalet das
"GuildInfoUI". ]]
function avaletUI.buildGuildInfoUI()
  avalet.log("avaletUI.buildGuildInfoUI()", 1)

--[==[
  -- Hauptcontainer
  avaletUI.guildInfoContainer = Geyser.Container:new({
    name = "avaletUI.guildInfoContainer",
    x="3%", y="3%", width="94%", height="94%",
  }, avaletUI.InfoBox)
  avaletUI.guildInfoContainer:hide()
]==]
  --[[
  Eigentlich könnte hier nach Gilden-Zugehörigkeit entschieden werden,
  ob der Bereich überhaupt erzeugt wird oder nicht. Aber da ich kein
  Runenschmied bin, das Ganze aber ja testen muss, schalte ich das
  hier mal generell ein. ]]
  if (avalet.char.getGilde() == "Runenschmiede") then

    avaletUI.buildRuniGuildInfoUI()
  
  end

end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildRuniGuildInfo</name>
				<packageName></packageName>
				<script>function avaletUI.showRuniGuildInfo()
  avalet.log("avaletUI.showRuniGuildInfo()", 1)

  avaletUI.buildRuniGuildInfoUI()

  avaletUI.guildInfoContainer:show()
  --avaletUI.guildInfoContainer:show()
  --hideWindow("avaletUI.infoScreen")

end --avaletUI.buildRuniGuildInfoUI()
registerAnonymousEventHandler("RuniGuildInfoChange", "avaletUI.showRuniGuildInfo")



--[[
Hier wird die Box erzeugt, die für die Ausgabe von "ruebersicht" der
Runenschmiede vorgesehen ist. Sie wird nur für Runenschmiede erzeugt
und sofort unsichtbar gemacht. Wenn der Runenschmied "ruebersicht"
eingibt, sendet das MUD per ATCP die Antwort, die Box wird sichtbar
gemacht (und die normale InfoBox unsichtbar) und der Runi-Kram wird
angezeigt. Gibt der Spieler dann seinen nächsten Befehl ein, der zur
Ausgabe von irgendwas in der InfoBox führt, wird dieses Fenster wieder
unsichtbar gemacht, das normale InfoBox-Fenster sichtbar, und die Info
wird da angezeigt. ]]--[[
Ok, neuer Versuch... ]]
function avaletUI.buildRuniGuildInfoUI()
  avalet.log("avaletUI.buildRuniGuildInfoUI()", 1)

  --avaletUI.runiInfo = {}
  
  -- Es gab mal eine Fehlermeldung, weil das Model irgendwie nicht initialisiert
  -- war. Das hier ist ein Versuch, den Fehler zu beheben.
  if avalet.guildInfo.runiGuildInfoModel == nil then return end

  local imageFolderPath = getMudletHomeDir().."/Avalet/imgs/"
  
  local placeholder = imageFolderPath.."missingImage.png"
  
  local imageHead = imageFolderPath.."head-white.png"
  local imageBody = imageFolderPath.."body-white.png"
  local imageArms = imageFolderPath.."arms-white.png"
  local imageLegs = imageFolderPath.."legs-white.png"
  local imageWeapon = imageFolderPath.."weapon-white.png"
  local imageShield = imageFolderPath.."shield-white.png"
  
  local ITEM_TYPE_WEAPON = "Weapon"
  local ITEM_TYPE_SHIELD = "Shield"
  local ITEM_TYPE_HEAD = "Head"
  local ITEM_TYPE_BODY = "Body"
  local ITEM_TYPE_LEGS = "Legs"
  local ITEM_TYPE_ARMS = "Arms"
    
  local CHARGE_POSITIVE = "positiv"
  local CHARGE_NEGATIVE = "negativ"
  local CHARGE_NONE = "neutral"
  
  
  local LAYOUT = avalet.CONSTS.LAYOUT
  local layout = avaletUI.dimensions.layout

  local widthLeftColumn = avaletUI.dimensions.widthLeftColumn
  local widthMainConsole = avaletUI.dimensions.widthMainConsole
  local widthScrollBar = avaletUI.dimensions.widthScrollBar
  local defaultFontHeight = avaletUI.dimensions.defaultFontHeight
  local symbolWidth = math.floor((widthMainConsole-widthScrollBar) / 6)
  
  --[[
  Die Höhe der Anzeigefläche jedes Items ist abhängig von der Anzahl der Runen, die
  anzuzeigen sind. Plus 1, wegen dem Item-Namen. Aber nicht weniger als 5, sonst
  siehts komisch aus. ]]
  local symbolHeight = defaultFontHeight * math.max(tonumber(avalet.guildInfo.runiGuildInfoModel.maxNumbDispRunes)+1, 5)

  local mainContainerX = nil
  local mainContainerY = nil
  local mainContainerWidth = nil
  local mainContainerHeight = nil 
  
  local pos = {}
  
  if layout == LAYOUT["FULL"] or layout == LAYOUT["REDUCED"] then -- Linke Spalte vorhanden
  
    mainContainerX = widthLeftColumn
    mainContainerY = 0
    mainContainerWidth = widthMainConsole
    mainContainerHeight = symbolHeight
    
    pos = {
      [1] = {["xPos"] = symbolWidth * 0, ["yPos"] = 0},
      [2] = {["xPos"] = symbolWidth * 1, ["yPos"] = 0},
      [3] = {["xPos"] = symbolWidth * 2, ["yPos"] = 0},
      [4] = {["xPos"] = symbolWidth * 3, ["yPos"] = 0},
      [5] = {["xPos"] = symbolWidth * 4, ["yPos"] = 0},
      [6] = {["xPos"] = symbolWidth * 5, ["yPos"] = 0},
    }

  elseif layout == LAYOUT["COMPACT"] or layout == LAYOUT["MULTIVIEW"] then -- Linke Spalte NICHT vorhanden

    mainContainerX = 0
    mainContainerY = 0
    mainContainerWidth = widthMainConsole - (2 * widthLeftColumn) - widthScrollBar
    mainContainerHeight = symbolHeight * 2
    symbolWidth = math.floor(mainContainerWidth / 3)

    pos = {
      [1] = {["xPos"] = symbolWidth * 0, ["yPos"] = 0},
      [2] = {["xPos"] = symbolWidth * 1, ["yPos"] = 0},
      [3] = {["xPos"] = symbolWidth * 2, ["yPos"] = 0},
      [4] = {["xPos"] = symbolWidth * 0, ["yPos"] = symbolHeight},
      [5] = {["xPos"] = symbolWidth * 1, ["yPos"] = symbolHeight},
      [6] = {["xPos"] = symbolWidth * 2, ["yPos"] = symbolHeight},
    }

  else  
    -- NONE-Layout behandeln: alles ausblenden

  end  
  
  
  local chargeColor = ""
  if avalet.guildInfo.runiGuildInfoModel.HammerCharge == CHARGE_POSITIVE then
    chargeColor = "rgba(0,0,255,0.5)"             --"blue"
  elseif avalet.guildInfo.runiGuildInfoModel.HammerCharge == CHARGE_NEGATIVE then
    chargeColor = "rgba(255,0,0,0.5)"             --"red"
  end

  placeholder = placeholder:gsub("[\\/]", "/")
  
  imageHead = imageHead:gsub("[\\/]", "/")
  imageBody = imageBody:gsub("[\\/]", "/")
  imageArms = imageArms:gsub("[\\/]", "/")
  imageLegs = imageLegs:gsub("[\\/]", "/")
  imageWeapon = imageWeapon:gsub("[\\/]", "/")
  imageShield = imageShield:gsub("[\\/]", "/")
  
  if not (io.exists(placeholder)) then
    cecho("&lt;magenta&gt;Fehler in der RuniInfoBox: Platzhalterbild fehlt.\n")
  else
    if not (io.exists(imageHead)) then imageHead = placeholder end
    if not (io.exists(imageBody)) then imageBody  = placeholder end
    if not (io.exists(imageArms)) then imageArms  = placeholder end
    if not (io.exists(imageLegs)) then imageLegs  = placeholder end
    if not (io.exists(imageWeapon)) then imageWeapon  = placeholder end
    if not (io.exists(imageShield)) then imageShield  = placeholder end
  end

  --[[
  Die Funktion getItemSymbolLabel erzeugt ein Label, in dem ein Bild des Items liegt.
  Dieses Bild bildet dann den Hintergrund zu dem Text des Items. Derzeit ist das Bild
  nicht an das Item angepasst, sondern nur ein Symbol für Waffe, Schild, Helm, Körper-
  panzer, Handschuhe und Stiefel. Wenn in der Übersicht zwei Waffen auftauchen, dann
  wird die erste hier mit einem Waffensymbol hinterlegt sein, die Zweite mit einem
  Schild. ]]
  local function getItemSymbolLabel(itemType, image, posX, posY, parent)
  
    local symbol = nil

    symbol = Geyser.Label:new({
        name = "RuniInfobox_"..itemType.."Symbol",
        x=posX,y=posY,width=symbolWidth,height=symbolHeight,
      }, avaletUI.guildInfoContainer)
    
    symbol:setStyleSheet([[
          background-image: url("]]..image..[[");
          background-repeat: no-repeat;
          background-position: center;
          background-color: rgba(0,0,0,0);
    ]])
    
    return symbol
    
  end

  -- Die Funktion getItemTextLabel erzeugt ein Label, in dem der Text des Items steht. 
  local function getItemTextLabel(itemType, item, posX, posY, parent)

    local label = nil
    
    local iType = itemType--item.iType
    local iName = item.iName
    local iColor = item.iColor
    local iRunes = item.iRunes
    
    label = Geyser.Label:new({
      name = "RuniInfobox_"..iType.."Text",
      x=posX,y=posY,width=symbolWidth,height=symbolHeight,
    }, avaletUI.guildInfoContainer)
    label:setFont(getFont())
    label:setFontSize(getFontSize()-2)
    setBackgroundColor("RuniInfobox_"..iType.."Text", 0, 0, 0, 220) --210 zu viel, 240 fast nicht zu sehen
    label:setStyleSheet([[qproperty-alignment: 'AlignTop';padding-left: '5px'; margin: '0px';]])   --'AlignHCenter | AlignVCenter'

    local itemText = ""
    itemText = itemText..[[&lt;p&gt;&lt;div style="margin-bottom:4px"&gt;&lt;b&gt;&lt;font color="]]..iColor..[["&gt;]]..string.gsub(iName, "Paar (.*)", "%1")..[[&lt;/font&gt;&lt;/b&gt;&lt;/div&gt;]]
    itemText = itemText..[[&lt;div&gt;&lt;b&gt;&lt;table&gt;]]
    if iRunes ~= nil then
      for _, k in pairs(iRunes) do

        local fontColor = nil
        local fontRuneColor = nil
        local fontDingsbumsColor = nil
        local fontSymbolColor = nil
        
        if avalet.guildInfo.runiGuildInfoModel.HammerCharge == CHARGE_POSITIVE then fontDingsbumsColor = "blue" end
        if avalet.guildInfo.runiGuildInfoModel.HammerCharge == CHARGE_NEGATIVE then fontDingsbumsColor = "red" end

      
        if k.rCharge == avalet.guildInfo.runiGuildInfoModel.HammerCharge or k.rCharge == CHARGE_NONE then
          fontRuneColor = k.rColor
          --fontDingsbumsColor = k.rColor
          fontSymbColor = 'white'
        else
          fontRuneColor = k.rColor--'grey'
          fontDingsbumsColor = 'grey'
          fontSymbColor = 'white'--'grey'
        end

        itemText = itemText..[[
          &lt;tr style="border: 0px none black;"&gt;            
            &lt;td style="border:0px none black;padding-right: 5px; padding-left: 5px; padding-top: 0px; padding-bottom:0px; margin:0px; text-align: center; color: ]]..fontSymbColor..[[;background-color: ]]         ..fontDingsbumsColor..[[;"&gt;]]..k.rChargeSymbol..[[&lt;/td&gt;
            &lt;!--td style="background-color: ]]         ..fontDingsbumsColor..[[;"&gt;&amp;nbsp;&amp;nbsp;&lt;/td--&gt;
            &lt;td style="border:0px none black;padding: 0px; margin: 0px;text-align: left; color: ]]..fontRuneColor..[[;"&gt;&amp;nbsp;]]..string.gsub(k.rName, "(.*)rune", "%1")..[[&lt;/td&gt;
          &lt;/tr&gt;
        ]]

      end --for
    end --if

    itemText = itemText..[[&lt;/table&gt;&lt;/b&gt;&lt;/div&gt;&lt;/p&gt;]]
    label:echo("")
    label:echo(itemText)

    return label

  end --local function getItemTextLabel(itemType, item, posX, posY, parent)


  -- Hauptcontainer
  avaletUI.guildInfoContainer = Geyser.Container:new({
    name = "avaletUI.guildInfoContainer",
    x=mainContainerX, y=mainContainerY, 
    width=mainContainerWidth, height=mainContainerHeight,
  })
  
  --[[
  Derzeit werden im Runi-Infoscreen Bilder von den Items im Hintergrund hinter dem 
  Text zu den Items angezeigt. Da es keine Möglichkeit gibt, in Background-Image in
  einem Label transparent zu machen, liegen hier zwei Label übereinander. Im hinten
  liegenden ist das Bild als border-image, im Label davor der Text. So gehts. ]]

  local i = 0

  -- Label für Waffe
  if avalet.guildInfo.runiGuildInfoModel["iWeapon"]["iShow"]==true then
    i = i + 1
    avaletUI.runiInfoBox_weaponSymbol = getItemSymbolLabel(ITEM_TYPE_WEAPON, imageWeapon, pos[i]["xPos"], pos[i]["yPos"])
    avaletUI.runiInfoBox_weaponText = getItemTextLabel(ITEM_TYPE_WEAPON, avalet.guildInfo.runiGuildInfoModel["iWeapon"], pos[i]["xPos"], pos[i]["yPos"])
  else
    if avaletUI.runiInfoBox_weaponSymbol~=nil then avaletUI.runiInfoBox_weaponSymbol:hide() end
    if avaletUI.runiInfoBox_weaponText~=nil then avaletUI.runiInfoBox_weaponText:hide() end
  end
  
  -- Label für Schild
  if avalet.guildInfo.runiGuildInfoModel["iShield"]["iShow"]==true then
    i = i + 1
    avaletUI.runiInfoBox_shieldSymbol = getItemSymbolLabel(ITEM_TYPE_SHIELD, imageShield, pos[i]["xPos"], pos[i]["yPos"])
    avaletUI.runiInfoBox_shieldText = getItemTextLabel(ITEM_TYPE_SHIELD, avalet.guildInfo.runiGuildInfoModel["iShield"], pos[i]["xPos"], pos[i]["yPos"])
  else
    if avaletUI.runiInfoBox_shieldSymbol~=nil then avaletUI.runiInfoBox_shieldSymbol:hide() end
    if avaletUI.runiInfoBox_shieldText~=nil then avaletUI.runiInfoBox_shieldText:hide() end
  end

  -- Label für Helm
  if avalet.guildInfo.runiGuildInfoModel["iHead"]["iShow"]==true then
    i = i + 1
    avaletUI.runiInfoBox_headSymbol = getItemSymbolLabel(ITEM_TYPE_HEAD, imageHead, pos[i]["xPos"], pos[i]["yPos"])
    avaletUI.runiInfoBox_headText = getItemTextLabel(ITEM_TYPE_HEAD, avalet.guildInfo.runiGuildInfoModel["iHead"], pos[i]["xPos"], pos[i]["yPos"])
  else
    if avaletUI.runiInfoBox_headSymbol~= nil then avaletUI.runiInfoBox_headSymbol:hide() end
    if avaletUI.runiInfoBox_headText~=nil then avaletUI.runiInfoBox_headText:hide() end
  end

  -- Label für Körperpanzer
  if avalet.guildInfo.runiGuildInfoModel["iBody"]["iShow"]==true then
    i = i + 1
    avaletUI.runiInfoBox_bodySymbol = getItemSymbolLabel(ITEM_TYPE_BODY, imageBody, pos[i]["xPos"], pos[i]["yPos"])
    avaletUI.runiInfoBox_bodyText = getItemTextLabel(ITEM_TYPE_BODY, avalet.guildInfo.runiGuildInfoModel["iBody"], pos[i]["xPos"], pos[i]["yPos"])
  else
    if avaletUI.runiInfoBox_bodySymbol~= nil then avaletUI.runiInfoBox_bodySymbol:hide() end
    if avaletUI.runiInfoBox_bodyText~=nil then avaletUI.runiInfoBox_bodyText:hide() end
  end

  -- Label für Handschuhe
  if avalet.guildInfo.runiGuildInfoModel["iArms"]["iShow"]==true then
    i = i + 1
    avaletUI.runiGuildBox_armsSymbol = getItemSymbolLabel(ITEM_TYPE_ARMS, imageArms, pos[i]["xPos"], pos[i]["yPos"])
    avaletUI.runiGuildBox_armsText = getItemTextLabel(ITEM_TYPE_ARMS, avalet.guildInfo.runiGuildInfoModel["iArms"], pos[i]["xPos"], pos[i]["yPos"])
  else
    if avaletUI.runiGuildBox_armsSymbol~=nil then avaletUI.runiGuildBox_armsSymbol:hide() end
    if avaletUI.runiGuildBox_armsText~=nil then avaletUI.runiGuildBox_armsText:hide() end
  end

  -- Label für Stiefel
  if avalet.guildInfo.runiGuildInfoModel["iLegs"]["iShow"]==true then
    i = i + 1
    avaletUI.runiGuildBox_legsSymbol = getItemSymbolLabel(ITEM_TYPE_LEGS, imageLegs, pos[i]["xPos"], pos[i]["yPos"])
    avaletUI.runiGuildBox_legsText = getItemTextLabel(ITEM_TYPE_LEGS, avalet.guildInfo.runiGuildInfoModel["iLegs"], pos[i]["xPos"], pos[i]["yPos"])
  else
    if avaletUI.runiGuildBox_legsSymbol~=nil then avaletUI.runiGuildBox_legsSymbol:hide() end
    if avaletUI.runiGuildBox_legsText~=nil then avaletUI.runiGuildBox_legsText:hide() end
  end

end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildChatUI</name>
				<packageName></packageName>
				<script>--[[
Hier findet sich alles, was für die Anzeige der Chats benötigt wird. Also
erstmal die GUI-Elemente selbst und dann auch die Funktionen, die direkt
auf die Anzeige wirken. Die hier angezeigten Daten werden im Model vorbe-
reitet. (Avalet --&gt; Model --&gt; createChatModel) 
Die Idee ist, verschiedene Tabs für verschiedene Kanäle zu haben, also einen
für "rede", einen für "laber" einen für "schwafel"... Und einen weiteren Tab,
auf dem mehrere Kanäle zusammengefasst werden. Die Idee ist außerdem, dass
die User die Belegung dieser Tabs selbst bestimmen können: auf dem Summen-Tab
können sie selber festlegen, welche Kanäle dort zusammengefasst werden. Auf
den Einzeltabs können sie bestimmen, welcher Kanal dort angezeigt wird. Eine
weitere Idee ist, dass es noch einen Tab für Logging-Ausgaben geben soll. Aber
das ist eigentlich eher was fürs Model. ]]

-- Namensraum für das hier.
avaletUI.chats = avaletUI.chats or {}

--[[
Die Funktion avaletUI.buildChatUI() baut die Oberfläche auf. Also die grafischen
Elemente wie Rahmen, Tabulatoren und das Ausgabefeld für die Inhalte hinter den 
Tabulatoren. ]]
function avaletUI.buildChatUI()
  avalet.log("Function avaletUI.buildChatUI()", 1)

  --[[
  Diese Liste an Tabs wird auf der Oberfläche angezeigt. Die Liste hat einen Index, 
  der die Reihenfolge der Tabs bestimmt. Die Liste wird im Profil gespeichert, so
  dass Änderungen durch die User persistent sind. ]]
  avaletUI.chats.listOfDisplayedTabs = avaletUI.chats.listOfDisplayedTabs or avalet.profile:getChatTabsList()

  --[[
  Es gibt einen Sammel-Tab, auf dem mehrere Kommunikationskanäle zusammengefasst werden.
  Eigentlich ist das immer der erste Tab, aber man weiß ja nie. Deshalb wird hier erstmal
  der Index zu diesem Sammeltab geholt und gespeichert. ]]
  avaletUI.chats.sumTabIndex = table.index_of(avaletUI.chats.listOfDisplayedTabs, avalet.CONSTS.SUMMING_TAB_NAME)
  
  --[[
  Die Liste der Tabs, die auf dem Sammeltab angezeigt werden. ]]
  avaletUI.chats.listOfSummedTabs = avalet.profile:getCollectionList()     -- default: sag, rede, gruppe
   
  --[[
  Speichert das aktuell ausgewählte Element, also das derzeit angezeigt wird.
  Per Default ist es das erste Element. ]]
  avaletUI.chats.currentTabIndex = avaletUI.chats.currentTabIndex or tonumber(1)
    
  -- Liste von Tabs, für die es ungelesene Nachrichten gibt
  avaletUI.chats.listOfTabsWithUnreadEntries = avaletUI.chats.listOfTabsWithUnreadEntries or {}

  -- Speicherort für die Label, die die Tabulatoren darstellen. Wird weiter unten befüllt.
  avaletUI.chats.tabs = {}

  --[[
  Hier gehts los mit den GUI-Elementen.
  
  Dieses Label zeichnet den Rahmen um den Chats-Bereich. Notwendig weil
  Container unsichtbar sind und deshalb keinen Rahmen haben können. ]]
  avaletUI.chatsFrame = Geyser.Label:new({
      name="avaletUI.chatsFrame", 
      x=0, y=0, 
      height="100%", width="100%", 
      color="black",
  }, avaletUI.chatBoxContainer)
  avaletUI.chatsFrame:setStyleSheet(avaletUI.CSS.boxCSS:getCSS())
 
  -- Container, der die Teile des Tab-Elements enthält.
  avaletUI.chatsContainer = Geyser.Container:new({
      name = "avaletUI.chatsContainer",
      x = "1%", y = "2%",
      width = "98%", height = "96%",
  }, avaletUI.chatsFrame)

  -- die Kopfzeile des Tab-Elements, also da wo die Tabs sind
  avaletUI.chatsHeader = Geyser.HBox:new({
      name = "avaletUI.chatsHeader",
      x = 0, y = 0,
      width = "100%", height = "8%",
  }, avaletUI.chatsContainer)

  -- Der Körper des Tab-Elements, also da wo der Inhalt steht.
  avaletUI.chatsBody = Geyser.Label:new({
      name = "avaletUI.chatsBody",
      x = 0, y = "8%",
      width = "100%", height = "92%",
  }, avaletUI.chatsContainer)
  avaletUI.chatsBody:setStyleSheet(avaletUI.CSS.chatsBodyCSS:getCSS())
  
  -- Jetzt werden die einzelnen Tabs erzeugt.
  for key=1, #avaletUI.chats.listOfDisplayedTabs do
  
    --[[ 'value' enthält den Namen des Tabs, der auch auf dem Tab angezeigt wird.
    Normalerweise ist das der Name des Kanals, der auf dem Tab angezeigt wird. ]]
    local value = avaletUI.chats.listOfDisplayedTabs[key]
  
		-- Tabs sind auch nur Label. 
		avaletUI.chats.tabs[key] = Geyser.Label:new({
			  name = "avaletUI.chats.tabs."..key,
		}, avaletUI.chatsHeader)
		avaletUI.chats.tabs[key]:setFontSize(getFontSize() - 2)	  
		avaletUI.chats.tabs[key]:setFont(getFont())	  
		avaletUI.chats.tabs[key]:echo("&lt;center&gt;"..value)
    avaletUI.chats.tabs[key]:setStyleSheet(avaletUI.CSS.MenuTabCSS:getCSS())

    --[[
    Zu jedem Tab wird ein "right click menu" erstellt, in dem der Tab konfiguriert werden kann.
    Dieses Menü muss erzeugt werden, bevor der ClickCallback hinzugefügt wird. Sichtbar gemacht
    wird das Kontextmenü in der Funktion, die duch den ClickCallback ausgelöst wird. ]] 
    avaletUI.addRightClickMenue(key, value)

    --[[
    Damit die Tabs auch auf Anklicken reagieren, wird hier eine Callback-Funktion
    hinzugefügt. Letztlich ist das auch ein Event, der beim Anklicken ausgelöst
    wird. Parameter ist der Name des angeklickten Tabs. Die dazugehörige Funktion
    steht weiter unten. ]]
		avaletUI.chats.tabs[key]:setClickCallback("avaletUI.chats.tabOnClick", key)

    --[[
    Der Sammeltab soll mit dem Summenzeichen beschriftet sein. ]]
    if key == avaletUI.chats.sumTabIndex then avaletUI.chats.tabs[key]:echo("&lt;center&gt;&amp;sum;") end

	end  -- for

  --[[
  Alle Tabs sind erzeugt worden. Die Ausgabe der Tabs erfolgt aber in der gleichen
  Miniconsole. Es gibt also nicht zu jedem Tab eine, sondern nur die hier: ]]
	avaletUI.chats.miniConsole = Geyser.MiniConsole:new({
		  name="avaletUI.chats.miniConsole",
		  x="1%", y="2%",
		  width = "98%", height = "96%",
		  autoWrap = true,
		  color = "black",
		  scrollBar = true,
		  fontSize = tonumber(getFontSize()-2),
	}, avaletUI.chatsBody)
  avaletUI.chats.miniConsole:setFont(getFont())
  avaletUI.chats.miniConsole:resetAutoWrap()

  --[[
  Abschließend müssen die Tabs noch mit ihren jeweiligen Stylesheets versehen werden. Dies
  geschieht, indem einfach auf diesen "currentTab" geklickt wird. Oder zumindest wird so
  getan als ob. ]]
  avaletUI.chats.tabOnClick(avaletUI.chats.currentTabIndex)

end --function avaletGUI.buildChatUI()


--[[
Diese Funktion wird ausgeführt, wenn auf einen Tab geklickt wird. Der Name
des Tabs wird als Parameter übergeben. Der zu diesem Zeitpunkt noch aktivierte
Tab-Body wird unsichtbar gemacht, und der angeklickte Tab wird zum aktuell
aktivierten Tab und sichtbar gemacht. 
Außerdem wird noch die Darstellung der Tabs aktualisiert: Der bisher "aktuelle
Tab" wird als "nicht aktiviert" dargestellt, der jetzt aktivierte Tab wird als
"aktiviert" dargestellt. 
Der Parameter 'arg' wird automatisch angehängt, wenn tatsächlich auf das
Label geklickt wurde. Er ist eine Tabelle und enthält Informationen darüber,
mit welcher Maustaste geklickt wurde und auf welche Koordinaten.
Diese Funktion wird auch einfach so aufgerufen, ohne Label-klick, dann 
fehlt dieser Parameter. ]] 
function avaletUI.chats.tabOnClick(tab, arg)
  avalet.log("Function avaletUI.chats.tabOnClick(): "..tostring(tabIndex), 1)
  
  local tabIndex = tab                                      -- z.B. 4
  local tabLabel = avaletUI.chats.listOfDisplayedTabs[tab]  -- z.B. "Laber"

  --[[
  Das Kontextmenü wird nur bei einem Rechtsklick geöffnet. Obs einer ist oder
  nicht steht im Parameter 'arg' und wird automatisch ausgewertet. ]]
  if arg ~= nil and arg.button ~= nil then
    avaletUI.chats.tabs[tabIndex]:onRightClick(arg)
  end

  -- bisher aktivierten Tab als "nicht aktiviert" anzeigen
  avaletUI.chats.tabs[avaletUI.chats.currentTabIndex]:setStyleSheet(avaletUI.CSS.MenuTabCSS:getCSS())

  --[[
  Diesen Tab auch aus der Liste entfernen, in der die Tabs stehen, auf denen
  neue Nachrichten eingegangen sind. ]]
  for k, j in pairs(avaletUI.chats.listOfTabsWithUnreadEntries) do
    if j == tabLabel then
      table.remove(avaletUI.chats.listOfTabsWithUnreadEntries, k)
    end
  end
  
  --[[
  Wenn der Sammeltab geöffnet war, waren auch die dort gesammelten Kanal-Tabs
  als "aktiv" markiert. Die müssen dann jetzt auch ein anderes Stylesheet be-
  kommen. Und eventuelle Einträge in der Liste "UnreadEntries" entfernt werden. ]]
  if avaletUI.chats.currentTabIndex == avaletUI.chats.sumTabIndex then
    for i,v in pairs(avaletUI.chats.listOfSummedTabs) do
      for k, j in pairs(avaletUI.chats.listOfTabsWithUnreadEntries) do
          if v == j then table.remove(avaletUI.chats.listOfTabsWithUnreadEntries, k) end
      end -- for
      local index = table.index_of(avaletUI.chats.listOfDisplayedTabs, v)
      if index~= nil then avaletUI.chats.tabs[index]:setStyleSheet(avaletUI.CSS.MenuTabCSS:getCSS()) end
    end -- for
  end

  --[[
  Der Dreizeiler hier behebt ein Problem mit einem nicht immer richtig
  positionierten Cursor in der Miniconsole: ]]
  clearWindow("avaletUI.chats.miniConsole")
  avaletUI.chats.miniConsole:echo(" ")
  clearWindow("avaletUI.chats.miniConsole")

  -- der angeklickte Tab wird zum "aktuellen Tab" (am Model!). Zwingend vor dem nächsten Schritt!
	avaletUI.chats.currentTabIndex = tabIndex

  -- der neue "currenTab" wird entsprechend formatiert
  avaletUI.chats.tabs[tabIndex]:setStyleSheet(avaletUI.CSS.MenuTabCurrentCSS:getCSS())
  
  -- der Inhalt des neuen "currentTab" wird aktualisiert
  raiseEvent("RefreshChatUI", avaletUI.chats.listOfDisplayedTabs[avaletUI.chats.currentTabIndex])
  
  --[[
  Wenn der neue "aktuelle Tab" der Sammeltab ist, dann sollen alle Tabs, die dort
  angezeigt werden, auch als "aktueller Tab" markiert werden.]]
  if avaletUI.chats.currentTabIndex == avaletUI.chats.sumTabIndex then
    for _,v in pairs(avaletUI.chats.listOfSummedTabs) do
      local index = table.index_of(avaletUI.chats.listOfDisplayedTabs, v)
      if index ~= nil then avaletUI.chats.tabs[index]:setStyleSheet(avaletUI.CSS.MenuTabCurrentCSS:getCSS()) end
    end
  --[[
  Wenn der aktuelle Tab dagegen nicht der Sammeltab ist, aber auf einem der Tabs, die
  auf dem Sammeltab angezeigt werden, eine ungelesene Nachricht ist, dann soll der 
  Sammeltab auch als "hat neue Nachrichten" gekennzeichnet sein. Außerdem werden hier
  alle Tabs aus der listOfTabsWithUnreadEntries entsprechend markiert. ]]
  else
    for i, j in pairs(avaletUI.chats.listOfTabsWithUnreadEntries) do
      for k,v in pairs(avaletUI.chats.listOfSummedTabs) do
        if j == v then avaletUI.chats.tabs[avaletUI.chats.sumTabIndex]:setStyleSheet(avaletUI.CSS.MenuTabMarkedCSS:getCSS()) end
      end

      local index = table.index_of(avaletUI.chats.listOfDisplayedTabs, j)
      avaletUI.chats.tabs[index]:setStyleSheet(avaletUI.CSS.MenuTabMarkedCSS:getCSS())
    end
  end
    
end --function avaletUI.chats.tabOnClick(tab)


--[[
Damit die User wissen, dass auf einem (grade nicht aktivierten) Tab neue Nachrichten
eingegangen sind, erhalten diese Tabs eine Markierung, also eine eigene Formatierung.
Die wird zurück gesetzt, wenn der Tab aktiviert wird. ]]
function avaletUI.chats.markTab(tab)
  avalet.log("Function avaletUI.chats.markTab() mit Parameter: "..tostring(tab), 1)
  
  local tabName = tab
  local tabIndex = table.index_of(avaletUI.chats.listOfDisplayedTabs, tab)

  -- Manche Kanäle haben keinen Tab, der wäre dann hier "nil".
  if tabIndex == nil then 
    avalet.log("Tab zum Markieren ist nil: "..tostring(tabName), 2)
    return
  end
  
  -- Wenn der zu markierende Tab auch auf dem Sammeltab angezeigt wird, ...
  if table.index_of(avaletUI.chats.listOfSummedTabs, tabName) ~= nil then
    -- ..., der aktuelle Tab aber nicht der Sammeltab ist, ...
    if avaletUI.chats.currentTabIndex ~= avaletUI.chats.sumTabIndex then
      -- ... dann soll auch der Sammeltab mit markiert werden.
      avaletUI.chats.tabs[avaletUI.chats.sumTabIndex]:setStyleSheet(avaletUI.CSS.MenuTabMarkedCSS:getCSS())
    end
  end
  
  -- doubletten entfernen    
  for i, j in pairs(avaletUI.chats.listOfTabsWithUnreadEntries) do
    if j == tabName then
      table.remove(avaletUI.chats.listOfTabsWithUnreadEntries, i)
    end
  end

  table.insert(avaletUI.chats.listOfTabsWithUnreadEntries, tabName)
  avaletUI.chats.tabs[tabIndex]:setStyleSheet(avaletUI.CSS.MenuTabMarkedCSS:getCSS())

end --function avaletUI.chats.markTab(tab)


--[[
Diese Funktion aktualisiert die Anzeige. Sie wird immer ausgeführt,
wenn das ChatModel geändert wurde, also wenn auch auf der Oberfläche
eine Änderung zu erkennen sein soll. ]]
function avaletUI.onRefreshChatUI(_, chan)
  avalet.log("Function avaletUI.onRefreshChatUI() mit Parameter "..chan, 1)

  local content = ""
  local lastdate = ""
  local date = ""
  local line = ""
  local lineCount = nil
  
  local channel = chan
  
  local currentTabName = avaletUI.chats.listOfDisplayedTabs[avaletUI.chats.currentTabIndex]

  --[[
  Hier wird ermittelt, ob es der aktuell angezeigte Tab ist, für den die neue Nachricht
  ist. Das kann einmal so sein, weil es eben der aktuelle Tab ist, auf dessen Kanal eine
  neue Nachricht eingetroffen ist. Das kann aber auch sein, wenn der aktuelle Tab der
  Sammeltab ist, und der Kanal der neuen Nachricht dort angezeigt wird. ]]
  local function currentTabNeedsUpdate()
    local value = false
    -- Ist der aktuelle Tab der Tab des Kanals?
    if currentTabName == channel then value = true; return value end
    -- Ist der aktuelle Tab der Sammeltab ...
    if avaletUI.chats.currentTabIndex == avaletUI.chats.sumTabIndex then
      -- ... und wird der Kanal der neuen Nachricht dort angezeigt?
      for _,v in pairs(avaletUI.chats.listOfSummedTabs) do
        if v == channel then
          value = true
          channel = avalet.CONSTS.SUMMING_TAB_NAME
          break
        end --if
      end --for
    end --if
    return value
  end

  --[[ 
  Wenn die Nachricht, die eingeht, NICHT für den aktuell angezeigten Tab ist, dann wird
  einfach nur der entsprechende Tab farbig markiert. Damit der User sieht, dass da noch
  ungelesene Nachrichten sind. ]]
	if not currentTabNeedsUpdate() then avaletUI.chats.markTab(channel); return end

  --[[
  Wenn die neue Nachricht allerdings für den aktuell angezeigten Tab ist, dann geschieht
  deutlich mehr. ]]
  avalet.log("Der aktuelle TAB wird aktualisiert.", 1)

  -- Erstmal werden die alten Inhalte von der Miniconsole gelöscht
  clearWindow("avaletUI.chats.miniConsole")
  avaletUI.chats.miniConsole:echo(" ")
  clearWindow("avaletUI.chats.miniConsole")
  
  --[[ 
  Einträge aus der hasNewEntries-Liste entfernen, wenn der aktuelle
  Tab der Sammeltab ist und in der hasNewEntries-Liste Tabs stehen, 
  die auf dem Sammeltab angezeigt werden. ]]
  if channel == avalet.CONSTS.SUMMING_TAB_NAME then
    for _,v in pairs(avaletUI.chats.listOfSummedTabs) do
      for k, j in pairs(avaletUI.chats.listOfTabsWithUnreadEntries) do
        if j == v then
          table.remove(avaletUI.chats.listOfTabsWithUnreadEntries, k)
        end -- if
      end -- for
    end -- for
  end -- if

  -- Dann wird für jede Zeile in der ChatTab-Tabelle ...
  for _,v in pairs(avalet.chats.chats[channel]) do

    -- ... zunächst das Datum extrahiert. (Aus dem Timestamp am Anfang der Zeile.)
    date = string.gsub(v, "^%[(%d+%.%d+%.%d+) %- %d+:%d+:%d+%.%d+%]: .*$", "%1", 1)
    
    --[[
    Wenn der Tab noch ganz leer ist, dann wird als erste Zeile das Datum des ersten Eintrags
    angezeigt. Und dann jedesmal wieder, wenn sich das Datum ändert. (Also um Mitternacht.) 
    VOR diesen Datumszeilen wird eine Leerzeile ausgegeben - nur ganz am Anfang nicht. NACH
    diesen Datumszeilen wird immer eine Leerzeile ausgegeben. ]]
    
    --[[
    Die Trenn- bzw. Datumslinie richtet sich in der Breite nach dem 
    zur Verfügung stehenden Platz. ]]
    local i = math.floor((avaletUI.chats.miniConsole:getColumnCount() - 16) / 4)

    local filler = ""
    if i &gt; 0 then
      for j=0, i, 1 do
        filler = filler .. "~ "
      end
      filler = string.trim(filler)
    end
    
    if lastdate ~= date then
      -- Am Anfang ist "lastdate" noch leer, dann keine Leerzeile
      if lastdate ~= "" then content = "\n" end
      content = content .. "&lt;white&gt;" .. filler .. "   " .. date .. "   " .. filler .. "\n\n"
      lastdate = date
      lineCount = nil
    end
    
    -- Die eigentliche Zeile besteht nur aus dem Zeitstempel und dem eigentlichen Text
    line = string.gsub(v, "^%[%d+%.%d+%.%d+ %- (%d+:%d+:%d+)%.%d+%]: (.*)$", "%1: %2", 1)
    --content = content .. line .. "\n"
    
    if lineCount == nil or lineCount == 1 then
      content = content .."&lt;LimeGreen&gt;" .. line .. "\n"--"\n\n"
      lineCount = 2
    else
      content = content .."&lt;white&gt;" .. line .. "\n"--"\n\n"
      lineCount = 1
    end
    

    --[[
    In Mudlet Version 4.8 konnte "echo()" plötzlich nur noch 10k Zeichen auf einmal ausgeben.
    So weit ich das mitbekommen habe, wurde diese Änderung wieder zurückgenommen. Aber in 
    den wenigen Tagen, in denen Avalet deshalb nicht funktionierte, hab ich den Bug halt 
    schon gefixt. Und jetzt lass ich es so.
    Hier wird also nach 8k Zeichen der Content einmal ausgegeben (und dann geleert). ]]
    if #content &gt; 8000 then
      avaletUI.chats.miniConsole:cecho(content)
      content = ""
      lineCount = nil
    end
  end
  
  -- Zum Schluss wird noch der Rest vom Content ausgegeben, also alles unter 8k Zeichen.
  if content ~= "" then
    avaletUI.chats.miniConsole:cecho(content)
  end
  
end --function avaletUI.onRefreshChatUI(_, channel)
registerAnonymousEventHandler("RefreshChatUI", "avaletUI.onRefreshChatUI")


--[[
Zu jedem Tab gibt es ein Kontextmenü. Beim Sammeltab können in dem Menü die Kanäle
ausgewählt werden, die auf dem Sammeltab angezeigt werden sollen. Bei den anderen
Tabs kann der Kanal gewählt werden, der auf diesem Tab angezeigt werden soll. ]]
function avaletUI.addRightClickMenue(intTabIndex, strTabName)
avalet.log("function avaletUI.addRightClickMenue(strTabName): "..tostring(strTabName), 1) 

  local tabIndex = tonumber(intTabIndex)
  local tabName = strTabName

  -- Zuerst wird ein leeres Menü erzeugt und das Layout festgelegt.
  avaletUI.chats.tabs[tabIndex]:createRightClickMenu(
      {MenuItems = {}, 
      MenuWidth = 150, 
      MenuFormat = "l10",
      MenuStyle = [[
        QLabel::hover{ 
            background-color: rgba(96,96,96,255);
            color: white;} 
        QLabel::!hover{
            color: black; 
            background-color: rgba(96,96,96,255);
        } 
      ]]})

  -- anschließend werden die leeren Menüs befüllt.
  local CHANNELS = avalet.CONSTS.CHANNELS                -- alle verfügbaren Kanäle
  local chatTabs = avaletUI.chats.tabs                   -- die Kanäle, zu denen es derzeit einen Tab gibt
  local collectionList = avaletUI.chats.listOfSummedTabs   -- Kanäle die auf dem Sammeltab angezeigt werden
  
  -- Der Sammeltab bekommt ein Menü, in dem mehrere Elemente ausgewählt werden können
  if tabIndex == avaletUI.chats.sumTabIndex then

    --[[
    Alle Elemente aus der Channel-Konstante sollen angezeigt werden. Manche sind schon ausgewählt,
    andere sind es nicht. Das wird mit einem entsprechenden Symbol (Kästen mit Kreuz, Kästchen ohne
    Kreuz) symbolisiert. Die schon ausgewählten Kanäle stehen in der 'collectionList'. Hier wird
    jetzt die Liste aller Kanäle einmal mit der Liste der schon gewählten Kanäle abgeglichen und 
    das entsprechende Symbol hinzugefügt. ]]  
    for channelIndex=1, #CHANNELS do
    
      -- der aktuelle Kanal-Name
      local channelName = CHANNELS[channelIndex]

      local isItemInList = false
      local menuLabelName = ""
      
      for k,v in pairs(collectionList) do
      
        if channelName == v then
          -- &amp;#9746; ist ein Kästchen mit Kreuz drin.
          menuLabelName = "&amp;nbsp;&amp;#9746;&amp;nbsp;"..channelName
          -- Der Menüeintrag wird hinzugefügt und...
          avaletUI.chats.tabs[tabIndex]:addMenuLabel(menuLabelName)
          --[[
          ... mit Funktionalität versehen. Beim Auswählen des
          Menüpunkes wird die Funktion hier ausgeführt. Die
          selbst nur eine Funktion (weiter unten) ausführt. ]]
          avaletUI.chats.tabs[tabIndex]:setMenuAction((menuLabelName), function() avaletUI.toggleMenuEntry(channelName, menuLabelName) end)
          isItemInList = true
          break
        end
      end
  
      if isItemInList == false then
        -- &amp;#9744; ist ein Kästchen ohne Kreuz
        menuLabelName = "&amp;nbsp;&amp;#9744;&amp;nbsp;"..channelName
        avaletUI.chats.tabs[tabIndex]:addMenuLabel(menuLabelName)
        avaletUI.chats.tabs[tabIndex]:setMenuAction(menuLabelName, function() avaletUI.toggleMenuEntry(channelName, menuLabelName) end)
      end    
    end    
    
    
    
    -- Sammeltab mit Summenzeichen versehen
    --avaletUI.chats.tabs[tab.."tab"]:echo("&lt;center&gt;&amp;sum;")
  -- die normalen Tabs bekommen ein Menü, in dem jeweils nur eine Option gewählt werden kann  
  else
  
     --for u,w in pairs(CHANNELS) do
     for i=1, #CHANNELS, 1 do
    
      local w = CHANNELS[i]
  
      if w == tabName then
        -- &amp;#10687; (Kreis mit Punkt drin).
        menuLabelName = "&amp;nbsp;&amp;#10687;&amp;nbsp;"..w
      else
        -- &amp;#9711; (großer Kreis)     
        menuLabelName = "&amp;nbsp;&amp;#9711;&amp;nbsp;"..w
      end
       -- Der Menüeintrag wird hinzugefügt und...
      --table.insert(menuTable, MenuLabelName)
      avaletUI.chats.tabs[tabIndex]:addMenuLabel(menuLabelName)
      -- ... mit Funktionalität versehen. Beim Auswählen des
      -- Menüpunkes wird die Funktion hier ausgeführt. Die
      -- selbst nur eine Funktion ausführt.
      avaletUI.chats.tabs[tabIndex]:setMenuAction((menuLabelName), function() avaletUI.changeTabContext(tabIndex, tabName, w) end)
    end
  end  
  
end


function avaletUI.changeTabContext(intTabIndex, strTabName, strNewContext)
  avalet.log("Function avaletUI.changeTabContext(intTabIndex, strTabName): "..tostring(intTabIndex)..", "..tostring(strTabName), 1)

  local index = intTabIndex
  local tab = strTabName
  local newContext = strNewContext

  avalet.profile.changeTabContext(index, newContext)
  -- alten Eintrag
  avaletUI.chats.tabs[index]:hideMenuLabel("&amp;nbsp;&amp;#10687;&amp;nbsp;"..strTabName)
  -- neuen Eintrag
  avaletUI.chats.tabs[index]:hideMenuLabel("&amp;nbsp;&amp;#9711;&amp;nbsp;"..strNewContext)
  avalet.createChatModel()
  avaletUI.buildChatUI()
  
end

--[[
Hier werden die Einträge im Konfigurations-Menü geändert. Konkret gibt
es die Liste mit den Tabs, die aktuell auf dem Sammeltab angezeigt werden.
Und wenn der User im Menü einen Tab hinzufügt oder entfernt, dann wird
hier die Liste entsprechend aktualisiert. Anschließend muss die Oberfläche
neu gebaut werden, damit diese Veränderung auch sichtbar wird. Und da
der vom User ausgewählte Menüpunkt dabei sichtbar bleibt, wird er hier
extra ausgeblendet. ]]
function avaletUI.toggleMenuEntry(entryValue, menuLabelName)
  avalet.log("Function avaletUI.toggleMenuEntry(...)", 1)
  
  local keyToRemove = nil
  keyToRemove = table.index_of(avaletUI.chats.listOfSummedTabs, entryValue)
  if keyToRemove == nil then
    table.insert(avaletUI.chats.listOfSummedTabs, entryValue)
  else
    table.remove(avaletUI.chats.listOfSummedTabs, keyToRemove)
  end  

  --[[
  Das Kontextmenü wird automatisch geschlossen, aber der ausgewählte Eintrag
  blieb immer sichtbar. Der wird hier deshalb extra ausgeblendet. ]]
  --closeAllLevels(avaletUI.chatsConfig)
  avaletUI.chats.tabs[avaletUI.chats.sumTabIndex]:hideMenuLabel(menuLabelName)

  avalet.createChatModel()
  avaletUI.buildChatUI()

end
</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>ATCP</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>atcp</name>
				<packageName></packageName>
				<script>--[[
ATCP-Handling

In diesem Script findet der Umgang mit den ATCP-Daten statt, die Avalon
sendet (und empfängt). Hier soll so wenig passieren wie möglich. Die Daten
werden dort verarbeitet, wo die letztlich dann auch gespeichert werden.
Hier wäre aber ein guter Platz, um die Daten zu bereinigen, wenn sie irgend-
wie schlecht zu verarbeiten oder fehlerhaft sind. Ein Beispiel dafür wäre ein
"trim", wenn die Daten Leerzeichen am Anfang oder am Ende haben.
Eine Beschreibung der ATCP-Schnittstelle von Avalon findet sich im Wiki:
https://avalon.mud.de/wiki/avalon:atcp

Wenn Daten per ATCP eintreffen, dann löst das einen Event aus, der den "key"
des Datums trägt. Das Eintreffen des Charakternamens löst beispielsweise den
"AvalonName"-Event aus. Die Funktion, die darauf reagieren soll, wird also
für diesen Event registriert.

Alle ATCP-Daten werden von Mudlet in einer Tabelle gespeichert, die den Namen
"atcp" trägt. Diese Tabelle kann mit "display(atcp)" ausgegeben werden. (Auch
auf der Eingabezeile von Mudlet, da dann mit "lua display(atcp)". 

ATCP bzw. dessen Verwendung in Avalet muss auch konfiguriert werden. Das geschieht
bei der Verarbeitung des entsprechenden Events in der Funktion
avalet.onSysProtocolEnabled(event,arg). (Siehe unter Avalet --&gt; Events) ]]

avalet.atcp = avalet.atcp or {}

----------------------------------------------------------------------------------------
-- Misc
----------------------------------------------------------------------------------------

-- AvalonGrafikVermeiden
function avalet.atcp.onATCPEventAvalonGrafikVermeiden(event, arg)
	avalet.log("AvalonGrafikVermeiden = " .. tostring(arg), 1)
  -- Dieses ATCP-Flag wird derzeit nicht ausgewertet
end
registerAnonymousEventHandler("AvalonGrafikVermeiden", "avalet.atcp.onATCPEventAvalonGrafikVermeiden")

-- AuthRequest
function avalet.atcp.onATCPEventAuthRequest(event, arg)
	avalet.log("AuthRequest = " .. tostring(arg), 1)
  -- Dieses ATCP-Flag wird derzeit nicht ausgewertet
end
registerAnonymousEventHandler("AuthRequest", "avalet.atcp.onATCPEventAuthRequest")

----------------------------------------------------------------------------------------
--  Charakter-Daten/Spielstand
----------------------------------------------------------------------------------------

-- AvalonName
function avalet.atcp.onATCPEventAvalonName(event, arg)
  avalet.log("AvalonName per ATCP empfangen: " .. arg, 1)
  avalet.char.setName(tostring(arg))
end
registerAnonymousEventHandler("AvalonName", "avalet.atcp.onATCPEventAvalonName")

-- AvalonVollName
function avalet.atcp.onATCPEventAvalonVollName(event, arg)
	avalet.log("AvalonVollName per ATCP empfangen!", 1)
	avalet.char.setVollerName(arg)
end
registerAnonymousEventHandler("AvalonVollName", "avalet.atcp.onATCPEventAvalonVollName")

-- AvalonPortfolio
function avalet.atcp.onATCPEventAvalonPortfolio(event, arg)
	avalet.log("AvalonPortfolio per ATCP empfangen!", 1)
	avalet.char.setPortfolio(arg)
end
registerAnonymousEventHandler("AvalonPortfolio", "avalet.atcp.onATCPEventAvalonPortfolio")

-- AvalonGilde
function avalet.atcp.onATCPEventAvalonGilde(event, arg)
	avalet.log("AvalonGilde per ATCP empfangen!", 1)
	avalet.char.setGilde(arg)
end
registerAnonymousEventHandler("AvalonGilde", "avalet.atcp.onATCPEventAvalonGilde")

-- AvalonGildenInfo (ruebersicht-Daten der Runenschmiede)
function avalet.atcp.onATCPEventAvalonGildenInfo(event, arg)
	avalet.log("AvalonGildenInfo per ATCP empfangen!", 1)
  avalet.char.setGildenInfo(arg)
end
registerAnonymousEventHandler("AvalonGildenInfo", "avalet.atcp.onATCPEventAvalonGildenInfo")

-- AvalonZuenfte
function avalet.atcp.onATCPEventAvalonZuenfte(event, arg)
	avalet.log("AvalonZuenfte per ATCP empfangen!", 1)
	avalet.char.setZuenfte(arg)
end
registerAnonymousEventHandler("AvalonZuenfte", "avalet.atcp.onATCPEventAvalonZuenfte")

-- AvalonAlter
function avalet.atcp.onATCPEventAvalonAlter(event, arg)
	avalet.log("AvalonAlter per ATCP empfangen", 1)
  avalet.char.setAlter(arg)
end
registerAnonymousEventHandler("AvalonAlter", "avalet.atcp.onATCPEventAvalonAlter")

-- AvalonLevel
function avalet.atcp.onATCPEventAvalonLevel(event, arg)
	avalet.log("AvalonLevel per ATCP empfangen!", 1)
	avalet.char.setLevel(arg)
end
registerAnonymousEventHandler("AvalonLevel", "avalet.atcp.onATCPEventAvalonLevel")

-- AvalonEP
function avalet.atcp.onATCPEventAvalonEP(event, arg)
	avalet.log("AvalonEP per ATCP empfangen!", 1)
	avalet.char.setEP(arg)
end
registerAnonymousEventHandler("AvalonEP", "avalet.atcp.onATCPEventAvalonEP")

-- AvalonGesinnung
function avalet.atcp.onATCPEventAvalonGesinnung(event, arg)
	avalet.log("AvalonGesinnung per ATCP empfangen!", 1)
	avalet.char.setGesinnung(arg)
end
registerAnonymousEventHandler("AvalonGesinnung", "avalet.atcp.onATCPEventAvalonGesinnung")

-- AvalonHunger
-- Die Texte für Hunger und für Durst hatten am Ende ein Leerzeichen zu viel.
-- Das wurde gefixt. Aber ein Trim kann nie schaden.
function avalet.atcp.onATCPEventAvalonHunger(event, arg)
	avalet.log("AvalonHunger per ATCP empfangen!", 1)
	arg = string.trim(arg)
	avalet.char.setHunger(arg)
end
registerAnonymousEventHandler("AvalonHunger", "avalet.atcp.onATCPEventAvalonHunger")

-- AvalonDurst
-- Die Texte für Hunger und für Durst hatten am Ende ein Leerzeichen zu viel.
-- Das wurde gefixt. Aber ein Trim kann nie schaden.
function avalet.atcp.onATCPEventAvalonDurst(event, arg)
	avalet.log("AvalonDurst per ATCP empfangen!", 1)
	arg = string.trim(arg)
	avalet.char.setDurst(arg)
end
registerAnonymousEventHandler("AvalonDurst", "avalet.atcp.onATCPEventAvalonDurst")

-- AvalonHoehe
function avalet.atcp.onATCPEventAvalonHoehe(event, arg)
	avalet.log("AvalonHoehe per ATCP empfangen!", 1)
	avalet.char.setHoehe(arg)
end
registerAnonymousEventHandler("AvalonHoehe", "avalet.atcp.onATCPEventAvalonHoehe")

-- AvalonFlucht
function avalet.atcp.onATCPEventAvalonFlucht(event, arg)
	avalet.log("AvalonFlucht per ATCP empfangen: "..arg, 1)
	avalet.char.setFlucht(arg)
end
registerAnonymousEventHandler("AvalonFlucht", "avalet.atcp.onATCPEventAvalonFlucht")

-- AvalonSchutz
-- Wenn ein Schutzzauber hinzu kommt, gibt es eine ATCP-Message. Wenn ein
-- Schutz wegfällt, gibt es aber keine. 
function avalet.atcp.onATCPEventAvalonSchutz(event, arg)
	avalet.log("AvalonSchutz per ATCP empfangen!", 1)
	avalet.char.setSchutz(arg)
end
registerAnonymousEventHandler("AvalonSchutz", "avalet.atcp.onATCPEventAvalonSchutz")

-- AvalonGruppe
function avalet.atcp.onATCPEventAvalonGruppe(event, arg)
	avalet.log("AvalonGruppe per ATCP empfangen!", 1)
	avalet.char.setGruppenname(arg)
end
registerAnonymousEventHandler("AvalonGruppe", "avalet.atcp.onATCPEventAvalonGruppe")

-- AvalonZaubern
function avalet.atcp.onATCPEventAvalonZaubern(event, arg)
	avalet.log("AvalonZaubern per ATCP empfangen!", 1)
	avalet.char.setZaubern(arg)
end
registerAnonymousEventHandler("AvalonZaubern", "avalet.atcp.onATCPEventAvalonZaubern")

-- AvalonKampf
function avalet.atcp.onATCPEventAvalonKampf(event, arg)
	avalet.log("AvalonKampf per ATCP empfangen: "..tostring(arg), 1)
	avalet.fight.setKampf(arg)
end
registerAnonymousEventHandler("AvalonKampf", "avalet.atcp.onATCPEventAvalonKampf")

-- AvalonAngegriffen
function avalet.atcp.onATCPEventAvalonAngegriffen(event, arg)
	avalet.log("AvalonAngegriffen per ATCP empfangen: "..arg, 1)
	avalet.fight.setAngegriffen(arg)
end
registerAnonymousEventHandler("AvalonAngegriffen", "avalet.atcp.onATCPEventAvalonAngegriffen")

-- AvalonGetoetet
function avalet.atcp.onATCPEventAvalonGetoetet(event, arg)
	avalet.log("AvalonGetoetet per ATCP empfangen: "..arg, 1)
	avalet.fight.setGetoetet(arg)
end
registerAnonymousEventHandler("AvalonGetoetet", "avalet.atcp.onATCPEventAvalonGetoetet")

-- AvalonGruppeGetoetet
function avalet.atcp.onATCPEventAvalonGruppeGetoetet(event, arg)
	avalet.log("AvalonGruppeGetoetet per ATCP empfangen!", 1)
	avalet.fight.setGruppeGetoetet(arg)
end
registerAnonymousEventHandler("AvalonGruppeGetoetet", "avalet.atcp.onATCPEventAvalonGruppeGetoetet")

-- AvalonAllyGetoetet
function avalet.atcp.onATCPEventAvalonAllyGetoetet(event, arg)
	avalet.log("AvalonAllyGetoetet per ATCP empfangen!", 1)
	avalet.fight.setAllyGetoetet(arg)
end
registerAnonymousEventHandler("AvalonAllyGetoetet", "avalet.atcp.onATCPEventAvalonAllyGetoetet")


--[[------------------------------------------------------------------------------------

     TP, TPMAX, AP, APMAX, ZP, ZPMAX, MP, MPMAX
     
Hier findet die Verarbeitung der Vital-Werte statt. Grade bei den Maximalwerten gibt
es natürlich wenig Veränderungen. Deshalb wird hier immer zuerst geschaut, ob sich der
Wert denn überhaupt verändert hat. Wenn er das hat, wird der entsprechende Event aus-
gelöst, durch den dann letztlich eine Aktualisierung der Oberfläche stattfindet. 

--------------------------------------------------------------------------------------]]

-- AvalonTP
function avalet.atcp.onATCPEventAvalonTP(event, arg)
	avalet.log("AvalonTP per ATCP empfangen!", 1)
	avalet.char.setStatsTP(tonumber(arg))
end
registerAnonymousEventHandler("AvalonTP", "avalet.atcp.onATCPEventAvalonTP")

-- AvalonMAXTP
function avalet.atcp.onATCPEventAvalonMAXT(event, arg)
	avalet.log("AvalonMAXTP per ATCP empfangen!", 1)
	avalet.char.setStatsTPMax(tonumber(arg))
end
registerAnonymousEventHandler("AvalonMAXTP", "avalet.atcp.onATCPEventAvalonMAXT")

-- AvalonAP
function avalet.atcp.onATCPEventAvalonAP(event, arg)
	avalet.log("AvalonAP per ATCP empfangen!", 1)
	avalet.char.setStatsAP(tonumber(arg))
end
registerAnonymousEventHandler("AvalonAP", "avalet.atcp.onATCPEventAvalonAP")

-- AvalonMAXAP
function avalet.atcp.onATCPEventAvalonMAXAP(event, arg)
	avalet.log("AvalonMAXAP per ATCP empfangen!", 1)
	avalet.char.setStatsAPMax(tonumber(arg))
end
registerAnonymousEventHandler("AvalonMAXAP", "avalet.atcp.onATCPEventAvalonMAXAP")

-- AvalonSP
function avalet.atcp.onATCPEventAvalonSP(event, arg)
	avalet.log("AvalonSP per ATCP empfangen!", 1)
	avalet.char.setStatsZP(tonumber(arg))
end
registerAnonymousEventHandler("AvalonSP", "avalet.atcp.onATCPEventAvalonSP")

-- AvalonMAXSP
function avalet.atcp.onATCPEventAvalonMAXSP(event, arg)
	avalet.log("AvalonMAXSP per ATCP empfangen!", 1)
	avalet.char.setStatsZPMax(tonumber(arg))
end
registerAnonymousEventHandler("AvalonMAXSP", "avalet.atcp.onATCPEventAvalonMAXSP")

-- AvalonMP
function avalet.atcp.onATCPEventAvalonMP(event, arg)
	avalet.log("AvalonMP per ATCP empfangen!", 1)
	avalet.char.setStatsMP(tonumber(arg))
end
registerAnonymousEventHandler("AvalonMP", "avalet.atcp.onATCPEventAvalonMP")

-- AvalonMAXMP
function avalet.atcp.onATCPEventAvalonMAXMP(event, arg)
	avalet.log("AvalonMAXMP per ATCP empfangen!", 1)
	avalet.char.setStatsMPMax(tonumber(arg))
end
registerAnonymousEventHandler("AvalonMAXMP", "avalet.atcp.onATCPEventAvalonMAXMP")



--[[------------------------------------------------------------------------------------

   Kommunikation

Hier werden die ganzen Kommunikations-Daten verarbeitet. Also labern, reden, sagen...
Aber auch Emotes. Ich kommentier jeweils die erste Funktion, weitere gleiche dann
nicht mehr.

Die Vorbereitung der Daten an dieser Stelle zu machen (und nicht eher im Model) hat
sich angeboten, weil die Weiterverarbeitung dann einheitlich ist. Ich versuche das
durch eine entsprechende Dokumentation transparent zu halten.

Meldungen über channel:
Avalon.Channel [kanalname] [Nachricht]
--------------------------------------------------------------------------------------]]

-- AvalonChannel
function avalet.atcp.onATCPEventAvalonChannel(event, arg)
  avalet.log("AvalonChannel = " .. arg, 1)
  
  --[[
  Zu Beginn der ATCP-Nachricht steht der Kanal, über den sie geschickt wurde.
  Wenn ein Mensch per "vr" zu den Menschen spricht, dann steht da: "mensch ..."
  Dieser Kanal wird hier extrahiert. Gleichzeitig wird der erste Buchstabe in
  einen Großbuchstaben geändert. ]]
  local channel = string.title(string.match(arg, "^(%w+)"))
  
  -- Die eigentliche Nachricht ist der Teil nach dem ersten Leerzeichen.
  local message = arg:gsub("^.-%s", "", 1)

  --[[
  Die Channelnamen hängen davon ab, in welcher Gilde, Zunft, in welchem Volk etc.
  der Char ist. Auf der Oberfläche sollen die Kanalnamen aber "Volk" und "Gilde" 
  etc. heißen. Und nicht "Menschen", "Magier" etc.
  Zünfte sollen außerdem zusammengefasst werden, das wird ja sonst viel zu viele
  Tabs. ]] 
  if channel == "Hyraskrieger" then channel = "Gilde" end
  if channel == "Golemkultisten" then channel = "Gilde" end
  if channel == "Daemonenkrieger" then channel = "Gilde" end
  if channel == "Runenschmiede" then channel = "Gilde" end
  if channel == "Barden" then channel = "Gilde" end
  if channel == "Kleriker" then channel = "Gilde" end
  if channel == "Druiden" then channel = "Gilde" end
  if channel == "Nekromanten" then channel = "Gilde" end
  if channel == "Magier" then channel = "Gilde" end

  if channel == "Schneider" then channel = "Zuenfte" end
  if channel == "Orkjaeger" then channel = "Zuenfte" end
  if channel == "Koeche" then channel = "Zuenfte" end

  --[[
  Zu welchem Volk ein Charakter gehört, lässt sich derzeit nur aus
  dem entsprechenden Kommunikationskanal ableiten. Wenn ein Charakter
  auf dem "Menschen"-Kanal mitlesen kann, dann muss er wohl ein 
  Mensch sein...
  Da diese Information bei den Charakter-Infos angezeigt werden soll,
  wird sie hier ausgelesen und gespeichert. Diese Information wird
  also erst angezeigt, wenn der Char das erste mal über seinen Rassen-
  Kanal was empfängt. Und danach dann aber immer, weil dieser Wert
  von Avalet gespeichert wird. Eine Aktualisierung der Oberfläche ist
  also nur beim ersten Mal notwendig. ]]

  -- Wenn etwas über den Menschen-Kanal kommt...
  if channel == "Mensch" then
    -- ... dann weiss Avalet jetzt: es ist ein Mensch!
    avalet.char.setNation("Menschen")
    -- Aber der Nachrichten-Tab heißt "Volk", nicht "Mensch"
    channel = "Volk"
  elseif channel == "Hobbit" then
    avalet.char.setNation("Hobbits")
    channel = "Volk"
  elseif channel == "Elf" then
    avalet.char.setNation("Elfen")
    channel = "Volk"
  elseif channel == "Dunkelelf" then
    avalet.char.setNation("Dunkelelfen")
    channel = "Volk"
  elseif channel == "Zwerg" then
    avalet.char.setNation("Zwerge")
    channel = "Volk"
  elseif channel == "Chaoszentaur" then
    avalet.char.setNation("Chaoszentauren")
    channel = "Volk"
  elseif channel == "Amphib" then
    avalet.char.setNation("Amphiben")
    channel = "Volk"
  elseif channel == "Exxen" then
    avalet.char.setNation("Exxen")
    channel = "Volk"
  elseif channel == "Oger" then   
    avalet.char.setNation("Oger")
    channel = "Volk"
  end
  
  -- Jetzt wird die neue Nachricht weiter verarbeitet: 
  avalet.chats.processNewMessage(channel, message)

end
registerAnonymousEventHandler("AvalonChannel", "avalet.atcp.onATCPEventAvalonChannel")



-- AvalonComm (Sagen)
function avalet.atcp.onATCPEventAvalonComm(event, arg)
  avalet.log("AvalonComm = " .. arg, 1)
  
  --[[
  Der Kanalname steht auch am Anfang der Nachricht, aber in Kapitalien.
  Ich setz den einfach mal von Hand: ]]
  local channel = "Sagen"
  
  --[[
  Die eigentliche Nachricht ist der Teil hinter dem ersten Leerzeichen,
  alles vorher wird hier abgeschnitten. ]]
  local message = arg:gsub("^.-%s", "", 1)
  --[[
  Hier werden MXP-Daten entfernt, die sind nur Zeichensalat. ]]
  message = message:gsub('%[1z[^[]*%[7z','')

  -- Hier wird die Nachricht weiter verarbeitet (Model --&gt; createChatModel):
  avalet.chats.processNewMessage(channel, message)

end
registerAnonymousEventHandler("AvalonComm", "avalet.atcp.onATCPEventAvalonComm")



-- AvalonRComm (Reden)
function avalet.atcp.onATCPEventAvalonRComm(event, arg)
	avalet.log("AvalonRComm = " .. arg, 1)

	local channel = "Reden"
	local message = arg:gsub("^.-%s", "", 1)
  --[[
  Hier werden MXP-Daten entfernt, die sind nur Zeichensalat. ]]
  message = message:gsub('%[1z[^[]*%[7z','')

  avalet.chats.processNewMessage(channel, message)

end
registerAnonymousEventHandler("AvalonRComm", "avalet.atcp.onATCPEventAvalonRComm")



-- AvalonSoul (Sagen)
function avalet.atcp.onATCPEventAvalonSoul(event, arg)
	avalet.log("AvalonSoul = " .. arg, 1)

  --[[
  Die Emotes werden hier einfach so verarbeitet, wie die "normale"
  Kommunikation mit der entsprechenden Distanz. Also: Ferngefühle 
  werden wie "rede"n behandelt, normale Gefühle wie "sag"en.]]
	local channel = "Sagen"
	local message = arg:gsub("^.-%s", "", 1)

  avalet.chats.processNewMessage(channel, message)

end
registerAnonymousEventHandler("AvalonSoul", "avalet.atcp.onATCPEventAvalonSoul")



-- AvalonRSoul (Reden)
function avalet.atcp.onATCPEventAvalonRSoul(event, arg)
  avalet.log("AvalonRSoul = " .. arg, 1)
  
  local channel = "Reden"
  local message = arg:gsub("^.-%s", "", 1)

  avalet.chats.processNewMessage(channel, message)

end
registerAnonymousEventHandler("AvalonRSoul", "avalet.atcp.onATCPEventAvalonRSoul")



----------------------------------------------------------------------------------------
--  Item-Handling
--  wird von Avalet nicht verwendet
----------------------------------------------------------------------------------------

-- AvalonInventarRein
function avalet.atcp.onATCPEventAvalonInventarRein(event, arg)
	avalet.log("AvalonInventarRein = " .. arg, 1)
	--avalet.char.setInventarRein(arg)
end
registerAnonymousEventHandler("AvalonInventarRein", "avalet.atcp.onATCPEventAvalonInventarRein")


-- AvalonInventarRaus
function avalet.atcp.onATCPEventAvalonInventarRaus(event, arg)
	avalet.log("AvalonInventarRaus = " .. arg, 1)
	--avalet.char.setInventarRaus(arg)
end
registerAnonymousEventHandler("AvalonInventarRaus", "avalet.atcp.onATCPEventAvalonInventarRaus")


-- AvalonBehaelterRein
function avalet.atcp.onATCPEventAvalonBehaelterRein(event, arg)
	avalet.log("AvalonBehaelterRein = " .. arg, 1)
  --avalet.char.setBehaelterRein(arg)	
end
registerAnonymousEventHandler("AvalonBehaelterRein", "avalet.atcp.onATCPEventAvalonBehaelterRein")


-- AvalonBehaelterRaus
function avalet.atcp.onATCPEventAvalonBehaelterRaus(event, arg)
	avalet.log("AvalonBehaelterRaus = " .. arg, 1)
  --avalet.char.setBehaelterRaus(arg)
end
registerAnonymousEventHandler("AvalonBehaelterRaus", "avalet.atcp.onATCPEventAvalonBehaelterRaus")


-- AvalonGefuehrt
function avalet.atcp.onATCPEventAvalonGefuehrt(event, arg)
	avalet.log("AvalonAvalonGefuehrt = " .. arg, 1)
  --avalet.char.setGefuehrt(arg)	
end
registerAnonymousEventHandler("AvalonGefuehrt", "avalet.atcp.onATCPEventAvalonGefuehrt")


-- AvalonGesenkt
function avalet.atcp.onATCPEventAvalonGesenkt(event, arg)
	avalet.log("AvalonGesenkt = " .. arg, 1)
  --avalet.char.setGesenkt(arg)	
end
registerAnonymousEventHandler("AvalonGesenkt", "avalet.atcp.onATCPEventAvalonGesenkt")


-- AvalonAngezogen
function avalet.atcp.onATCPEventAvalonAngezogen(event, arg)
	avalet.log("AvalonAvalonAngezogen = " .. arg, 1)
  --avalet.char.setAngezogen(arg)	
end
registerAnonymousEventHandler("AvalonAngezogen", "avalet.atcp.onATCPEventAvalonAngezogen")


-- AvalonAusgezogen
function avalet.atcp.onATCPEventAvalonAusgezogen(event, arg)
	avalet.log("AvalonAusgezogen = " .. arg, 1)
  --avalet.char.setAusgezogen(arg)	
end
registerAnonymousEventHandler("AvalonAusgezogen", "avalet.atcp.onATCPEventAvalonAusgezogen")


--------------------------------------------------------------------
-- Map/Mapper
--------------------------------------------------------------------

-- AvalonDunkel
function avalet.atcp.onATCPEventAvalonDunkel(event, arg)
  avalet.log("AvalonDunkel = " .. tostring(arg), 1)
  --avalet.char.setIstDunkel(tostring(arg))
end
registerAnonymousEventHandler("AvalonDunkel", "avalet.atcp.onATCPEventAvalonDunkel")

--[[
ATCP.AvalonInstance kann man anfordern, und zwar mit 'sendATCP("ava_req_iid", "hier")'.
(Ohne die ' vorne und hinten.) Was dann kommt ist eine verbeuelte RoomID: nur die ID,
nicht der Name. Ich wollte immer mal fragen, ob das ein Bug ist, aber ... dann war
der Tag immer schon um. TODO
Angefordert wird AvalonInstance übrigens durch ein Alias auf "schau" oder durch die
5 auf dem Ziffernblock. ]]
function avalet.atcp.onATCPEventAvalonInstance(event, arg)
  avalet.log("AvalonInstance = " .. tostring(arg), 1)
  
  --[[
  Format:
  hier raum/193219d1cd6e2e81fbf8a116c22c0022 ""

  Hier kommt im Grunde eine "RoomID" an, nur mit einem führenden "hier ". Dieser Teil
  wird hier abgeschnitten, und dann wird der Rest einfach an die Funktion übergeben,
  die die RoomID sonst auch verarbeitet. Das ist die hier direkt drunter... ]]
  
  -- Erstmal das führende "hier " abtrennen
  arg = string.gsub(arg, "hier (.*)", "%1")
  
  --[[
  Dann so tun als ob per ATCP 'AvalonRoomID' eintrifft, dadurch übernimmt dann die
  richtige Funktion. (Und dort dann den Sonderfall "leerer Name" verarbeiten.) ]]
  raiseEvent("AvalonRoomID", arg)
end
registerAnonymousEventHandler("AvalonInstance", "avalet.atcp.onATCPEventAvalonInstance")


-- AvalonRoomID
function avalet.atcp.onATCPEventAvalonRoomID(event, arg)
  avalet.log("AvalonRoomID = " .. tostring(arg), 1)
  
  --[[
  Normalerweise enthält die RoomID auch einen Namen, also "Walhalla" oder sowas.
  Aber es gibt den Sonderfall, dass da kein Name ist. Warum das so ist, steht 
  weiter oben bei 'function avalet.atcp.onATCPEventAvalonInstance(event, arg)' ]]

  local str = string.gsub(arg, "^%S*%s+(.+)", "%1", 1)
  if str ~= '""' then 
    avalet.char.setAvalonRoomID(str)
  end

  str = string.gsub(arg, "^raum/(%S*)%s+.+", "%1", 1)
  avalet.char.setAvalonRoomHash(str)
  
  --[[
  Hierdurch wird RoomInv abgefragt. Das geschieht auch bei einem "schau", damit
  man im Kampf durch "schau" (oder durch die 5 auf dem Ziffernblock) ein aktuelles
  RoomInv bekommt. Das dann angezeigt wird und zum Beispiel Gegner bzw. Leichen und
  Loot und so zeigt. Und die anderen Chars aus der Gruppe ggf. ]]
  _ = sendATCP("ava_req_inv hier")
  
end
registerAnonymousEventHandler("AvalonRoomID", "avalet.atcp.onATCPEventAvalonRoomID")



-- event == "AvalonRoomBrief"
function avalet.atcp.onATCPEventAvalonRoomBrief(event, arg)
	avalet.log("AvalonRoomBrief = " .. tostring(arg), 1)

end
registerAnonymousEventHandler("AvalonRoomBrief", "avalet.atcp.onATCPEventAvalonRoomBrief")


-- AvalonArea
function avalet.atcp.onATCPEventAvalonArea(event, arg)
	avalet.log("AvalonArea = " .. tostring(arg), 1)

end
registerAnonymousEventHandler("AvalonArea", "avalet.atcp.onATCPEventAvalonArea")


-- AvalonInv
function avalet.atcp.onATCPEventAvalonInv(event, arg)
	avalet.log("AvalonInv = " .. tostring(arg), 1)
  
  avalet.char.setAvalonRoomInv(arg)

end
registerAnonymousEventHandler("AvalonInv", "avalet.atcp.onATCPEventAvalonInv")


-- AvalonZiele
function avalet.atcp.onATCPEventAvalonZiele(event, arg)
	avalet.log("AvalonZiele = " .. tostring(arg), 1)
  
  --echo("\n\n AVALON.TARGETS START\n\n")
  --display(arg)
  --echo("\n\n AVALON.TARGETS STOP\n\n")
  
  --avalet.char.setAvalonRoomZiele(arg)

end
registerAnonymousEventHandler("AvalonZiele", "avalet.atcp.onATCPEventAvalonZiele")


-- AvalonSite
function avalet.atcp.onATCPEventAvalonSite(event, arg)
	avalet.log("AvalonSite = " .. tostring(arg), 1)

end
registerAnonymousEventHandler("AvalonSite", "avalet.atcp.onATCPEventAvalonSite")


-- AvalonExits
function avalet.atcp.onATCPEventAvalonExits(event, arg)
	avalet.log("AvalonExits = " .. tostring(arg), 1)

end
registerAnonymousEventHandler("AvalonExits", "avalet.atcp.onATCPEventAvalonExits")


-- AvalonAvalonWeg
function avalet.atcp.onATCPEventAvalonAvalonWeg(event, arg)
	avalet.log("AvalonAvalonWeg = " .. tostring(arg), 1)

end
registerAnonymousEventHandler("AvalonAvalonWeg", "avalet.atcp.onATCPEventAvalonAvalonWeg")


-- AvalonAvalonIcon16
function avalet.atcp.onATCPEventAvalonAvalonIcon16(event, arg)
	avalet.log("AvalonAvalonWeg = " .. tostring(arg), 1)

end
registerAnonymousEventHandler("AvalonAvalonIcon16", "avalet.atcp.onATCPEventAvalonAvalonIcon16")


--[[
--------------------------------------------------------------------
-- onKill wird durch einen kill ausgelöst -- ab hier nicht funktionsfähig
--------------------------------------------------------------------

function onKillEvent(event,name,file)
  avalet.log("atcp.onKillEvent", 3)
	--sendATCP("ava_req_inv", "hier")
	--if tMetzel and tMetzel.sMode ~= nil then fMetzelGetoetet() end 
	--sendAll("r","t bewohner")
end
--registerAnonymousEventHandler("KillEvent", "onKillEvent")

-- Script: AvalonAllyGetoetet
function AvalonAllyGetoetet(event,arg)
	--onATCP (event,arg)
	--raiseEvent("onKillEvent",arg)
end
--registerAnonymousEventHandler("AvalonAllyGetoetet", "AvalonAllyGetoetet")

-- Script: AvalonAP
function AvalonAP(event,arg)
	--tPlayer.diffap = tonumber(arg) - tonumber(tPlayer.ap)
	--onATCP (event,arg)
end
--registerAnonymousEventHandler("AvalonAP", "AvalonAP")


-- Script: AvalonBehaelterRaus
function AvalonBehaelterRaus(event,arg)
	--onATCP (event,arg)
	--sendATCP("ava_req_inv", "mich")
end
--registerAnonymousEventHandler("AvalonBehaelterRaus", "AvalonBehaelterRaus")

-- Script: AvalonBehaelterRein
function AvalonBehaelterRein(event,arg)
	--onATCP (event,arg)
	--sendATCP("ava_req_inv", "mich")
end
--registerAnonymousEventHandler("AvalonBehaelterRein", "AvalonBehaelterRein")
]]</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage>
		<KeyGroup isActive="yes" isFolder="yes">
			<name>Keypadfunktionen</name>
			<packageName></packageName>
			<script>--[[
Hier findet sich die Belegung des Ziffernblocks. ]]
</script>
			<command></command>
			<keyCode>-1</keyCode>
			<keyModifier>0</keyModifier>
			<Key isActive="yes" isFolder="no">
				<name>9 - nordosten</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",9)</script>
				<command></command>
				<keyCode>57</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>8 - norden</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",8)</script>
				<command></command>
				<keyCode>56</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>7 - nordwesten</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",7)</script>
				<command></command>
				<keyCode>55</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>6 - osten</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",6)</script>
				<command></command>
				<keyCode>54</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>5 - schau</name>
				<packageName></packageName>
				<script>--[[
Also hier wird (genau wie bei dem Alias auf "schau", wo dieser Text auch
steht) die RoomID des aktuellen Raumes angefordert. Die kommt dann
als "AvalonInstance" per ATCP. Dieser Wert wird dann innerhalb von Avalet
einfach weitergereicht, und zwar an die Funktion, die auch die RoomID ver-
arbeitet, wenn die per ATCP kommt. Und DORT wird dann "RoomInv" nochmal
per ATCP angefordert. Und DAS sorgt dann dafür, dass die "RoomInv"-Anzeige
auf dem GUI aktualisiert wird. Dort steht, was sich so im Raum befindet.
Also: man selbst, Gruppenmitglieder oder allgemein andere Chars, Gegner,
Leichen, Loot, Möbel... Sinn ist, dass man sich so im Kampfgetümmel einen
Überblick über den aktuellen Stand verschaffen kann. Denn von selbst
aktualisiert sich RoomInv nicht. 
Und ich weiß nicht mehr, warum ich das so gebaut habe. Und warum ich hier
nicht einfach RoomInv anfordere. Aber ich vertrau mal darauf, dass das
irgendeinen Grund hat. Und halte mich an die alte Regel: never change a
running system.

Außerdem wird hier die InfoBox auf den Default-Wert zurückgesetzt. Falls man
mal nicht warten will, bis der Timer für die Injections abgelaufen ist. Die
Idee ist, dass man mit der eigenen Aufmerksamkeit ohnehin in der Hauptconsole
sein wird, wenn man mit "schau" die Raumbeschreibung neu ausgeben lässt. ]]

--Infobox auf Default stellen
if avalet.infoBox.injectionTimerID ~= nil then killTimer(avalet.infoBox.injectionTimerID) end
avalet.infoBox.injectionTimerID=nil;
raiseEvent("RenewInfoBox")

_ = sendATCP("ava_req_iid", "hier")
raiseEvent("keyPadEvent",5)
				</script>
				<command></command>
				<keyCode>53</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>4 - westen</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",4)</script>
				<command></command>
				<keyCode>52</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>3 - suedosten</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",3)</script>
				<command></command>
				<keyCode>51</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>2 - sueden</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",2)</script>
				<command></command>
				<keyCode>50</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>1 - suedwesten</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",1)</script>
				<command></command>
				<keyCode>49</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>- - hoch</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",10)</script>
				<command></command>
				<keyCode>45</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>+ - runter</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",11)</script>
				<command></command>
				<keyCode>43</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="no" isFolder="no">
				<name>/ - rein</name>
				<packageName></packageName>
				<script>--[[
Die Belegung von Ziffernblocktasten mit "rein" und "raus" war bisher - also 
in anderthalb Jahren, in denen ich damit spiele - vollkommen nutzlos. Das
ist einfach kein sehr häufig verwendeter Befehl. Ich deaktivier die deshalb
mal. Dann kann sich jeder Spieler das hier ansehen und mit einer eigenen
Idee kopieren. (Hier ändern geht normalerweise nicht, weil Avalet sich immer
wieder selbst überschreibt bei jedem Neustart.) ]]
raiseEvent("keyPadEvent",12)</script>
				<command></command>
				<keyCode>47</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="no" isFolder="no">
				<name>* - raus</name>
				<packageName></packageName>
				<script>--[[
Die Belegung von Ziffernblocktasten mit "rein" und "raus" war bisher - also 
in anderthalb Jahren, in denen ich damit spiele - vollkommen nutzlos. Das
ist einfach kein sehr häufig verwendeter Befehl. Ich deaktivier die deshalb
mal. Dann kann sich jeder Spieler das hier ansehen und mit einer eigenen
Idee kopieren. (Hier ändern geht normalerweise nicht, weil Avalet sich immer
wieder selbst überschreibt bei jedem Neustart.) ]]
raiseEvent("keyPadEvent",13)</script>
				<command></command>
				<keyCode>42</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>0 - blicke gegner</name>
				<packageName></packageName>
				<script>send("blicke gegner")</script>
				<command></command>
				<keyCode>48</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
		</KeyGroup>
		<KeyGroup isActive="yes" isFolder="yes">
			<name>Fernrohr</name>
			<packageName></packageName>
			<script>--[[
Wenn der Char ein Fernrohr im Inventar hat, dann kann der Spieler durch
drücken von STRG plus einer Richtungstaste in die entsprechende Richtung
'spaehe'n. 
Die Taste '5' löst auch hier wieder den Befehl 'schau' aus. Das hat sich
in der Praxis einfach so ergeben und bewährt. ]]</script>
			<command></command>
			<keyCode>-1</keyCode>
			<keyModifier>0</keyModifier>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-1</name>
				<packageName></packageName>
				<script></script>
				<command>spaehe sw</command>
				<keyCode>49</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-2</name>
				<packageName></packageName>
				<script></script>
				<command>spaehe s</command>
				<keyCode>50</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-3</name>
				<packageName></packageName>
				<script></script>
				<command>spaehe so</command>
				<keyCode>51</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-4</name>
				<packageName></packageName>
				<script></script>
				<command>spaehe w</command>
				<keyCode>52</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-5</name>
				<packageName></packageName>
				<script></script>
				<command>schau</command>
				<keyCode>53</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-6</name>
				<packageName></packageName>
				<script></script>
				<command>spaehe o</command>
				<keyCode>54</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-7</name>
				<packageName></packageName>
				<script></script>
				<command>spaehe nw</command>
				<keyCode>55</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-8</name>
				<packageName></packageName>
				<script></script>
				<command>spaehe n</command>
				<keyCode>56</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-9</name>
				<packageName></packageName>
				<script></script>
				<command>spaehe no</command>
				<keyCode>57</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
		</KeyGroup>
	</KeyPackage>
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
