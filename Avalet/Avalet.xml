<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>OnReconnect</name>
			<script>-- reconnect
-- Dieser Trigger lÃ¶st einen Event aus, wenn der Char Statue war.
-- Also nicht neu eingeloggt wurde, sondern "reconnected".
raiseEvent("afterReconnectEvent")</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^Verwende alten Koerper...$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>AvaletTriggerFuerTimer</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
		</TriggerGroup>
		<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Raetsel</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Foersterquest</name>
				<script>--[[

alias suche tue b boden, u boden, b laub, u laub, b gras, u gras, b nadeln, u nadeln, b unterholz, u unterholz

Treteisen:
untersuche nadeln
Fallgrube:
untersuche gras
Giftpfeil:
untersuche unterholz
Drahtschlinge:
untersuche nadeln
Stolperdraht:
untersuche boden/untersuche erde
Fangnetz:
b gras  (NOCH TESTEN!)
Schlinge:
untersuche laub
]]</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Treteisen</name>
					<script>-- gefunden durch: untersuche nadeln
sendAll("tue b erhebung, u erhebung, b erde, u erde, b metall, b zacken, z zacken, b treteisen, u treteisen, entschaerfe treteisen")
--sendAll("b erhebung", "u erhebung", "b erde", "u erde", "b metall", "b zacken", "z zacken", "b treteisen", "u treteisen", "entschaerfe treteisen")
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>2</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Ueberall auf dem Boden und um einige der Baumstaemme herum siehst Du</string>
						<string>Tannennadeln liegen. An einer Erhebung liegen etwas mehr Nadeln.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>3</integer>
						<integer>3</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Fallgrube</name>
					<script>-- wird gefunden durch: untersuche grass
send("tue b abdeckung, u abdeckung, b fallgrube, u fallgrube, zerstoere fallgrube")
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>2</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Ein paar der Bueschel sind so angeordnet, als waeren sie eine Abdeckung</string>
						<string>fuer irgendetwas.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>3</integer>
						<integer>3</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Giftpfeil</name>
					<script>-- wird gefunden durch: untersuche unterholz
send("ute b efeuranke, u efeuranke, b faden, u faden, b vorrichtung, entschaerfe vorrichtung")
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>2</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Du untersuchst das Unterholz etwas genauer und dabei faellt Dir eine</string>
						<string>Efeuranke auf, die bestimmt nicht normal gewachsen ist.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>3</integer>
						<integer>3</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Drahtschlinge</name>
					<script>-- wird gefunden durch: untersuche nadeln
-- Messer muss vorhanden sein!
send("tue denk messer vorhanden?, b baumstamm, u baumstamm, b draht, u draht, b schlinge, zerschneide schlinge")
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>2</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Bei genauerer Betrachtung der Tannennadeln faellt Dir auf, dass an einem</string>
						<string>Baumstamm recht viele Nadeln liegen.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>3</integer>
						<integer>3</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Stolperdraht</name>
					<script>-- wird gefunden durch: untersuche boden/untersuche erde
-- Klingenwaffe muss vorhanden sein.
send("tue denk messer vorhanden?, b efeuranke, u efeuranke, b draht, u draht, zerschneide draht")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>2</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Bei genauerer Untersuchung des Bodens faellt Dir eine Efeuranke auf, die</string>
						<string>besonders gerade ueber den Boden waechst.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>3</integer>
						<integer>3</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Fangnetz TEST</name>
					<script>-- wird gefunden durch: b gras
send("denk hier ist das fangnetz, da bin ich bisher reingefallen. viel glueck!")
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>3</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>transparent</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Kleine Grasbueschel, die hier und da auf dem Waldboden wachsen, hier sogar</string>
						<string>kreisfoermig. Anscheinend fressen die scheuen Tiere des Waldes nicht immer</string>
						<string>das ganze Gras, was hier waechst.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>3</integer>
						<integer>3</integer>
						<integer>3</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="yes" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Schlinge</name>
					<script>-- wird gefunden durch: u laub
send("tue denk Schlinge! Messer wird benoetigt., b haufen, u haufen, b fasern, u fasern, b schlinge, zerschneide schlinge")
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>2</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Ueberall auf dem Boden liegt Laub herum, aber an einer Stelle auf dem Boden</string>
						<string>siehst Du etwas mehr davon auf einem kleinen Haufen liegen.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>3</integer>
						<integer>3</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
		</TriggerGroup>
		<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Spiele</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Murmelspiel</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
			</TriggerGroup>
		</TriggerGroup>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Alkohol</name>
			<script>--[[Da der Alkohol-Zustand des Chars nicht per ATCP Ã¼bertragen wird,
    versuche ich es mal auf die umstÃ¤ndliche Weise: per Trigger.]]
    
--[[
Reihenfolge von stark zu schwach:
Du hast einen maechtigen Rausch.
Du bist betrunken.
Du hast einen Schwips.
Du bist angeheitert.
Du fuehlst eine leichte Klarheit im Kopf. (--&gt; nÃ¼chtern)
Du verspuerst ploetzlich furchtbare Kopfschmerzen.
Du bist wieder nuechtern.
]]
    
str = matches[1]
if player.alk == nil then player.alk = "Du bist nuechtern." end

player.alk = "Du bist nuechtern."

if str == "Die Welt dreht sich um Dich." then
  player.alk = str
elseif str == "Du bist sternhagelvoll." then
  player.alk = str
elseif str == "Du hast einen maechtigen Rausch." then
  player.alk = str
elseif str == "Du bist betrunken." then
  player.alk = str
elseif str == "Du hast einen Schwips." then
  player.alk = str
elseif str == "Du bist angeheitert." then
  player.alk = str
elseif str == "Du bist wieder nuechtern." then
  player.alk = "Du bist wieder nuechtern."
elseif str == "Du fuehlst eine leichte Klarheit im Kopf." then
  player.alk = "Du bist nuechtern."
elseif str == "Deine Kopfschmerzen verschwinden." then
  player.alk = "Du bist nuechtern."
else
  --cecho("\nUnbehandelt im Avalet-Trigger Alkohol" .. matches[1].. "\n")
end</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#55007f</mFgColor>
			<mBgColor>#55ff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>Die Welt dreht sich um Dich.</string>
				<string>Du bist sternhagelvoll.</string>
				<string>Du hast einen maechtigen Rausch.</string>
				<string>Du bist betrunken.</string>
				<string>Du hast einen Schwips.</string>
				<string>Du bist angeheitert.</string>
				<string>Du bist wieder nuechtern.</string>
				<string>Du fuehlst eine leichte Klarheit im Kopf.</string>
				<string>Du verspuerst ploetzlich furchtbare Kopfschmerzen.</string>
				<string>Furchtbare Schmerzen jagen durch Deinen Kopf.</string>
				<string>Deine Kopfschmerzen verschwinden.</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>3</integer>
				<integer>3</integer>
				<integer>3</integer>
				<integer>3</integer>
				<integer>3</integer>
				<integer>3</integer>
				<integer>3</integer>
				<integer>3</integer>
				<integer>3</integer>
				<integer>3</integer>
				<integer>3</integer>
			</regexCodePropertyList>
		</Trigger>
	</TriggerPackage>
	<TimerPackage>
		<Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>avaletTimersTimer</name>
			<script>-- Timer-Timer
-- Dieser Mudlet-Timer sorgt dafÃ¼r, dass die Anzeige der Avalet-Timer
-- aktualisiert wird. Die hier sekÃ¼ndlich aufgerufene Funktion sorgt dafÃ¼r,
-- dass ggf. die Reihenfolge der Timer geÃ¤ndert wird, dass die Schriftfarbe
-- die Restlaufzeit wiedergibt und dass der Fortschrittsbalken aktualisiert wird.
avalonUI.refreshTimer()</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:01.000</time>
		</Timer>
		<Timer isActive="yes" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>ATCP-Update</name>
			<script>-- ATCP-Update
-- Manche Informationen werden von ATCP nicht automatisch verschickt. Beispielsweise
-- werden der Hunger- und der Durst-Status nicht aktualisiert, wenn der Char isst
-- oder trinkt. Und die Anzeige des Alters auf der OberflÃ¤che ist natÃ¼rlich auch nicht
-- aktuell. Ich setz hier deshalb mal alle 15 Sekunden eine manuelle aktualisierung. 
-- Mal sehen, ob sich das bewÃ¤hrt.
_ = sendATCP("ava_req_update")</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:15.000</time>
		</Timer>
	</TimerPackage>
	<AliasPackage>
		<Alias isActive="yes" isFolder="no">
			<name>ausloggen</name>
			<script>-- logout
-- Dieses Alias soll ausgelÃ¶st werden, wenn der Spieler den
-- Charakter richtig ausloggt. Aber NICHT, wenn er Statue wird.
-- Der hier ausgelÃ¶ste Event rÃ¤umt dann hauptsÃ¤chlich Daten ab, damit
-- die nÃ¤chste Session sauber beginnt. (Session-EP, Chat-Tabs)
send(matches[1])
raiseEvent("logoutEvent")
</script>
			<command></command>
			<packageName></packageName>
			<regex>^(ende|ende hier|einschlafen|schlaf ein|schlafe ein)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>Laufrichtung</name>
			<script>-- Laufrichtung
-- Hier wollte ich sicherlich dafÃ¼r sorgen, dass die Laufrichtung auch dann erfasst wird,
-- wenn der Spieler tatsÃ¤chlich das Laufen richtig austippt. TODO
send(matches[1])
</script>
			<command></command>
			<packageName></packageName>
			<regex>^(norden|sueden|osten|westen|nordost|suedost|suedwest|nordwest|nordosten|suedosten|suedwesten|nordwesten)$</regex>
		</Alias>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<Script isActive="yes" isFolder="no">
			<name>Avalet init</name>
			<packageName></packageName>
			<script>-- init
-- Das Modul Avalet wird im Wesentlichen Ã¼ber eine Funktion initialisiert, die durch den 
-- "sysInstall"-Event aufgerufen wird. Diese Funktion findet sich unter "View --&gt; buildUI".
-- Eine zweite Funktion, die dann ausgefÃ¼hrt wird, findet sich hier weiter unten.

--cecho("&lt;magenta&gt;Avalet init ...\n")

CSSMan = CSSMan or {}
avalonUI = avalonUI or {}


character = character or {}
player = player or {}

avalonUI.chats = avalonUI.chats or {}

-- Speicherort des Moduls. Wird zu:
-- C:/Users/&lt;usrdir&gt;/Documents/Avalet/Avalet.mpackage
modulePath = getModulePath("Avalet")

-- Speicherort des geladenen Profils. Wird zu:
-- C:/Users/&lt;usrdir&gt;/.config/mudlet/profiles/&lt;Profilname&gt;
mudletHomeDir = getMudletHomeDir()

local readFileFromFS = function(path, mode)
  debugc("readFileFromFS()")

  local data = {}
  local file = io.open (path, mode)
  data = yajl.to_value(file:read())
  file:close()
  return data
end

local writeDataToFS = function(path, data, mode)
  debugc("writeDataToFS()")
  
  local file = io.open (path, mode)
  file:write(yajl.to_string(data))
  file:flush()
  file:close()
  return true
end


characterFilePath = characterFilePath or ""
function avalonUI.loadCharacterFileFromDisk(charName)
	--debugc("function loadCharacterFileFromDisk(charName)")
  
  -- Trennzeichen sind abhÃ¤ngig vom Betriebssystem
  if string.char(getMudletHomeDir():byte()) == "/" then _sep = "/" else  _sep = "\\" end
  
  characterFilePath = getMudletHomeDir() .. _sep .. "AvaletCharacter" .. string.title(charName) .. ".json"
  
  -- Hier werden Leerzeichen im Pfad mit einem "\" maskiert, um Probleme unter
  -- Linux zu beheben. Scheint zu funktionieren. Alternativ mÃ¼sste man das mit
  -- AnfÃ¼hrungszeichen um den Pfad rum lÃ¶sen.
  if _sep == "/" then string.gsub(characterFilePath, " ", "\ ") end
  
  if io.exists(characterFilePath) then
    -- Die Tabelle der geladenen Daten wird mit der Player-Tabelle gemerged
    subset = readFileFromFS(characterFilePath, "r")
    for k,v in pairs(subset) do
      if k ~= "loginIsReconnect" then
        --cecho("&lt;magenta&gt;k: " .. tostring(k) .. "\n")
        player[k] = v 
      end
    end
  else
    --cecho("&lt;magenta&gt;Charakter-Datei nicht gefunden fÃ¼r: " .. charName .. "\n")
    writeDataToFS(characterFilePath, player, "w")
  end
end

-- function loadCharacterSettingsFromDisk(charName)
--[[Eigentlich wÃ¼rde ich hier "Profil-Settings" behandeln. Aber da gibt es ja noch den User-Wunsch, mehrere Chars
    im gleichen Profil spielen zu kÃ¶nnen. Also muss es innerhalb eines Profils die MÃ¶glichkeit geben, verschiedene
    Chars auch verschieden zu konfigurieren. (Beispiel: unterschiedliche Hintergrundfarben)]]
characterSettingsPath = characterSettingsPath or ""
avaletCharacterSettingsPrefix = "AvaletCharacterSettings"
function avalonUI.loadCharacterSettingsFromDisk(charName)
  debugc("function loadCharacterSettingsFromDisk(charName): " .. charName)
  
	if string.char(getMudletHomeDir():byte()) == "/" then _sep = "/" else  _sep = "\\" end
  
  characterSettingsPath = getMudletHomeDir() .. _sep .. avaletCharacterSettingsPrefix .. string.title(charName) .. ".json"
  
  -- Das hier ist der Versuch, ein Problem mit Leerzeichen im Pfad unter Linux zu lÃ¶sen.
  -- Indem das Leerzeichen mit einem "\" maskiert wird. Alternativ mÃ¼sste man das mit 
  -- AnfÃ¼hrungszeichen um den Pfad rum lÃ¶sen.
  if _sep == "/" then string.gsub(characterFilePath, " ", "\ ") end
  
--	if io.exists(characterFilePath) then
		--cecho("&lt;magenta&gt;Charakter-Datei ist vorhanden, versuche Datei zu laden:\n" .. characterFilePath .. "\n")
    -- merge 2 tables
--    subset = readFileFromFS(characterSettingsPath, "r")
--    for k,v in pairs(subset) do player[k] = v end
		--player = readFileFromFS(characterFilePath, "r")
		--echo("...done\n")
--	else
	  --cecho("&lt;magenta&gt;Charakter-Datei nicht gefunden fÃ¼r: " .. charName .. "\n")
		--echo("Erzeuge Character-Objekt\n")
		--player = Character()
		--echo("...done\n")
--		writeDataToFS(characterSettingsPath, player, "w")
--	end  
  return
end


characterChatsPath = characterChatsPath or ""
function avalonUI.loadCharacterChatsFromDisk(charName)
  debugc("function loadCharacterChatsFromDisk")
  
  if string.char(getMudletHomeDir():byte()) == "/" then _sep = "/" else  _sep = "\\" end
  
  characterChatsPath = getMudletHomeDir() .. _sep .. "AvaletChats" .. string.title(charName) .. ".json"
  
  -- Leerzeichen im Pfad maskieren fÃ¼r Linux-Systeme 
  if _sep == "/" then string.gsub(characterChatsPath, " ", "\ ") end
  
  if io.exists(characterChatsPath) then
    subset = readFileFromFS(characterChatsPath, "r")
    for k,v in pairs(subset) do avalonUI.chats[k] = v end
  else
    writeDataToFS(characterChatsPath, avalonUI.chats, "w")
  end
end



-- function loadVersionInformation()
function avalonUI.loadVersionInformation()
  --local versionFilePath = getMudletHomeDir().. .."/Avalet/version"
  -- TODO
  return

end -- function loadVersionInformation()


-- function initPlayer(name)
-- Wenn nach dem Start von Mudlet der Name des angemeldeten Charakters per ATCP
-- ERSTMALS Ã¼bertragen wird, kann dieses Modul die Charakter-abhÃ¤ngigen Teile
-- initialisieren. Also im Grunde alles auÃer das, was Avalet selbst betrifft.
-- Diese Funktion wird sowohl nach einem echten login als auch nach einem
-- reconnect ausgefÃ¼hrt!
function avalonUI.initPlayer(name)
  debugc("Funktion initPlayer aufgerufen mit Parameter: " .. name)

  -- Settings des Chars laden
  avalonUI.loadCharacterSettingsFromDisk(name)

  -- Charakterdaten laden
  avalonUI.loadCharacterFileFromDisk(name)
  -- Unterscheiden zwischen einem reconnect und einem echten login:
  -- (Den echten Login zu erkennen geht leider nicht. Was bei einem
  -- echten login vorhanden sein soll, muss man beim echten logout
  -- weiter unten setzen.)
  if not player.loginIsReconnect then
    --cecho("&lt;magenta&gt;\nes ist _kein_ reconnect: "..tostring(player.ep).."\n")
    player.sessionEP = tonumber(player.ep)
  end

  -- Chat-VerlÃ¤ufe laden
  avalonUI.loadCharacterChatsFromDisk(name)
  -- Nachdem die Inhalte der Chat-Tabs geladen wurden, muss das aktuelle
  -- Tab-Element noch aktualisiert werden.
  --cecho("&lt;magenta&gt;\nAktualisierung des aktuellen Chat-Tabs?\n")
  raiseEvent("RefreshTabElement", GUIModel.tabElement.currentTab)
end --function initPlayer(name)



-- Function: onKeyPadEvent
-- fuer das Laufen per Keypad, und fuer das Catchen
-- der letzten Bewegung fuer den Mapper
-- und fuer das automatische Schwimmen/ Klettern
-- Dieser Event wird jedesmal ausgelÃ¶st, wenn eine Taste des Ziffernblocks verwendet wird.
-- Das ist unter "Keybindings" bzw. "Tasten" so definiert.
function avalonUI.onKeyPadEvent(eventName,key,tDirections)
  tDirections = {"sw","s","so","w","sc","o","nw","n","no","h","r","rein","raus"}
  player.lastMove = tDirections[key]
  --tPlayer.sLastMoveDirection=tDirections[key]
  send(tDirections[key],false)
--	if bAutoSchwimmen == true then
--		send("schwimm "..tDirections[key],false)
--		--send("b karte")
--	else
--		send(tDirections[key],false)
--		--send("b pflanzen")
--	end
end --function onKeyPadEvent
registerAnonymousEventHandler("keyPadEvent", "avalonUI.onKeyPadEvent")



-- Der "sysConnectionEvent" ist ein Standard-Event von Mudlet.
-- Er wird ausgelÃ¶st, wenn eine Verbindung zum MUD besteht. Aber davon
-- abgesehen kann man hier noch nicht viel machen: ATCP funktioniert
-- hier noch nicht, ein Charakter ist noch nicht verfÃ¼gbar (noch nicht
-- angemeldet), ...
function avalonUI.onSysConnectionEvent()
  debugc("function onSysConnectionEvent()")
  return  
end
registerAnonymousEventHandler("sysConnectionEvent", "avalonUI.onSysConnectionEvent")


-- Der "sysExitEvent" ist ein Standard-Event von Mudlet.
-- Er wird ausgelÃ¶st, wenn Mudlet das Profil schlieÃt.
function avalonUI.onSysExitEvent()
	debugc("onSysExitEvent")

  -- Sichere Charakter-Daten. Das ist hier vielleicht Ã¼berflÃ¼ssig,
  -- weil es durch den "sysDisconnectionEvent" schon geschieht.
  -- Deshalb testweise auskommentiert.
  if player.name ~= "" then
    --writeDataToFS(characterFilePath, player, "w")
  end
end
registerAnonymousEventHandler("sysExitEvent", "avalonUI.onSysExitEvent")


-- Der Event "sysDisconnectionEvent" ist ein Standard-Event von Mudlet.
-- Er wird ausgelÃ¶st, wenn die Verbindung zum MUD abreisst. Das kann sowohl
-- durch ein logout geschehen als auch durch jeden anderen Verbindungs-
-- abbruch.
function avalonUI.onSysDisconnectionEvent()
  debugc("onSysDisconnectionEvent()")
  
  -- Hier wird vorsorglich der Wert gesetzt, der bei der nÃ¤chsten Verbindungs-
  -- aufnahme ausgewertet wird. VOR dieser Auswertung wird der Wert aber noch-
  -- mal Ã¼berschrieben, wenn diese Verbindungsaufnahme ein "reconnect" ist.
  player.loginIsReconnect = false
  
  writeDataToFS(characterFilePath, player, "w")
  writeDataToFS(characterChatsPath, avalonUI.chats, "w")
end
registerAnonymousEventHandler("sysDisconnectionEvent", "avalonUI.onSysDisconnectionEvent")


-- Dieses Event wird ausgelÃ¶st, wenn der Spieler den Charakter richtig ausloggt,
-- also mit "schlafe ein" etc. AusgelÃ¶st wird dieses Event durch ein Alias auf
-- die Befehle, mit denen das Ausloggen mÃ¶glich ist. AuÃer ich hab einen vergessen.
-- Derzeit: ^(ende|ende hier|einschlafen|schlaf ein|schlafe ein)$
function avalonUI.onLogoutEvent()
	debugc("onLogoutEvent()")

  -- Die Basis, auf der die Session-EP berechnet werden, wird hier schon mal fÃ¼r die
  -- nÃ¤chste Session gesetzt.
  -- Das geschieht neuerdings beim Login nochmal, und damit die Anzeige im UI nach dem
  -- logout noch den Wert der dann grade beendeten Session zeigt, ist das hier erstmal
  -- auskommentiert. Testweise. TODO
  --player.sessionEP = tonumber(player.ep)
  
  -- der nÃ¤chste Login wird zwangslÃ¤ufig ein "richtiger" login sein, kein reconnect
  player.loginIsReconnect = false

  -- Bei einem richtigen logout werden die ChatTab-VerlÃ¤ufe gelÃ¶scht:
  -- TODO: evtl. konfigurierbar machen, die BeschrÃ¤nkung auf (derzeit) 500 Zeilen
  -- setzt ja auch schon eine Grenze.
  for k,v in pairs(GUIModel.tabElement.tabs) do

    avalonUI.chats[v] = {}
    
  end

end
registerAnonymousEventHandler("logoutEvent", "avalonUI.onLogoutEvent")



-- afterReconnectEvent wird durch einen Trigger auf "Verwende alten Koerper..." ausgelÃ¶st.
-- Das ist notwendig, da das MUD bei einem Reconnect die ATCP-Daten nicht erneut schickt.
function avalonUI.afterReconnectEvent()
  debugc("afterReconnectEvent()")
  --cecho("&lt;magenta&gt;\nab jetzt ist es ein reconnect\n")
  --debugc("ab jetzt ist es ein reconnect")
  player.loginIsReconnect = true
  -- "sendATCP" gibt "true" zurÃ¼ck, und das wird unter UmstÃ¤nden im Hauptfenster
  -- ausgegeben. AuÃer man speichert es in einer Variable wie zum Beispiel "_".
  _ = sendATCP("ava_req_update")
end
registerAnonymousEventHandler("afterReconnectEvent", "avalonUI.afterReconnectEvent")



-- Func: fsysProtocolEnabled
-- Ich hab versucht, hier auch auf "GMCP" zu prÃ¼fen und eine
-- Warnung auszugeben. Aber offenbar wird GMCP nicht wie die
-- anderen Protokolle aktiviert, ich hatte jedenfalls keinen
-- AuslÃ¶ser des "elseif", trotz aktiviertem GMCP. TODO
function avalonUI.onSysProtocolEnabled(event,arg)
	debugc("&lt;red&gt;onSysProtocolEnabled() running at this point.\n")
	if arg =="ATCP" then
		--echo("ATCP Support aktiviert.\n")
		sendATCP("ava_set_mapper",1)
		sendATCP("ava_set_channel",1)
		sendATCP("ava_set_comm",1)
		sendATCP("ava_set_rcomm",1)
		sendATCP("ava_set_soul",1)
		sendATCP("ava_set_rsoul",1)
		--sendATCP("ava_set_soundpack",1)
		sendATCP("ava_req_update",1)
		sendATCP("ava_req_graphics_status",1)
	elseif arg=="GMCP" then
		debugc("&lt;red&gt;GMCP ist offenbar aktiviert. So wird Avalet nicht funktionieren.\nBitte GMXP in den Einstellungen deaktivieren und neu starten.")
	else
		--echo("Support fuer "..arg.." ist aktiv.\n")
	end
end
registerAnonymousEventHandler("sysProtocolEnabled", "avalonUI.onSysProtocolEnabled")



-- function onSysInstall
-- Wird ausgefÃ¼hrt nach der Installation eines Moduls oder eines Paketes.
-- Dazu wird ein EventHandler fÃ¼r das entsprechende Mudlet-Event registriert.
-- Hier muss zunÃ¤chst geschaut werden, ob der Event auch Avalet betrifft. 
-- AnschlieÃend findet hier Modul-Initialisierung statt.
-- Avalet:    setModulePriority("Avalet", 1)
-- SubModule: priority &gt; 2, vorher prÃ¼fen ob avalet installiert ist
function avalonUI.onSysInstall(_, name)
  debugc("function onSysInstall()")
  -- Erstmal prÃ¼fen, ob es Avalet ist, was da installiert wurde:
  if name ~= "Avalet" then return end
  
  -- FÃ¼r eine vernÃ¼nftige Versionierung bzw. fÃ¼r einen irgendwie gearteten
  -- Update-Mechanismus muss Avalet etwas Ã¼ber die eigene Versionsnummer wissen.
  avalonUI.loadVersionInformation()

  -- Die Modul-PrioritÃ¤t von Avalet wird auf 1 gesetzt, um spÃ¤ter Submodule mit
  -- einer niedrigeren PrioritÃ¤t ausstatten zu kÃ¶nnen. Das sollte dazu fÃ¼hren,
  -- dass die Submodule NACH Avalet installiert werden. (Das ist aber ungetestet
  -- und ich sehe auch nicht, wie das gehen kann. Wenn ich die PrioritÃ¤t erst
  -- NACH der installation setzen kann... Vermutlich also ein TODO.)  
  setModulePriority("Avalet", 1)
  
  --	Nach einem Reconnect braucht Avalet den Charakternamen. Nach einem normalen
  -- Login wird der sehr schnell per ATCP gesendet. Nach einem reconnect (Statue)
  -- aber nicht. Der Trigger, der hier erzeugt wird, reagiert auf "Verwende alten 
  -- Koerper..." und lÃ¶st dann einen Event aus, der ein ATCP-Update vom Server
  -- anfordert. Damit kommt dann auch der Charaktername.
  if not exists("OnReconnect", "trigger") then
    luaCode = [[raiseEvent("afterReconnectEvent")]]
    permRegexTrigger("OnReconnect", "Avalet", {"^Verwende alten Koerper\.\.\.$"}, luaCode)
  end
end -- function onSysInstall
registerAnonymousEventHandler("sysInstall", "avalonUI.onSysInstall")


-- function onSysUninstall(_, name)
-- Diese Funktion soll ausgefÃ¼hrt werden, wenn Avalet deinstalliert wird.
-- Deshalb wird hier ein EventHandler fÃ¼r das onSysUninstall-Event registriert.
-- In der Funktion muss dann noch geschaut werden, ob das auch Avalet ist,
-- was deinstalliert wurde.
-- Die Funktion wird grad nicht verwendet, aber das wird sich sicher noch Ã¤ndern.
function avalonUI.onSysUninstall(_, name)
  --debugc("function onSysUninstall()")
  -- Erstmal prÃ¼fen, ob es Avalet ist, was da deinstalliert wurde:
  if name ~= "Avalet" then return end

end -- function onSysUninstall(_, name)
registerAnonymousEventHandler("sysUninstall", "avalonUI.onSysUninstall")


-- sysInstallPackage - Standard-Event von Mudlet
-- Avalet funktioniert nicht, wenn es als Paket installiert wird - nur als Modul!
-- Deshalb hier die Fehlermeldung
function avalonUI.onSysInstallPackage(_, name)
  debugc("function onSysInstallPackage()")
  -- Erstmal prÃ¼fen, ob es Avalet ist, was da installiert wurde:
  if name ~= "Avalet" then return end
  
  cecho("\n\n&lt;magenta&gt;!!!    ACHTUNG: Avalet wurde als Paket installiert!    !!!\n")
  cecho(    "&lt;magenta&gt;!!!        Avalet funktioniert als Paket nicht.        !!!\n")
  cecho(    "&lt;magenta&gt;!!!    Avalet muss jetzt erst deinstalliert werden!    !!!\n")
  cecho(    "&lt;magenta&gt;!!! Anschliessend Avalet bitte als MODUL installieren! !!!\n\n")
  
end
registerAnonymousEventHandler("sysInstallPackage", "avalonUI.onSysInstallPackage")
</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Frameworks</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>Jor'Mox's GUIframe</name>
				<packageName></packageName>
				<script>-- Jor'Mox's GUIframe Script
-- 3/07/2019
-- v1.4.2
-- To resize frames or move tabs, right click and drag either the resize label or the tab
-- until the desired result is achieved.
-- To add a window to a frame for the script to manage, use the
-- GUIframe.addWindow(window, name, container, hideText) function, where the window
-- variable contains the Geyser object you want to add, the name variable contains
-- the name you want it to be referred to as, which also is used as the text printed
-- on the associated tab that is created, the container variable is a string containing
-- one of the following: bottom, top, topleft, topright, bottomleft, bottomright,
-- and the hideText variable is an optional boolean which, if true, prevents text being
-- written on the tab for this window.
-- To remove a window from GUIframe, use the GUIframe.removeWindow(name, container)
-- function, where the name variable is the same name you gave the window when adding it,
-- and the optional container variable is a string specifying which container to remove
-- the window from. If no container is specified, the window is removed regardless of
-- which container it is in.
-- Resizing of frames can be enabled or disabled using the GUIframe.enable(side) and
-- GUIframe.disable(side, hide) functions respectively. If the second argument to
-- GUIframe.disable is false, then the entire set of frames on that side is hidden, and
-- the border is adjusted as if that side had be resized to zero.
-- To save and load settings, use the GUIframe.saveSettings() and
-- GUIframe.loadSettings(redraw) functions. If the redraw argument is true, the border
-- background color is changed to black to force the area of the borders to be redrawn.
-- Additionally, the GUIframe.reinitialize() function can be used to force the script to
-- initialize itself again, going back to default settings.
-- To activate a tab without it being clicked, use the GUIframe.activate(name) function.
-- And to apply a stylesheet to a tab that is different from the default stylesheet, use
-- the GUIframe.styleTab(name, style) function, where the style variable contains a string
-- with the CSS to be applied. Since tabs are styled only when created or when this
-- function is used, there should be no concern with this styling being overwritten.
GUIframe = GUIframe or {}
local mainW, mainH = getMainWindowSize()
local halfW, halfH = math.floor(mainW / 2), math.floor(mainH / 2)
GUIframe.configs = GUIframe.configs or {}
GUIframe.defaults =
  {
    tabHeight = 20,
    tabStyle =
      [[
        background-color: green;
        border-width: 2px;
        border-style: outset;
        border-color: limegreen;
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
        margin-right: 1px;
        margin-left: 1px;
        qproperty-alignment: 'AlignCenter | AlignCenter';]],
    tabEchoStyle = '&lt;center&gt;&lt;p style="font-size:14px; color:white"&gt;',
    leftStartWidth = 50,
    leftStartHeight = halfH,
    rightStartWidth = 50,
    rightStartHeight = halfH,
    topStartHeight = 50,
    bottomStartHeight = 50,
    resizeHeight = 30,
    resizeWidth = 30,
    resizeHoverImage = "/imgs/blue_arrows.png",
    resizeRestImage = "/imgs/blue_arrows_20t.png",
    borderOffset = 5,
  }
GUIframe.windows = GUIframe.windows or {}
GUIframe.tabs = GUIframe.tabs or {}
GUIframe.tabCoords = GUIframe.tabCoords or {}
GUIframe.sides =
  GUIframe.sides or {left = 'enabled', right = 'enabled', top = 'enabled', bottom = 'enabled'}
local resize_style = "border-image: url(%s%s);"
local configs = table.update(GUIframe.defaults, GUIframe.configs)
local tabsInfo, containerInfo, resizeInfo
local container_names =
  {
    'topLeftContainer',
    'bottomLeftContainer',
    'topRightContainer',
    'bottomRightContainer',
    'bottomContainer',
    'topContainer',
  }
local tab_names =
  {'topLeftTabs', 'topRightTabs', 'bottomLeftTabs', 'bottomRightTabs', 'midLeftTabs'}
local resizeLabels = {'resizeLeft', 'resizeRight', 'resizeTop', 'resizeBottom'}
local sides = {"top", "bottom", "left", "right"}
local side_containers =
  {
    left = {"topLeftContainer", "bottomLeftContainer", "topLeftTabs", "bottomLeftTabs"},
    right = {"topRightContainer", "bottomRightContainer", "topRightTabs", "bottomRightTabs"},
    top = {"topContainer"},
    bottom = {"bottomContainer"},
  }

local function get_window_coords(win, update)
  -- gets coords for window, stores data in tabCoords table as needed
  local x, y = win:get_x(), win:get_y()
  local w, h = win:get_width(), win:get_height()
  if update then
    GUIframe.tabCoords[win.name] = {x = x, y = y, w = w, h = h}
  end
  return x, y, w, h
end

local function check_overlap(tab, x, y)
  -- checks to see if given coords overlap tab or tab container
  if type(tab) == "string" then
    tab = GUIframe[tab] or GUIframe.tabs[tab]
  end
  if tab.hidden or tab.auto_hidden then
    return false
  end
  local info = GUIframe.tabCoords[tab.name]
  local x1, y1 = info.x, info.y
  local x2, y2 = x1 + info.w, y1 + info.h
  return (x &gt;= x1 and x &lt;= x2 and y &gt;= y1 and y &lt;= y2)
end

local function update_tab(tab, x, y, w, h)
  -- resizes and moves tab and updates tab coords table
  tab:move(x, y)
  tab:resize(w, h)
  local info = GUIframe.tabCoords[tab.name] or {}
  info.x, info.y = tab:get_x(), tab:get_y()
  info.w, info.h = tab:get_width(), tab:get_height()
  if table.contains(tab_names, tab.name) then
    info.container = true
  end
  GUIframe.tabCoords[tab.name] = info
end

local function get_containers(pos)
  if type(pos) == "table" then
    pos = pos.name
  end
  for _, w in ipairs({'right', 'left', 'container', 'tabs'}) do
    pos = pos:gsub(w, w:title())
  end
  local con, tab
  if string.find(pos, "Container") then
    con = GUIframe[pos]
    if not con then
      return
    end
    tabs = con.tabs
  elseif string.find(pos, "Tabs") then
    tabs = GUIframe[pos]
    if not tab then
      return
    end
    con = tabs.con
  else
    con = GUIframe[pos .. "Container"]
    tabs = GUIframe[pos .. "Tabs"]
  end
  return con, tabs
end

local function config()
  configs = table.update(GUIframe.defaults, GUIframe.configs)
  GUIframe.windows = {}
  GUIframe.tabCoords = {}
  tabsInfo =
    {
      topLeftTabs =
        {
          name = 'topLeftTabs',
          x = 0,
          y = 0,
          width = configs.leftStartWidth,
          height = configs.tabHeight,
        },
      bottomLeftTabs =
        {
          name = 'bottomLeftTabs',
          x = 0,
          y = configs.leftStartHeight,
          width = configs.leftStartWidth,
          height = configs.tabHeight,
        },
      topRightTabs =
        {
          name = 'topRightTabs',
          x = mainW - configs.rightStartWidth,
          y = 0,
          width = configs.rightStartWidth,
          height = configs.tabHeight,
        },
      bottomRightTabs =
        {
          name = 'bottomRightTabs',
          x = mainW - configs.rightStartWidth,
          y = configs.rightStartHeight,
          width = configs.rightStartWidth,
          height = configs.tabHeight,
        },
    }
  containerInfo =
    {
      topLeftContainer =
        {
          name = 'topLeftContainer',
          x = 0,
          y = configs.tabHeight,
          width = configs.leftStartWidth,
          height = configs.leftStartHeight - configs.tabHeight,
        },
      bottomLeftContainer =
        {
          name = 'bottomLeftContainer',
          x = 0,
          y = configs.leftStartHeight + configs.tabHeight,
          width = configs.leftStartWidth,
          height = configs.leftStartHeight - configs.tabHeight,
        },
      topRightContainer =
        {
          name = 'topRightContainer',
          x = mainW - configs.rightStartWidth,
          y = configs.tabHeight,
          width = configs.rightStartWidth,
          height = configs.rightStartHeight - configs.tabHeight,
        },
      bottomRightContainer =
        {
          name = 'bottomRightContainer',
          x = mainW - configs.rightStartWidth,
          y = configs.rightStartHeight + configs.tabHeight,
          width = configs.rightStartWidth,
          height = configs.rightStartHeight - configs.tabHeight,
        },
      bottomContainer =
        {
          name = 'bottomContainer',
          x = configs.leftStartWidth,
          y = mainH - configs.bottomStartHeight,
          height = configs.bottomStartHeight,
          width = mainW - configs.leftStartWidth - configs.rightStartWidth,
        },
      topContainer =
        {
          name = 'topContainer',
          x = configs.leftStartWidth,
          y = 0,
          height = configs.topStartHeight,
          width = mainW - configs.leftStartWidth - configs.rightStartWidth,
        },
    }
  resizeInfo =
    {
      resizeLeft =
        {
          name = 'resizeLeft',
          x = configs.leftStartWidth,
          y = configs.leftStartHeight - configs.resizeHeight / 2,
          height = configs.resizeHeight,
          width = configs.resizeWidth,
        },
      resizeRight =
        {
          name = 'resizeRight',
          x = configs.rightStartWidth - configs.resizeWidth,
          y = configs.rightStartHeight - configs.resizeHeight / 2,
          height = configs.resizeHeight,
          width = configs.resizeWidth,
        },
      resizeTop =
        {
          name = 'resizeTop',
          x = halfW - configs.resizeWidth / 2,
          y = configs.topStartHeight,
          height = configs.resizeHeight,
          width = configs.resizeWidth,
        },
      resizeBottom =
        {
          name = 'resizeBottom',
          x = halfW - configs.resizeWidth / 2,
          y = mainH - configs.bottomStartHeight - configs.resizeHeight,
          height = configs.resizeHeight,
          width = configs.resizeWidth,
        },
    }
  for name, cons in pairs(containerInfo) do
    GUIframe[name] = Geyser.Container:new(cons)
  end
  for name, cons in pairs(tabsInfo) do
    GUIframe[name] = Geyser.Container:new(cons)
    local cname = name:gsub("Tabs", "Container")
    GUIframe[cname].tabs = GUIframe[name]
    GUIframe[name].con = GUIframe[cname]
  end
  local style = resize_style
  local path = getMudletHomeDir()
  path = path:gsub("[\\/]", "/")
  configs.resizeRestImage = configs.resizeRestImage:gsub("[\\/]", "/")
  configs.resizeHoverImage = configs.resizeHoverImage:gsub("[\\/]", "/")
  local no_image
  if
    not (io.exists(path .. configs.resizeHoverImage) and io.exists(path .. configs.resizeRestImage))
  then
    debugc("GUIframe: config: resize image(s) not found")
    path = "255,20,147,"
    style = "background-color: rgba(%s%s);"
    no_image = true
  end
  for name, cons in pairs(resizeInfo) do
    GUIframe[name] = Geyser.Label:new(cons)
    GUIframe[name]:setColor(0, 0, 0, 0)
    GUIframe[name]:setStyleSheet(
      string.format(style, path, (no_image and "100") or configs.resizeRestImage)
    )
    GUIframe[name]:setOnEnter(
      "GUIframe." .. name .. ".setStyleSheet",
      GUIframe[name],
      string.format(style, path, (no_image and "255") or configs.resizeHoverImage)
    )
    GUIframe[name]:setOnLeave(
      "GUIframe." .. name .. ".setStyleSheet",
      GUIframe[name],
      string.format(style, path, (no_image and "100") or configs.resizeRestImage)
    )
    GUIframe[name]:setClickCallback("GUIframe.buttonClick", name)
    GUIframe[name]:setReleaseCallback("GUIframe.buttonRelease", name)
    GUIframe[name]:setMoveCallback("GUIframe.buttonMove", name)
  end
  setBorderLeft(configs.leftStartWidth + configs.borderOffset)
  setBorderRight(configs.rightStartWidth + configs.borderOffset)
  setBorderTop(configs.topStartHeight + configs.borderOffset)
  setBorderBottom(configs.bottomStartHeight + configs.borderOffset)
  GUIframe.initialized = true
end

local function deselectContainer(container, tabs)
  -- hide all windows in container
  for _, win in pairs(container.windowList) do
    win:hide()
    win.active = false
  end
  -- unhighlight all tabs in tabs container
  if tabs then
    for _, tab in pairs(tabs.windowList) do
      local name = tab.name:gsub("Tab", "")
      local show = GUIframe.windows[name].showText
      if show then
        tab:echo(configs.tabEchoStyle .. name)
      end
    end
  end
end

local function adjustTabs(tabs)
  if not GUIframe.initialized then
    error("GUIframe not initialized", 2)
  end
  -- remove duplicated window names
  local found = {}
  for k, v in ipairs(tabs.windows) do
    if not table.contains(found, v) and tabs.windowList[v] and not tabs.windowList[v].isClicked then
      table.insert(found, v)
    end
  end
  -- calculate tab width and set height
  local w, h = math.floor(100 / #tabs.windows), configs.tabHeight

  local function wrap(num)
    return tostring(num) .. "%"
  end

  -- resize and reposition all tabs
  local shown, first
  for k, v in ipairs(found) do
    local tab = tabs.windowList[v]
    if not first then
      first = v:gsub("Tab", "")
    end
    if not shown and tab.active then
      shown = v
    elseif tab.active then
      tab.active = false
    end
    update_tab(tab, wrap(w * (k - 1)), 0, wrap(w), h)
  end
  if first and not shown and GUIframe.windows[first] then
    GUIframe.windows[first]:show()
  end
  tabs.space_pos = nil
end

local function reorderTabs(tabs, name, pos)
  local windows = tabs.windows
  while table.contains(windows, name) do
    table.remove(windows, table.index_of(windows, name))
  end
  table.insert(windows, pos, name)
end

local function makeSpace(tabs, tab, pos)
  if not GUIframe.initialized then
    error("GUIframe not initialized", 2)
  end
  local windows = table.deepcopy(tabs.windows)
  local space_pos = tabs.space_pos
  local tab_pos = table.index_of(windows, tab.name)
  -- calculate tab width and set height
  local num_tabs = #windows + 1
  if tab_pos then
    num_tabs = num_tabs - 1
    if pos &gt; tab_pos then
      pos = pos - 1
    end
    if pos == space_pos then
      pos = pos + 1
    end
  elseif space_pos and pos &gt;= space_pos then
    pos = pos + 1
  end
  local w, h = math.floor(100 / num_tabs), configs.tabHeight

  local function wrap(num)
    return tostring(num) .. "%"
  end

  -- resize and reposition all tabs
  if tab_pos then
    table.remove(windows, tab_pos)
  end
  for k, v in ipairs(windows) do
    if k &gt;= pos then
      update_tab(tabs.windowList[v], wrap(w * k), 0, wrap(w), h)
    else
      update_tab(tabs.windowList[v], wrap(w * (k - 1)), 0, wrap(w), h)
    end
  end
  tabs.space_pos = pos
end

local function round(num, roundTo)
  local b, r = math.modf(num / roundTo)
  if r &gt;= 0.5 then
    b = b + 1
  end
  return b * roundTo
end

local function setBorder(side, val)
  local funcs =
    {left = setBorderLeft, right = setBorderRight, top = setBorderTop, bottom = setBorderBottom}
  val = math.max(val, 0)
  funcs[side](val)
end

local function resizeContainers(side, w, h)
  if table.contains({"left", "right"}, side) then
    local info =
      {
        left =
          {
            resize = "resizeLeft",
            cons = {"topLeftContainer", "bottomLeftContainer"},
            tabs = {"topLeftTabs", "bottomLeftTabs"},
            x = 0,
            w = w,
          },
        right =
          {
            resize = "resizeRight",
            cons = {"topRightContainer", "bottomRightContainer"},
            tabs = {"topRightTabs", "bottomRightTabs"},
            x = w,
            w = mainW - w,
          },
      }
    info = info[side]
    -- move and resize top, bottom and tab containers
    update_tab(GUIframe[info.tabs[1]], info.x, 0, info.w, configs.tabHeight)
    update_tab(GUIframe[info.tabs[2]], info.x, h, info.w, configs.tabHeight)
    GUIframe[info.cons[1]]:resize(info.w, h - configs.tabHeight)
    GUIframe[info.cons[1]]:move(info.x, configs.tabHeight)
    GUIframe[info.cons[2]]:resize(info.w, mainH - h - configs.tabHeight)
    GUIframe[info.cons[2]]:move(info.x, h + configs.tabHeight)
    -- adjust border size
    setBorder(side, info.w + configs.borderOffset)
    -- adjust width of top and bottom containers
    local x, y
    x = (GUIframe.sides.left ~= "hidden" and GUIframe.topLeftContainer:get_width()) or 0
    w = ((GUIframe.sides.right ~= "hidden" and GUIframe.topRightContainer:get_x()) or mainW) - x
    for _, con in ipairs({GUIframe.topContainer, GUIframe.bottomContainer}) do
      y, h = con:get_y(), con:get_height()
      con:resize(w, h)
      con:move(x, y)
    end
  elseif table.contains({"top", "bottom"}, side) then
    local x = 0
    w = mainW
    if GUIframe.sides.left ~= "hidden" then
      w = w - GUIframe.topLeftContainer:get_width()
      x = GUIframe.topLeftContainer:get_width()
    end
    if GUIframe.sides.right ~= "hidden" then
      w = w - GUIframe.topRightContainer:get_width()
    end
    local info =
      {
        top = {con = "topContainer", y = 0, h = h},
        bottom = {con = "bottomContainer", y = h, h = mainH - h},
      }
    local con = GUIframe[info[side].con]
    con:resize(w, info[side].h)
    con:move(x, info[side].y)
    setBorder(side, info[side].h + configs.borderOffset)
  end
end

local function refresh()
  if not GUIframe.initialized then
    error("GUIframe not initialized", 2)
  end
  mainW, mainH = getMainWindowSize()
  local rH, rW = configs.resizeHeight, configs.resizeWidth
  local x, y, w
  -- adjust bottom left and right container heights
  for _, C in ipairs({GUIframe.bottomLeftContainer, GUIframe.bottomRightContainer}) do
    C:resize(C:get_width(), mainH - C:get_y())
  end
  -- reposition right containers
  w = GUIframe.topRightContainer:get_width()
  for
    _, C in
      ipairs(
        {
          GUIframe.topRightContainer,
          GUIframe.topRightTabs,
          GUIframe.bottomRightContainer,
          GUIframe.bottomRightTabs,
        }
      )
  do
    C:move(mainW - w, C:get_y())
  end
  -- resize and reposition bottom and top containers
  w, x = mainW, 0
  if GUIframe.sides.left ~= "hidden" then
    w = w - GUIframe.topLeftContainer:get_width()
    x = GUIframe.topLeftContainer:get_width()
  end
  if GUIframe.sides.right ~= "hidden" then
    w = w - GUIframe.topRightContainer:get_width()
  end
  for _, C in ipairs({GUIframe.topContainer, GUIframe.bottomContainer}) do
    C:resize(w, C:get_height())
    C:move(x, C.name == "topContainer" and 0 or mainH - C:get_height())
  end
  -- reposition resize labels
  x, y = GUIframe.topLeftContainer:get_width(), GUIframe.bottomLeftTabs:get_y()
  GUIframe.resizeLeft:move(x, y - rH / 2)
  x, y = GUIframe.topRightContainer:get_x(), GUIframe.bottomRightTabs:get_y()
  GUIframe.resizeRight:move(x - rW, y - rH / 2)
  x = (GUIframe.topContainer:get_width() - rW) / 2
  if GUIframe.sides.left ~= "hidden" then
    x = x + GUIframe.topLeftContainer:get_width()
  end
  y = GUIframe.topContainer:get_height()
  GUIframe.resizeTop:move(x, y)
  y = GUIframe.bottomContainer:get_y()
  GUIframe.resizeBottom:move(x, y - rH)
end

-- enables the resize label for the given side and shows all associated containers if hidden

function GUIframe.enable(side)
  if not GUIframe.initialized then
    error("GUIframe not initialized", 2)
  end
  if not table.contains(sides, side) then
    error("GUIframe.enable: invalid side", 2)
  end
  local cons = side_containers[side]
  for _, con in ipairs(cons) do
    GUIframe[con]:show()
    for _, win in pairs(GUIframe[con].windowList) do
      -- loop can be removed after Geyser fix comes in
      if win.active then
        win:show()
      end
    end
  end
  if table.contains({"left", "right"}, side) then
    setBorder(side, GUIframe[cons[1]]:get_width() + configs.borderOffset)
  else
    setBorder(side, GUIframe[cons[1]]:get_height() + configs.borderOffset)
  end
  GUIframe["resize" .. side:title()]:show()
  GUIframe.sides[side] = "enabled"
  refresh()
end

-- disables and hides the resize label for the given side, and hides all associated containers if indicated

function GUIframe.disable(side, hide)
  if not GUIframe.initialized then
    error("GUIframe not initialized", 2)
  end
  if not table.contains(sides, side) then
    error("GUIframe.disable: invalid side", 2)
  end
  local cons = side_containers[side]
  GUIframe.sides[side] = "disabled"
  if hide then
    for _, con in ipairs(cons) do
      GUIframe[con]:hide()
      for _, win in pairs(GUIframe[con].windowList) do
        -- loop can be removed after Geyser fix comes in
        if win.type == "mapper" then
          win:hide()
        end
      end
    end
    local border = _G["setBorder" .. side:title()]
    border(0)
    GUIframe.sides[side] = "hidden"
  end
  GUIframe["resize" .. side:title()]:hide()
  refresh()
end

-- adds a Geyser window or container to the given container, with a tab showing the given name if applicable

function GUIframe.addWindow(window, name, container, hideText)
  if not GUIframe.initialized then
    config()
  end
  if type(container) == "table" then
    container = container.name
  end
  local con, tabs = get_containers(container)
	if not window then
		error("GUIframe.addWindow: invalid window", 2)
	end
  if not con then
    error("GUIframe.addWindow: invalid container name", 2)
  end
  if not name then
    error("GUIframe.addWindow: name argument required", 2)
  end
  -- remove window from any containers
  for _, tcon in ipairs(container_names) do
    if table.contains(GUIframe[tcon].windows, window.name) then
      GUIframe.removeWindow(name, tcon)
    end
  end
  deselectContainer(con, tabs)
  -- add tab for window, if applicable
  if tabs then
    local showText = not hideText
    window.showText = showText
    local lbl =
      Geyser.Label:new({name = name .. "Tab", x = 0, y = 0, width = 10, height = 10}, tabs)
    lbl:setStyleSheet(configs.tabStyle)
    if showText then
      lbl:echo(configs.tabEchoStyle .. "&lt;b&gt;" .. name)
    end
    lbl:setClickCallback("GUIframe.buttonClick", name)
    lbl:setReleaseCallback("GUIframe.buttonRelease", name)
    lbl:setMoveCallback("GUIframe.buttonMove", name)
    GUIframe.tabs[name] = lbl
    adjustTabs(tabs)
  end
  -- add window to container and set size and position
  con:add(window)
  window:resize("100%", "100%")
  window:move(0, 0)
  window:show()
  GUIframe.windows[name] = window
  raiseEvent("sysWindowResizeEvent")
end

-- removes a named Geyser window or container from the named container (using name given in GUIframe.addWindow)

function GUIframe.removeWindow(name, container)
  if not GUIframe.initialized then
    error("GUIframe not initialized", 2)
  end
  if not container then
    container = GUIframe.windows[name].container
  end
  local con, tabs = get_containers(container)
  if not con or not table.contains(container_names, con.name) then
    error("GUIframe.removeWindow: invalid container name", 2)
  end
  if not name then
    error("GUIframe.removeWindow: name argument required", 2)
  end
  if tabs then
    local lbl = tabs.windowList[name .. "Tab"]
    if lbl then
      tabs:remove(lbl)
      adjustTabs(tabs)
      lbl:hide()
    end
  end
  local window = GUIframe.windows[name]
  con:remove(window)
  window:hide()
end

-- saves the current GUI setup, including the size of the different containers and what windows go in which container

function GUIframe.saveSettings()
  if not GUIframe.initialized then
    error("GUIframe not initialized", 2)
  end
  local saveTbl = {}
  local w, h = GUIframe.topLeftContainer:get_width(), GUIframe.bottomLeftTabs:get_y()
  saveTbl.left = {w = w, h = h}
  w, h = GUIframe.topRightContainer:get_width(), GUIframe.bottomRightTabs:get_y()
  saveTbl.right = {w = w, h = h}
  w, h = GUIframe.topContainer:get_width(), GUIframe.topContainer:get_height()
  saveTbl.top = {w = w, h = h}
  w, h = GUIframe.bottomContainer:get_width(), GUIframe.bottomContainer:get_height()
  saveTbl.bottom = {w = w, h = h}
  -- get added windows and containers they are assigned to
  local windows = {}
  local text = {}
  for k, v in pairs(GUIframe.windows) do
    local con = v.container.name
    windows[con] = windows[con] or {}
    table.insert(windows[con], k)
    text[con] = text[con] or {}
    text[con][k] = v.showText
  end
  -- reorder windows to match tab order for tabbed containers
  for con, wins in pairs(windows) do
    if con:find("Left") or con:find("Right") then
      local tabs = GUIframe[con].tabs.windows
      local new = {}
      for k, v in ipairs(tabs) do
        local wname = v:gsub("Tab", "")
        table.insert(new, {wname, text[con][wname]})
      end
      windows[con] = new
    end
  end
  saveTbl.windows = windows
  saveTbl.sides = GUIframe.sides
  table.save(getMudletHomeDir() .. "/GUIframeSave.lua", saveTbl)
end

-- loads GUI setup from a previous save

function GUIframe.loadSettings(redraw)
  if not GUIframe.initialized then
    error("GUIframe not initialized", 2)
  end
  local saveTbl = {}
  local path = getMudletHomeDir() .. "/GUIframeSave.lua"
  path = path:gsub("\\", "/")
  mainW, mainH = getMainWindowSize()
  if not io.exists(path) then
    debugc("GUIframe.loadSettings: save file doesn't exist.")
    return
  end
  table.load(path, saveTbl)
  resizeContainers("left", saveTbl.left.w, saveTbl.left.h)
  resizeContainers("right", mainW - saveTbl.right.w, saveTbl.right.h)
  resizeContainers("top", saveTbl.top.w, saveTbl.top.h)
  resizeContainers("bottom", saveTbl.bottom.w, mainH - saveTbl.bottom.h)
  for con, wins in pairs(saveTbl.windows) do
    for _, name in ipairs(wins) do
      if type(name) == "string" then
        GUIframe.addWindow(GUIframe.windows[name], name, con)
      else
        local n, s = name[1], not name[2]
        GUIframe.addWindow(GUIframe.windows[n], n, con, s)
      end
    end
  end
  for side, state in pairs(saveTbl.sides) do
    if state == "enabled" then
      GUIframe.enable(side)
    elseif state == "disabled" then
      GUIframe.disable(side, false)
    elseif state == "hidden" then
      GUIframe.disable(side, true)
    end
  end
  -- force redraw of screen
  if redraw then
    setBackgroundColor(1, 1, 1)
    setBackgroundColor(0, 0, 0)
  end
end

-- can be called to force the script to run its config function again

function GUIframe.reinitialize()
  config()
end

-- can be called to activate a given tab without clicking on it

function GUIframe.activate(name)
  if not GUIframe.initialized then
    error("GUIframe not initialized", 1)
  end
  local window = GUIframe.windows[name]
  if window then
    local con, tabs = get_containers(window.container.name)
    -- hide and unhighlight other windows and tabs
    deselectContainer(con, tabs)
    -- show selected window
    window:show()
    window.active = true
    -- highlight selected tab
    if window.showText then
      GUIframe.tabs[name]:echo(configs.tabEchoStyle .. "&lt;b&gt;" .. name)
    end
  end
end

-- can be called to apply a style to a given tab

function GUIframe.styleTab(name, style)
  if not GUIframe.initialized then
    error("GUIframe not initialized", 1)
  end
  local tab = GUIframe.tabs[name]
  if tab then
    tab:setStyleSheet(style)
  end
end

-- internally used function to handle button click callbacks

function GUIframe.buttonClick(name, event)
  if not GUIframe.initialized then
    error("GUIframe not initialized", 2)
  end
  if table.contains(resizeLabels, name) then
    if event.button == "RightButton" then
      local lbl = GUIframe[name]
      lbl.difX, lbl.difY = event.x, event.y
      lbl.savedX, lbl.savedY = getMousePosition()
      GUIframe[name].isClicked = true
    end
  elseif event.button == "LeftButton" then
    local window = GUIframe.windows[name]
    local con, tabs = get_containers(window.container.name)
    -- hide and unhighlight other windows and tabs
    deselectContainer(con, tabs)
    -- show selected window
    window:show()
    window.active = true
    -- highlight selected tab
    if window.showText then
      GUIframe.tabs[name]:echo(configs.tabEchoStyle .. "&lt;b&gt;" .. name)
    end
  elseif event.button == "RightButton" then
    local window, tab = GUIframe.windows[name], GUIframe.tabs[name]
    tab.savedX, tab.savedY = getMousePosition()
    tab.difX, tab.difY, tab.isClicked = event.x, event.y, true
    -- force update of coords for all tabs and tab containers
    GUIframe.tabCoords = {}
    for _, name in ipairs(tab_names) do
      get_window_coords(GUIframe[name], true)
      for tname, tab in pairs(GUIframe[name].windowList) do
        get_window_coords(tab, true)
      end
    end
  end
  raiseEvent("GUIframe.buttonClick", name, event)
end

-- internally used function to handle button release callbacks

function GUIframe.buttonRelease(name, event)
  if not GUIframe.initialized then
    error("GUIframe not initialized", 2)
  end
  if table.contains(resizeLabels, name) then
    if event.button == "RightButton" then
      local lbl = GUIframe[name]
      lbl.savedX, lbl.savedY, lbl.difX, lbl.difY, lbl.isClicked = nil, nil, nil, nil, false
    end
  elseif event.button == "RightButton" then
    local window, tab = GUIframe.windows[name], GUIframe.tabs[name]
    local con, tabs = get_containers(window.container.name)
    tab.difX, tab.difY, tab.savedX, tab.savedY, tab.isClicked = nil, nil, nil, nil, false
    hideWindow("show_container")
    for _, tname in ipairs(tab_names) do
      local info = GUIframe[tname]
      if info.mouse_over then
        local pos = info.space_pos
        info.mouse_over = nil
        GUIframe.addWindow(window, name, tname:gsub("Tabs", ""), not window.showText)
        if pos then
          reorderTabs(info, tab.name, pos)
          adjustTabs(info)
        end
      end
    end
    adjustTabs(tabs)
  end
  raiseEvent("GUIframe.buttonRelease", name, event)
end

-- internally used function to handle button move callbacks

function GUIframe.buttonMove(name, event)
  if not GUIframe.initialized then
    error("GUIframe not initialized", 2)
  end
  if table.contains(resizeLabels, name) then
    lbl = GUIframe[name]
    if lbl.isClicked then
      local w, h = getMousePosition()
      w, h = round(w - lbl.difX, 10), round(h - lbl.difY, 10)
      mainW, mainH = getMainWindowSize()
      local side, cW, cH, rX, rY
      local minX = GUIframe.sides.left ~= "hidden" and GUIframe.topLeftContainer:get_width() or 0
      local maxX = GUIframe.sides.right ~= "hidden" and GUIframe.topRightContainer:get_x() or mainW
      local minY = GUIframe.sides.top ~= "hidden" and GUIframe.topContainer:get_height() or 0
      local maxY = GUIframe.sides.left ~= "hidden" and GUIframe.bottomContainer:get_y() or mainH
      local mid, min, max = GUIframe.topContainer:get_width(), math.min, math.max
      local tabH, rH, rW = configs.tabHeight, configs.resizeHeight, configs.resizeWidth
      w, h = max(w, 0), max(h, 0)
      -- specify position of resize labels and size of containers
      local info =
        {
          resizeLeft =
            {
              side = "left",
              x = min(w, maxX - rW),
              y = min(max(h + rH / 2, tabH), mainH - tabH) - rH / 2,
              w = min(w, maxX - rW),
              h = min(max(h + rH / 2, tabH), mainH - tabH),
            },
          resizeRight =
            {
              side = "right",
              x = min(max(w, minX), mainW),
              y = min(max(h + rH / 2, tabH), mainH - tabH) - rH / 2,
              w = min(max(w, minX), mainW - rW) + rW,
              h = min(max(h + rH / 2, tabH), mainH - tabH),
            },
          resizeTop =
            {
              side = "top",
              x = minX + (mid - rW) / 2,
              y = min(h, maxY - rH),
              w = maxX - minX,
              h = min(h, maxY - rH),
            },
          resizeBottom =
            {
              side = "bottom",
              x = minX + (mid - rW) / 2,
              y = min(max(h, minY) - rH, mainH),
              w = maxX - minX,
              h = min(max(h, minY) + rH, mainH),
            },
        }
      info = info[name]
      lbl:move(info.x, info.y)
      resizeContainers(info.side, info.w, info.h)
    end
  else
    local window, tab = GUIframe.windows[name], GUIframe.tabs[name]
    local con, tabs = get_containers(window.container.name)
    local x, y = getMousePosition()
    local over_con, over_tab
    if tab and tab.isClicked then
      moveWindow(tab.name, x - tab.difX, y - tab.difY)
      -- check to see if mouse is over any tab containers
      for _, tcon in ipairs(tab_names) do
        if check_overlap(tcon, x, y) then
          over_con = tcon
          GUIframe[tcon].mouse_over = true
          local info = GUIframe.tabCoords[tcon]
          local tx, ty, tw, th = info.x, info.y, info.w, info.h
          createLabel("show_container", 0, 0, 0, 0, 1)
          moveWindow("show_container", tx, ty)
          resizeWindow("show_container", tw, th)
          setLabelStyleSheet(
            "show_container",
            [[
                        background-color: black;
                        border: 2px solid white;]]
          )
          showWindow("show_container")
          lowerWindow("show_container")
          -- check to see if mouse is over any tabs
          for tname, info in pairs(GUIframe.tabs) do
            if tname ~= name and check_overlap(info, x, y) then
              over_tab = info.name
              local windows = GUIframe[tcon].windows
              local index = table.index_of(windows, over_tab)
              makeSpace(GUIframe[tcon], tab, index)
              break
            end
          end
          break
        end
      end
      -- remove any unnecessary spaces in tab containers
      for _, name in ipairs(tab_names) do
        if name ~= over_con then
          adjustTabs(GUIframe[name])
          GUIframe[name].mouse_over = nil
        end
      end
    end
  end
  raiseEvent("GUIframe.buttonMove", name, event)
end

-- internally used function to handle sysWindowResizeEvent

function GUIframe.eventHandler(event, ...)
  if event == "sysWindowResizeEvent" and GUIframe.initialized then
    refresh()
  end
end

registerAnonymousEventHandler("sysWindowResizeEvent", "GUIframe.eventHandler")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>CSSMan</name>
				<packageName></packageName>
				<script>-- CSSMan by Vadi. Public domain.

CSSMan = {}
CSSMan.__index = CSSMan

function CSSMan.new(stylesheet)
  local obj  = { stylesheet = {} }
  setmetatable(obj,CSSMan)
  local trim = string.trim

  assert(type(stylesheet) == "string", "CSSMan.new: no stylesheet provided. A possible error is that you might have used CSSMan.new, not CSSMan:new")

  for line in stylesheet:gmatch("[^\r\n]+") do
    local attribute, value = line:match("^(.-):(.-);$")
    if attribute and value then
      attribute, value = trim(attribute), trim(value)
      obj.stylesheet[attribute] = value
    end
  end

  return obj
end

function CSSMan:set(key, value)
  self.stylesheet[key] = value
end

function CSSMan:get(key)
  return self.stylesheet[key]
end

function CSSMan:getCSS(key)
  local lines, concat = {}, table.concat
  for k,v in pairs(self.stylesheet) do lines[#lines+1] = concat({k,": ", v, ";"}) end
  return concat(lines, "\n")
end

function CSSMan:gettable()
  return self.stylesheet
end

function CSSMan:settable(tbl)
  assert(type(tbl) == "table", "CSSMan:settable: table expected, got "..type(tbl))

  self.stylesheet = tbl
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Logging</name>
				<packageName></packageName>
				<script>-- Das Ziel des Avalet-Loggers ist, eine MÃ¶glichkeit zu haben, aus verschiedenen
-- Quellen Ausgaben in verschiedene Dateien umzuleiten. Um diese dann optional in den
-- Tabs auf der OberflÃ¤che anzeigen zu kÃ¶nnen.
-- Quellen fÃ¼r diese Ausleitung sind beispielsweise: 
-- --&gt; Trigger
-- --&gt; ATCP
-- --&gt; Logging-Ausgaben im Code fÃ¼r Debugging und Error-Logging im Betrieb
-- Und zwar vorzugsweise sowohl aus Avalet heraus als auch durch eventuelle
-- Sub-Module.
-- Funktionen sind also:
-- --&gt; Eine Datei angeben zu kÃ¶nnen, die innerhalb des Profils gespeichert wird,
--     und in die dann die Logausgaben irgendwie in geschickter Weise (DateigrÃ¶Ãe?)
--     rausgeschrieben werden.
-- --&gt; Einen Tab im Frontend anlegen kÃ¶nnen, in dem die Log-Ausgabe, also der Inhalt
--     der Datei, in einer Mini-Konsole angezeigt wird. (Muss es nicht geben, einfach
--     in eine Datei loggen kÃ¶nnen sollte auch gehen.)
-- --&gt; Aus den verschiedenen Quellen in den entsprechenden Logger reinschreiben zu kÃ¶nnen.
-- --&gt; Ein intelligenter Umgang mit den Dateien und dem verwendeten Speicher.
--
-- Das Logging (inklusive auch von Triggern, Timern etc.) basiert erstmal auf einer
-- Arbeit vom User Wyd aus dem Mudlet-Forum, die ich unter dieser Adresse gefunden habe:
-- https://forums.mudlet.org/viewtopic.php?t=1424
--
-- Anpassungen von Marco Steffens


Logger = Logger or {
		_currFileNum = 0,

		_fileName = nil,

		_keepOpen = {}
}

function Logger:getLogDirectory()
	if string.char(getMudletHomeDir():byte()) == "/" then _sep = "/" else  _sep = "\\" end
	local logdir = getMudletHomeDir() ..  _sep .. "log" .. _sep
  -- Marco Steffens: Es gab Probleme mit Leerzeichen im Pfad unter Linux. 
  -- Das hier ist der Versuch, das Problem zu lÃ¶sen. Indem das Leerzeichen
  -- mit einem "\" maskiert wird. Alternativ mÃ¼sste man das mit AnfÃ¼hrungs-
  -- zeichen um den Pfad rum lÃ¶sen.
  if _sep == "/" then
    string.gsub(logdir, " ", "\ ")
  end
  
	return logdir
end

function Logger:echo(message)
	cecho("\n&lt;red&gt;Logger: ")
	cecho("&lt;white&gt;" .. message)
end

function Logger:Log(file, val, options)
	options = options or Logger.options or {}

	local line = ""
  if table.contains(options, "timestamp") then
		local time_format = "'['dd'.'MM'.'yyyy' - 'hh':'mm':'ss'.'zzz]: "
		line = line .. getTime(true, time_format)
	end

	if table.contains(options, "split") then
		local maxSize = options.split
		self:_checkFileSize(file, maxSize)
	end
	
	local keepopen = table.contains(options, "keepOpen")

	local f
	
	if not self._keepOpen[file] then
		local filename = self:getLogDirectory()  .. file .. ".txt"
		f = io.open(filename, "a+")
		self._keepOpen[file] = f
	else
		f = self._keepOpen[file]
	end

	line = line .. val
	f:write(line .. "\n")

	if not keepopen then
		self:_closeLog(file)
	end
end

function Logger:CloseLog(file)
	if file then
		self:_closeLog(file)
	else
		for f, _ in pairs(self._keepOpen) do
			self:_closeLog(f)
		end
	end
end

function Logger:SearchLog(file, pattern)
	self:_closeLog(file) -- close the log if its open, so we can access it

	local filename = self:getLogDirectory() .. file .. ".txt"
	if not io.exists(filename) then
		self:echo("File '" .. file .. "' does not exist!")
		return
	end

	local counter = 0

	local numBackups = self:_getCurrentFileNumber(file)

	Logger:echo("Searching for '&lt;green&gt;" .. pattern .. "&lt;white&gt;' in file '" .. file .. "'")
	
	local t = 1;
	local lines = 0
	local r = rex.new(pattern)

	while t &lt;= numBackups do
		local bfilename = self:getLogDirectory() .. file .. "." .. tostring(t) .. ".txt"
		local f = io.open(bfilename, "r")

		for line in f:lines() do
			lines = lines + 1
			if r:match(line) then
				cecho("\n&lt;grey&gt;" .. line .. "  &lt;white&gt;(in " .. file .. "." .. tostring(t) .. ".txt)")
				counter = counter + 1
			end
		end

		f:close()

		t = t + 1
	end

	local f = io.open(filename, "r")

	for line in f:lines() do
		lines = lines + 1
		if r:match(line) then
			cecho("\n&lt;grey&gt;" .. line .. "  &lt;white&gt;(in " .. file .. ".txt)")
			counter = counter + 1
		end
	end

	f:close()

	Logger:echo("Term matched " .. counter .. " times in " .. lines .. " lines.")
end

-- HinzugefÃ¼gt von Marco Steffens
function Logger:logFileExists(file)
  self:_closeLog(file) -- close the log if its open, so we can access it
	local filename = self:getLogDirectory() .. file .. ".txt"
	if not io.exists(filename) then
    return false
	else
    return true
  end
end


-- HinzugefÃ¼gt von Marco Steffens
function Logger:ReadLog(file)
	self:_closeLog(file) -- close the log if its open, so we can access it
	debugc("File: "..self:getLogDirectory() .. file .. ".txt\n")
	local filename = self:getLogDirectory() .. file .. ".txt"
	if not io.exists(filename) then
		self:echo("File '" .. file .. "' does not exist!")
		return
	else
		local f = io.open(filename, "r")
		content = ""
    lastdate = ""
		for line in f:lines() do
			if line ~= "" then
				-- "'['dd'.'MM'.'yyyy' - 'hh':'mm':'ss'.'zzz]: "
				-- "[05.04.2020 - 16:45:00.283]: "
				--x = string.gsub("hello world", "%w+", "%0 %0", 1)
				-- ^\[\d{2}\.\d{2}\.\d{4} - (\d{2}:\d{2}:\d{2}).\d{3}\]: (.*)$
				-- "^%[%d{2}%.%d{2}%.%d{4} %- (%d{2}:%d{2}:%d{2})%.%d{3}%]: (.*)$", "[%0]: %1", 1)
				-- %^ITALIC%^schelmisch%^NO_ITALIC%^
        date = string.gsub(line, "^%[(%d+%.%d+%.%d+) %- %d+:%d+:%d+%.%d+%]: .*$", "%1", 1)
        if lastdate ~= date then
          content = content .. "\n\n~~~~~~~~~~~~~~~~~~~~ " .. date .. " ~~~~~~~~~~~~~~~~~~~~\n"
          lastdate = date
        end
				line = string.gsub(line, "^%[%d+%.%d+%.%d+ %- (%d+:%d+:%d+)%.%d+%]: (.*)$", "%1: %2", 1)
				content = content .. "\n" .. line
			end
		end
		return content
	end
end




-- TEST

-- HinzugefÃ¼gt von Marco Steffens
function Logger:ReadLogWithLineLimit()
  --file = "C:/Users/mstef/.config/mudlet/profiles/Ava - Rofhessa - DEV\log\Sagen.txt"
  file = "Sagen"
	self:_closeLog(file) -- close the log if its open, so we can access it
	debugc("File: "..self:getLogDirectory() .. file .. ".txt\n")
	local filename = self:getLogDirectory() .. file .. ".txt"
	if not io.exists(filename) then
		self:echo("File '" .. file .. "' does not exist!")
		return
	else
		local f = io.open(filename, "r")
		content = ""
    
    --f:seek("end",-24)
    --content = f:read("*a")
    
    --content = f:lines()
    lineCounter = 0
 		 for line in f:lines() do 
  			if line ~= "" then
       lineCounter = lineCounter + 1 
      end
--				-- "'['dd'.'MM'.'yyyy' - 'hh':'mm':'ss'.'zzz]: "
--				-- "[05.04.2020 - 16:45:00.283]: "
--				--x = string.gsub("hello world", "%w+", "%0 %0", 1)
--				-- ^\[\d{2}\.\d{2}\.\d{4} - (\d{2}:\d{2}:\d{2}).\d{3}\]: (.*)$
--				-- "^%[%d{2}%.%d{2}%.%d{4} %- (%d{2}:%d{2}:%d{2})%.%d{3}%]: (.*)$", "[%0]: %1", 1)
--				-- %^ITALIC%^schelmisch%^NO_ITALIC%^
--				line = string.gsub(line, "^%[%d+%.%d+%.%d+ %- (%d+:%d+:%d+)%.%d+%]: (.*)$", "%1: %2", 1)
--				content = content .. "\n" .. line
--			end
		  end
    content = tostring(lineCounter)
		return content
	end--if not io.exists(filename) then
end --function Logger:ReadLogWithLineLimit()

--- TEST ENDE





function Logger:LogSection(file, options)
		if self.trigger_id then 
			Logger:echo("Already logging a section. Do Logger:StopLogging() first")
			return
		end

		options = options or {}
		
		if not table.contains(options, "keepOpen") then table.insert(options, "keepOpen") end
		
		local splitSize = 0
		if table.contains(options, "split") then
			splitSize = options.split
			self:_checkFileSize(file, splitSize)
		end

		-- we don't want to pass this on
		options.split = nil

		self:Log(file, "\n\n", {"keepOpen"})
		self:Log(file, "[[[START OF SECTION]]]", {"timestamp", "keepOpen"})

		self.logging_file = file
		self.options = options
		self.trigger_id = tempRegexTrigger(".*", [[ Logger:Log("]] .. file .. [[", matches[1], Logger.options)]])	
		
		if splitSize ~= 0 then
			self.splitSize = splitSize
			enableTimer("Check File Size")
		end
		Logger:echo("Started logging!")
end

function Logger:StopLogging()
	if self.trigger_id then
		killTrigger(self.trigger_id)
		self:_closeLog(self.logging_file)
		self.trigger_id = nil
		self.options = nil
		self.splitSize = 0
		disableTimer("Check File Size")
		self:Log(self.logging_file, "[[[END OF SECTION]]]", {"timestamp"})

		self.logging_file = nil
		Logger:echo("Logging stopped!")
	end
end

function Logger:_checkFileSize(file, maxSize)
	--Check whether our file size is to big
	if self:_getFileSize(file) &gt;= maxSize then
		-- if it is, we need to rename the current file.txt to file.n.text
		self:_closeLog(file)
		local t = self:_getNextFileNumber(file)
		os.rename(self:getLogDirectory() .. file .. ".txt", self:getLogDirectory() .. file .. "." .. t .. ".txt")
	end
end

function Logger:_getFileSize(file)
	local filename = self:getLogDirectory()  .. file .. ".txt"
	local f = io.open(filename, "r")

	if not f then return 0 end
	local size = f:seek("end")    -- get file size
  	
	f:close()
	return size / 1024 -- We want size in kb's, not bytes
end

function Logger:_getCurrentFileNumber(file)
	local t = 1
	local stop = false
	while not stop do
		local filename = self:getLogDirectory() .. file .. "." .. tostring(t) .. ".txt"
		if io.exists(filename) then
			t = t + 1
		else
			stop = true
		end
	end

	self._currFileNum = t - 1

	return self._currFileNum
end

function Logger:_getNextFileNumber(file)
	local current = self:_getCurrentFileNumber(file)
	self._currFileNum = current + 1
	return self._currFileNum
end


function Logger:_closeLog(file)
	if self._keepOpen[file] then
		self._keepOpen[file]:close()
		self._keepOpen[file] = nil
	end
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Misc Functions</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>Utility Functions</name>
				<packageName></packageName>
				<script>-- Hilfsfunktionen
--function readFileFromFS(path, mode)
--	data = {}
--	file = io.open (path, mode)
--	data = yajl.to_value(file:read())
--	file:close()
--	return data
--end
--
--function writeDataToFS(path, data, mode)
--  debugc("\n&lt;magenta&gt;writeDataToFS()\n")
--  debugc("&lt;magenta&gt;path: " .. path .. "\n")
--  --cecho("&lt;magenta&gt;data: " .. tostring(data) .. "\n")
--  --cecho("&lt;magenta&gt;mode: " .. tostring(mode) .. "\n")
--
--	file = io.open (path, mode)
--	file:write(yajl.to_string(data))
--	file:flush()
--	file:close()
--	return true
--end

-- Formats numbers with german thousands seperator
-- Code originally written by Richard Warburton http://richard.warburton.it
function thousands(n)
  local left,num,right = string.match(n,'^([^%d]*%d)(%d*)(.-)$')
  return left..(num:reverse():gsub('(%d%d%d)','%1\.'):reverse())..right
end
</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<Script isActive="yes" isFolder="no">
			<name>CONFIG</name>
			<packageName></packageName>
			<script>avalonUI = avalonUI or {}

--[[Schriftart fÃ¼r die Seiten-Bereiche. "main" bedeutet, dass die Schriftart
des Hauptfensters verwendet wird. (Diese ist einstellbar unter "Settings" --&gt; "Main display".)
Eine Liste der hier einstellbaren Schriftarten wird mit dem Befehl "lua display(getAvailableFonts())"
angezeigt. Ãnderungen erfordern Neustart von Mudlet.]]
avalonUI.font = "main"
--avalonUI.font = "Bitstream Vera Sans Mono"

avalonUI.infoBoxFontSize = 10
avalonUI.chatFontSize = 10
avalonUI.chatTabFontSize = 9


-- Ausrichtung der Timer-Fortschrittsbalken
-- (Ãnderung erst durch Neustart von Mudlet)
avalonUI.timerOrientation = "goofy"      -- fancy! RÃ¼ckschrittsbalken!
--avalonUI.timerOrientation = "horizontal" -- doofe Fortschrittsbalken

--avalonUI.CounterColor = "gold"  -- geht so nicht, wird im css festgelegt
--avalonUI.GaugeFrontColorTimer = "green"
--avalonUI.GaugeFrontColorTimer = "#254b50" --So eine Art Silvergrey
--angeblich harmonisches Farbset:
avalonUI.GaugeFrontColorTimer = "#00575d" --Blue Stone
--avalonUI.GaugeFrontColorTimer = "#00929c" --Persian Green
--avalonUI.GaugeFrontColorTimer = "#66f5ff" --Aquamarine
--avalonUI.GaugeFrontColorTimer = "#993f00" --Brown
--avalonUI.GaugeFrontColorTimer = "#ff6900" --Orange
--avalonUI.GaugeFrontColorTimer = "#ffa566" --Atomic Tangerine

avalonUI.GaugeFrontColorTP = "darkred"
--avalonUI.GaugeFrontColorAP = "darkgoldenrod"
avalonUI.GaugeFrontColorAP = "#a35a00"
avalonUI.GaugeFrontColorZP = "darkblue"
avalonUI.GaugeFrontColorMana = "#4b0082" --war: "purple"
avalonUI.MiniConsoleCenterFontSize = 9
avalonUI.MiniConsoleTabsFontSize = 9


avalonUI.settings = avalonUI.settings or {}
avalonUI.settingsSettings = settingsSettings or {
  isSettingsDialogVisible = false,
  tabs = {"Diverses","Chats-Tabs","Farben","Ãber Avalet"},
  width = 800, -- auch mÃ¶glich: "20%"
  height = 600,
  current = nil,
}
  



avalonUI.CSS = {}

--  background-color: black;
--  border-color: DarkSlateBlue;
--  border-style: double;
--  border-radius: 1px;
--  border-width: 1px;
--  margin: 1px;
--  qproperty-alignment: 'AlignCenter | AlignCenter';
--  display:none;
--  visibility: hidden;
avalonUI.CSS.base = CSSMan.new([[
	background-color: rgba(0,0,0,100);
	border-style: solid;
	border-width: 1px;
	border-radius: 10px;
	border-color: white;
	font: TypeWriter;
	margin-left: 10px;
	margin-right: 10px;
  
]])
  
 -- CSS Boxes
avalonUI.CSS.boxCSS = CSSMan.new([[
	background-color: rgba(0,0,0,100);
	border-style: solid;
	border-width: 1px;
	border-radius: 10px;
	border-color: white;
	font: TypeWriter;
	margin: 10px;
]])

-- CSS Tab-Element ---------------------------------------------

avalonUI.CSS.tabElementFooterCSS = CSSMan.new([[
	background-color: rgb(20,0,20);
	border-bottom-left-radius: 10px;
	border-bottom-right-radius: 10px;
]])

-- Each window actually has two labels. One for the light blue background, and another for the dark blue center. This will create that dark blue center. 
avalonUI.CSS.tabElementCenterCSS = CSSMan.new([[
	background-color: rgba(0,0,0,100);
	border-radius: 10px;
	margin: 5px;
]])

-- Now we create the windows that appear when each tab is clicked. Each window has two labels, one atop the other. The first, which we'll create here, has rounded edges on its bottom. 
avalonUI.CSS.tabElementAtopCSS = CSSMan.new([[
	background-color: rgb(20,0,20);
	border-bottom-left-radius: 10px;
	border-bottom-right-radius: 10px;
]])

-- The second label serves as the window's center and has rounded edges on all sides. And a margin of 5px from it's parent, the label we just created. When adding stuff to your windows, this is the label you'll want to use. menu.&lt;tabname&gt;center
avalonUI.CSS.tabElementCenterTabCSS = CSSMan.new([[
	background-color: rgba(0,0,0,100);
	border-radius: 10px;
	margin: 5px;
]])

-- Hier werden die Tabs und die Seiten dazu erzeugt.
-- Erzeugt einen Tab fÃ¼r jeden Eintrag in der Menu-Liste
-- Stylesheet fÃ¼r jeden Tab
--background-color: ]]..menu.color1..[[;
--background-color: rgb(20,0,20);
avalonUI.CSS.MenuTabCSS = CSSMan.new([[
	background-color: rgb(20,0,20);
	border-style: solid;
	border-width: 1px;
	border-radius: 10px;
	border-color: white;
	border-top-left-radius: 10px;
	border-top-right-radius: 10px;
	margin-right: 1px;
	margin-left: 1px;
]])

avalonUI.CSS.MenuTabCurrentCSS = CSSMan.new([[
	background-color: purple;
	border-style: solid;
	border-width: 1px;
	border-radius: 10px;
	border-color: white;
	border-top-left-radius: 10px;
	border-top-right-radius: 10px;
	margin-right: 1px;
	margin-left: 1px;
]])

avalonUI.CSS.MenuTabMarkedCSS = CSSMan.new([[
	background-color: rgb(50,0,50);
	border-style: solid;
	border-width: 1px;
	border-radius: 10px;
	border-color: white;
	border-top-left-radius: 10px;
	border-top-right-radius: 10px;
	margin-right: 1px;
	margin-left: 1px;
]])

-- CSS Top Menu ------------------------------------------------

--	border-width: 1px;
--	border-color: white;
--	margin: 2px; 
--	border-style: solid;
--	border-radius: 7;
--	padding: 3px;
-- 	qproperty-alignment: 'AlignTop';
avalonUI.CSS.MenuLabelCSS = CSSMan.new([[
	background-color: rgba(0,0,0,100);
	font-weight: bold;
	font-size: 16pt;
	color: white;
]])
--avalonUI.TopMenuOptions:echo([[&lt;p style="font-size:22px"&gt;&lt;b&gt;&lt;font color="white"&gt;&amp;#9881;]])

-- CSS Counter -------------------------------------------------

--background-color: rgb(50,0,50);
--background-color: rgb(98,119,0);
avalonUI.CSS.counterCSS = CSSMan.new([[
	background-color: black;
	border-style: solid;
	border-width: 1px;
	border-radius: 10px;
	border-color: black;
	font: TypeWriter;
	margin: 5px;
]])

-- CSS Gauges --------------------------------------------------

avalonUI.CSS.GaugeBackCSS = CSSMan.new([[
	background-color: rgba(0,0,0,0);
	border-style: solid;
	border-color: white;
	border-width: 1px;
	border-radius: 5px;
	padding: 5px;
	width: 30%;
	height: 80%;
]])

avalonUI.CSS.GaugeFrontCSS = CSSMan.new([[
	background-color: rgba(0,0,0,0);
	border-style: solid;
	border-color: white;
	border-width: 1px;
	border-radius: 5px;
	padding: 5px;
	width: 30%;
	height: 80%;
]])

--	background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #78bd33, stop: 0.1 #6ebd20, stop: 0.49 #4c9900, stop: 0.5 #387000, stop: 1 #4c9900);
avalonUI.CSS.GaugeTextCSS = CSSMan.new([[
	padding: 5px;
	font-weight: bold;
]])

--	background-color: QLinearGradient( x1: 0, y1: 0, x2: 0, y2: 1, stop: 0 #78bd33, stop: 0.1 #6ebd20, stop: 0.49 #4c9900, stop: 0.5 #387000, stop: 1 #4c9900);
avalonUI.CSS.GaugeTimerTextCSS = CSSMan.new([[
	font-weight: bold;
	padding: 50px;
]])
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>initCharacter</name>
			<packageName></packageName>
			<script>--initCharacter()

function avalonUI.initCharacter()

  character = {}
  
  character.name = ""           -- ATCP: AvalonName
  character.vollername = ""     -- ATCP: AvalonVollName
  character.alter = ""          -- ATCP: AvalonAlter
  character.gilde = ""          -- ATCP: AvalonGilde
  character.zuenfte = ""        -- ATCP: AvalonZuenfte
  character.ep = 0             -- ATCP: AvalonEP
  character.level = ""          -- ATCP: AvalonLevel
  character.gesinnung = ""      -- ATCP: AvalonGesinnung
  character.portfolio = ""      -- ATCP: AvalonPortfolio
  character.hunger = ""         -- ATCP: AvalonHunger
  character.durst = ""          -- ATCP: AvalonDurst

  character.alk = ""          -- wird leider nicht Ã¼bertragen
  --
  character.hoehe = ""          -- ATCP: AvalonHoehe
  character.flucht = ""         -- ATCP: AvalonFlucht
  character.schutz = ""         -- ATCP: AvalonSchutz
  character.gruppenname = ""    -- ATCP: AvalonGruppe
  character.zaubern = 0         -- ATCP: AvalonZaubern
  character.kampf = 0           -- ATCP: AvalonKampf
  character.angegriffen = ""    -- ATCP: AvalonAngegriffen
  character.getoetet = ""       -- ATCP: AvalonGetoetet
  character.gruppeGetoetet = "" -- ATCP: AvalonGruppeGetoetet
  character.allyGetoetet = ""   -- ATCP: AvalonAllyGetoetet
  --
  character.stats = character.stats or {}
  character.stats.tp = 0        -- ATCP: AvalonTP
  character.stats.tp_max = 0    -- ATCP: AvalonMAXTP
  character.stats.ap = 0        -- ATCP: AvalonAP
  character.stats.ap_max = 0    -- ATCP: AvalonMAXAP
  character.stats.zp = 0        -- ATCP: AvalonSP
  character.stats.zp_max = 0    -- ATCP: AvalonMAXSP
  character.stats.mp = 0        -- ATCP: AvalonMP
  character.stats.mp_max = 0    -- ATCP: AvalonMAXMP
  --
  character.inventarRein = ""	  -- ATCP: AvalonInventarRein
  character.inventarRaus = ""	  -- ATCP: AvalonInventarRaus
  character.behaelterRein = ""	  -- ATCP: AvalonBehaelterRein
  character.behaelterRaus = ""  -- ATCP: AvalonBehaelterRaus
  character.gefuehrt = ""       -- ATCP: AvalonGefuehrt
  character.gesenkt = ""        -- ATCP: AvalonGesenkt
  character.angezogen = ""      -- ATCP: AvalonAngezogen
  character.ausgezogen = ""     -- ATCP: AvalonAusgezogen
  --
  character.lastMove = ""
  
  character.ep_speicher = ""
  
  character.sessionEP = 0
  
  character.loginIsReconnect = false
  
  character.avalonRoomID = ""
  character.avalonRoomHash = ""
  character.istDunkel = ""
  
  return character
end

</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>initTimer</name>
			<packageName></packageName>
			<script>-- Timer (und Trigger fÃ¼r Timer)
--
-- HINWEIS: Hier geht es um Timer und Trigger. Wenn hier von TRIGGERN geschrieben
-- wird, dann sind die normalen Mudlet-Trigger gemeint. (Die man sich als Spieler
-- anlegt, um nicht immer alles selber tippen zu mÃ¼ssen.) Wenn hier von TIMERN 
-- geschrieben wird, dann sind normalerweise die Timer gemeint, die auf der 
-- OberflÃ¤che von Avalet angezeigt werden! Die die Laufzeit beispielsweise von 
-- SchutzzaubersprÃ¼chen anzeigen. Es sind NICHT die Mudlet-Timer gemeint!
--
-- Hier werden die Daten fÃ¼r die Trigger gesammelt, die letztlich die Timer auf 
-- der OberflÃ¤che erzeugen sollen.
-- In den Funktionen weiter unten werden diese Trigger dann erzeugt. Es gibt (derzeit)
-- vier verschiedene Funktionen, die das tun. Benutzt wird nur eine davon, aber aus 
-- verschiedenen GrÃ¼nden lasse ich die anderen drin. Und zwar:
-- Trigger kÃ¶nnen als "temporÃ¤re" oder als "permantente" Trigger angelegt werden.
-- "TemporÃ¤re" Trigger haben die Eigenschaft, dass sie nicht im Code-Editor (und auch
-- nicht in dieser Datei hier) auftauchen. AuÃerdem werden sie durch einen Neustart
-- von Mudlet gelÃ¶scht und neu erzeugt. Dadurch kann man sie leicht aktualisieren.
-- "Permantente" Trigger stehem in Code-Editor, und kÃ¶nnen so leichter kontrolliert
-- und beim Entwickeln von Avalet auch leichter modifiziert werden. Sie Ã¼berstehen
-- aber einen Neustart von Mudlet, und da man sie auch nicht ohne weiteres per Lua
-- lÃ¶schen kann, ist es sehr viel schwieriger, sie gegebenenfalls zu aktualisieren.
-- Ich habe Funktionen fÃ¼r beides geschrieben, weil ich zum Debuggen die permanenten
-- Trigger verwendet habe, fÃ¼r die ausgelieferte Version von Avalet dann aber wieder
-- auf die temporÃ¤ren Trigger umstelle.
-- AuÃerdem gibt es jeweils eine Funktion, bei der alle Trigger auf ein mal beim Start
-- von Mudlet bzw. bei der Installation von Avalet erzeugt werden. Also die Start- und
-- die Stop-Trigger fÃ¼r die einzelnen Timer. Und es gibt jeweils eine Funktion, bei der
-- NUR die Start-Trigger bei der Installation erzeugt werden. Die dazugehÃ¶rigen STOP-
-- Trigger werden dann erzeugt, wenn der Start-Trigger ausgelÃ¶st wurde. Und dann werden
-- sie als ONE-TIME-Trigger angelegt, lÃ¶schen sich also nach einmaligem AuslÃ¶sen. Das
-- spart rund die HÃ¤lfte der Trigger - und da Trigger die ganze Zeit die Texte mitlesen
--  mÃ¼ssen, spart es Laufzeit. 
-- Es gibt also insgesamt vier Funktionen, mit denen die "Trigger fÃ¼r Timer" erzeugt werden.
-- Verwendet wird aber jeweils nur eine. FÃ¼rs debugging lass ich die anderen hier drin.
-- AuÃerdem: Die Trigger werden in eine Trigger-Group namens "AvaletTriggerFuerTimer"
-- geschrieben. Eigentlich kann man eine solche Group von Lua aus erzeugen und die Trigger
-- dann reinschreiben. Ich hatte dabei aber das Problem, dass die Trigger zwar alle 
-- richtig geschrieben wurden und auch aktiv waren. Die Trigger-Group war aber per default
-- deaktiviert. Wodurch auch die in ihr enthaltenen Trigger nicht funktionierten. Die
-- Trigger-Group war erst nach einem Speichern aktivierbar. Letztlich hab ich die Group
-- dann fest in Avalet reingeschrieben. Damit hat dann alles funktioniert. Also NICHT so:
-- permGroup("AvaletTriggerFuerTimer", "trigger")

-- function avalonUI.initTimer()
-- Hier werden die Daten fÃ¼r die Timer gesammelt, aus denen die Trigger erzeugt werden. Und
-- am Ende dieser Funktion werden sie dann auch erzeugt.
-- Die Trigger werden entweder als temporÃ¤re oder als permanente Trigger erzeugt, aber in 
-- jedem Fall werden sie "RegexTrigger" sein - die Texte, auf denen die Trigger reagieren
-- sollen, mÃ¼ssen also regulÃ¤re AusdrÃ¼cke sein. 
-- AuÃerdem ist es notwendig, die Zeichen zur Maskierung von Sonderzeichen ("\") extra einmal
-- zu maskieren. 
-- Die Angabe einer ["duration"] kann entfallen, der Timer wird dann OHNE Fortschrittsanzeige
-- angezeigt, bis der Stop-Trigger ihn entfernt. (Also die ganze Zeit mit vollen Fortschritts-
-- balken.) In dem Fall ist UNBEDINGT sicher zu stellen, dass das LÃ¶schen des Timers auch
-- wirklich funktioniert! Die Trigger MIT Laufzeit werden ebenfalls durch einen STOP-Trigger
-- entfernt, zusÃ¤tzlich aber auch (derzeit:) 30 Sekunde nach Ende ihrer eingetragenen Laufzeit.
-- Bei den Trigger MIT Laufzeit ist es also mÃ¶glich, auf einen STOP-String zu verzichten. Der
-- muss in dem Fall aber trotzdem hier reingeschrieben werden, und zwar so: ["stop"] = ""
-- Beim HinzufÃ¼gen weiterer Zeilen bitte die alphabetische Sortierung berÃ¼cksichtigen... 
function avalonUI.initTimer()
  
  local timerStrings = {
    --{["name"]="Name", ["start"]="Start-RegExpr",["stop"]="Stop-RegExpr", ["duration"]="600"},
    --{["name"]="Name", ["start"]="Start-RegExpr",["stop"]="", ["duration"]="600"},
    --{["name"]="Name", ["start"]="Start-RegExpr",["stop"]="Stop-RegExpr"},
    {["name"]="Arkanschild", ["start"]="Du wirst von einem Arkanschild umgeben\\.", ["stop"]="Dein Arkanschild loest sich auf\\.", ["duration"]="600"},
    {["name"]="Blaetterhaut", ["start"]="Deine Haut ist nun mit Blaettern bedeckt, die Dir ein angenehmes Klima|Deine Holzhaut ist nun mit Blaettern bedeckt, die Dir ein angenehmes Klima", ["stop"]="Deine Blaetterhaut loest sich auf\\.", ["duration"]="600"},  
    {["name"]="Blutrausch", ["start"]="Du laesst einen fuerchterlichen Urschrei von Dir. Es scheint so, als .*", ["stop"]="Die roetlichen Manawolken loesen sich auf\\.", ["duration"]="600"},
    {["name"]="Daemonenhaut", ["start"]="Du bist nun vollkommen in eine Daemonenhaut eingehuellt\\.", ["stop"]="Deine Daemonenhaut loest sich auf\\.", ["duration"]="600"},
    {["name"]="Erdaura", ["start"]="Du hebst Deine Haende, beschreibst einen Halbkreis.*|Die Partikel verdichten sich um Dich\\.", ["stop"]="Dein Staubschleier loest sich auf\\.", ["duration"]="600"},
    {["name"]="EP-Verdoppelung", ["start"]="^Du bekommst nun eine Zeit lang erhoehte Erfahrung\\.$", ["stop"]="", ["duration"]="3600"},
    {["name"]="Feueraura", ["start"]="Du senkst Deine Haende, aber der Schutz der Manawolken.*", ["stop"]="Deine Feueraura loest sich auf\\.", ["duration"]="600"},
    {["name"]="Feueraura III", ["start"]="Die Manawolken verdichten sich um Dich\\.", ["stop"]="Deine Feueraura loest sich auf\\.", ["duration"]="1200"},
    {["name"]="Friedfertigkeit", ["start"]="Du fuehlst Dich nun .* friedfertig\\.", ["stop"]="Du fuehlst Dich wieder kaempferischer, ungestuemer\\.", ["duration"]="600"},
    {["name"]="Holzhaut", ["start"]="Deine Haut sieht nun hoelzern und sehr widerstandsfaehig aus\\.|Deine Blaetterhaut sieht nun hoelzern und sehr widerstandsfaehig aus\\.|Deine Blaetterhaut fuehlt sich nun recht hoelzern an\\.|Deine Haut fuehlt sich nun recht hoelzern an\\.", ["stop"]="Deine Holzhaut loest sich auf\\.", ["duration"]="600"},
    {["name"]="Kampfbeschwoerung", ["start"]="Du wirst von einer heiligen Aura umgeben\\.",["stop"]="Deine heilige Aura loest sich auf\\.", ["duration"]="600"},
    {["name"]="Kampfeslust", ["start"]="Du bekommst so langsam richtig Lust auf ein kleines Kraeftemessen\\.", ["stop"]="Du fuehlst Dich wieder ruhiger, besonnener\\.", ["duration"]="600"},
    {["name"]="Kampfsegen", ["start"]="Du bist motiviert und willig zu kaempfen\\.", ["stop"]="Deine Motivation und Dein Kampfeswille schwinden\\.", ["duration"]="600"},
    {["name"]="Kernschild", ["start"]="Das Glitzern legt sich als schuetzendes Schild ueber Dich\\.", ["stop"]="Dein Kernschild loest sich auf\\.", ["duration"]="1000"},
    {["name"]="Knochenschild", ["start"]="Du erhebst Dich wieder, der wirbelnde Schild aus Knochen umgibt Dich", ["stop"]="Deine schuetzende Knochenwolke loest sich auf\\.", ["duration"]="600"},
    {["name"]="Lebensaura", ["start"]="Du oeffnest die Augen, aber der Schutz der Bluetenblaetter umgibt Dich", ["stop"]="Deine Lebensaura loest sich auf\\.", ["duration"]="600"},
    {["name"]="Lebenssegen", ["start"]="Du wirst von einem inneren Leuchten erfuellt\\.", ["stop"]="Dein inneres Leuchten erlischt wieder\\.", ["duration"]="600"},
    {["name"]="Licht I", ["start"]="Du erzeugst Dir eine kleine Feuerkugel\\.", ["stop"]="Deine Feuerkugel erlischt\\.", ["duration"]="240"},
    {["name"]="Licht II", ["start"]="Du erzeugst Dir eine kleine Leuchtflamme\\.",["stop"]="Deine Leuchtflamme erlischt\\.", ["duration"]="600"},
    {["name"]="Licht III", ["start"]="Ein grosser Lichtbogen breitet sich ueber Deinem Kopf aus\\.", ["stop"]="Dein Lichtbogen verschwindet\\.", ["duration"]="1200"},
    {["name"]="Luftaura", ["start"]="Du bist in den Watteflocken kaum noch auszumachen\\.", ["stop"]="Deine Watteflocken loesen sich auf\\.", ["duration"]="600"},
    {["name"]="Magieaufladung", ["start"]="Du hast einen Teil Deiner regenerativen Energien in Deine Zauber umgelenkt\\.",["stop"]="Deine Energien fliessen wieder normal\\.", ["duration"]="600"},
    {["name"]="Magiertrance", ["start"]="^Die Welt um Dich herum verliert an Bedeutung. Nur noch Deine Zauber sind$",["stop"]="Du erwachst aus Deiner Trance\\.", ["duration"]="600"},
    {["name"]="Manarausch", ["start"]="Dichte Manawolken bilden nun einen gewaltigen Schutz um Dich herum\\.",["stop"]="Dein Manarausch laesst wieder nach\\."},
    {["name"]="Pflanzenblick", ["start"]="Du siehst die Pflanzen um Dich herum jetzt viel klarer\\.", ["stop"]="Dein besonderer Blick fuer die Pflanzen an Deinem Weg verschwindet wieder\\.", ["duration"]="600"},
    {["name"]="Regenerationssegen", ["start"]="Du wirst von einem warmen Leuchten umgeben\\.", ["stop"]="Das Dich umgebende Leuchten erlischt wieder\\.", ["duration"]="600"},
    {["name"]="Schild", ["start"]="Du wirst von einem magischen Schild umgeben\\.",["stop"]="Dein magischer Schild loest sich auf\\.", ["duration"]="600"},
    {["name"]="Schwarzschild", ["start"]="Du wirst von einem magischen Schild umgeben, der Dich besser parieren",["stop"]="Dein Schwarzschild loest sich auf\\.", ["duration"]="600"},
    {["name"]="Segen", ["start"]="^Das Ankh auf (Deiner|Deinem|den)([a-z ,]*)([A-Za-z\\s]+) beginnt\\, schwach zu( leuchten\\.)?", ["stop"]="(Dein|Deine)([a-z ,]*)([A-z\\s]+) verliert .* magische Kraft.", ["duration"]="600"},
    {["name"]="Steinhaut", ["start"]="Du bist nun vollkommen in eine Steinhaut eingehuellt, .*",["stop"]=".*Du befreist Dich von Deiner Steinhaut.*|.*Deine Steinhaut loest sich auf.*|Das hat Deiner Steinhaut den letzten Rest gegeben, sie loest sich auf\\."},
    {["name"]="Sternenstaub", ["start"]="Du wirst von Sternenstaub umgeben\\.",["stop"]="Dein Sternenstaub loest sich auf\\.", ["duration"]="600"},
    {["name"]="Todesaura", ["start"]="Du senkst Deine Haende, aber der Schutz der schwarzen Schleier.*|Die schwarzen Schleier verdichten sich um Dich\\.",["stop"]="Deine Todesaura loest sich auf\\.", ["duration"]="600"},
    {["name"]="Todkonvertieren", ["start"]="Du wirst von einem heiligen Schutz umgeben\\.", ["stop"]="Dein heiliger Schutz loest sich auf\\.", ["duration"]="600"},
    {["name"]="Trotz", ["start"]="Du hast nun verbesserte Verteidigungsfertigkeiten\\.", ["stop"]="Deine verbesserten Verteidigungsfertigkeiten schwinden\\.", ["duration"]="600"},
    {["name"]="Vergeltung", ["start"]="Du oeffnest Deine Augen und buendelst Deine Wut\\.", ["stop"]="Die Wut in Dir scheint besiegt\\.", ["duration"]="600"},
    {["name"]="Wasseraura", ["start"]="Es regnet aus der Wolke auf Dich herab.*",["stop"]="Dein Wasserschleier loest sich auf\\.", ["duration"]="600"},
    {["name"]="Weissschild", ["start"]="Du wirst von einem magischen Schild umgeben, der Dich Deinen Gegner .*", ["stop"]="Dein Weissschild loest sich auf\\.", ["duration"]="600"},
    {["name"]="Windhaut", ["start"]="Du bist nun vollkommen in eine Windhaut eingehuellt\\.",["stop"]="Du befreist Dich von Deiner Windhaut\\.|Deine Windhaut loest sich auf\\.", ["duration"]="600"},
    {["name"]="Zauberwaffe", ["start"]="Du uebertraegst die Energie auf (Dein|Deine|Deinen|den)([a-z ,]*)([A-Za-z\\s]+)\\.",["stop"]="(Der|Die|Das|Dein|Deine) ([a-z ,]*)([A-Za-z\\s]+) verliert [a-z]* Energie\\.", ["duration"]="600"},
    {["name"]="Zorn", ["start"]="Du wirst von kuehlen Winden umgeben\\.", ["stop"]="Die kuehlen Winde, welche Dich umgeben, verschwinden\\.", ["duration"]="600"},
  }
 
  -- Jetzt mÃ¼ssen die Timer-Trigger noch erzeugt werden. DafÃ¼r gibt es, wie weiter
  -- oben beschrieben, vier MÃ¶glichkeiten:
  -- 1) erzeugt alle Start- und alle Stop-Trigger als temporÃ¤re Trigger:
  --avalonUI.createTempTimer(timerStrings)
  -- 2) erzeugt alle START-Trigger als temporÃ¤re Trigger. Die STOP-Trigger werden 
  --    vom jeweiligen START-Trigger erzeugt, und zwar als ONE-TIME temp. Trigger:
  avalonUI.createImprovedTempTimer(timerStrings)
  -- 3) erzeugt alle Start- und alle Stop-Trigger als permante Trigger:
  --avalonUI.createPermTimer(timerStrings)
  -- 4) erzeugt alle Start-Trigger als permanente Trigger. Die STOP-Trigger werden
  --    vom jeweiligen START-Trigger erzeugt, und zwar als ONE-TIME-temp.(!) Trigger:
  --avalonUI.createMixedTimer(timerStrings)

end -- function avalonUI.initTimer()



-- function avalonUI.createTempTimer(timerStrings)
-- Hier werden die Start- UND die Stop-Trigger als TEMPORÃRE Trigger erzeugt
function avalonUI.createTempTimer(timerStrings)

  for _, v in pairs(timerStrings) do
  
    if v["duration"] == nil then
      v["duration"] = "false"
    end

    local param = ""
    local luaCode = ""
    -- Bei bestimmten Zaubern werden Begriffe aus dem auslÃ¶senden Text verwendet, um den
    -- Namen fÃ¼r den Timer zu bauen. Hier wird der dafÃ¼r notwendige Parameter gesetzt.
    -- (Beim Stop-Trigger dann das GegenstÃ¼ck, damit der richtige Timer gelÃ¶scht wird.)
    if v["name"] == "Segen" then param = ", matches[4]" end
    if v["name"] == "Zauberwaffe" then param = ", matches[4]" end

    -- START-Trigger:
    luaCode = [[avalonUI.registerTimer("]]..v["name"]..[[", "]]..v["duration"]..[["]]..param..[[)]]
    tempRegexTrigger(v["start"], luaCode)
    
    -- STOP-Trigger (nur bei Bedarf):
    if v["stop"] ~= "" then
      luaCode = [[avalonUI.deregisterTimer("]]..v["name"]..[["]]..param..[[)]]
      tempRegexTrigger(v["stop"], luaCode)
    end
  end -- for
end



-- function avalonUI.createImprovedTempTimer(timerStrings)
-- Hier werden die START-Trigger als temporÃ¤re Trigger erzeugt. Und zwar so,
-- dass sie sich beim AuslÃ¶sen ihren eigenen temporÃ¤ren One-Time-STOP-Trigger
-- erzeugen
function avalonUI.createImprovedTempTimer(timerStrings)
  -- Beispiel fÃ¼r einen Timer-Trigger, der sich seinen eigenen Timer-Ende-Trigger setzt:
  -- permRegexTrigger("Flamme", "AvaletTriggerFuerTimer", {"^Flamme an!$"}, [[registerTimer("Flamme", "60"); tempRegexTrigger("^Flamme aus!$", function() removeTimer("Flamme") end, 1)]])
  -- Nur der Timer-Ende-Trigger:
  -- tempRegexTrigger("^Flamme aus!$", function() removeTimer("Flamme") end, 1)

  for _, v in pairs(timerStrings) do

    if v["duration"] == nil then
      v["duration"] = "false"
    end

    local param = ""
    local stopTimer = ""
    local luaCode = ""
      -- Bei bestimmten Zaubern werden Begriffe aus dem auslÃ¶senden Text verwendet, um den
      -- Namen fÃ¼r den Timer zu bauen. Und zwar ist das bei den Kleriker-Segen der Fall,
      -- weil die anders nicht zu unterscheiden sind. Hier wird der dafÃ¼r notwendige Parameter gesetzt.
      -- (Beim Stop-Trigger dann das GegenstÃ¼ck, damit der richtige Timer gelÃ¶scht wird.)
    if v["name"] == "Segen" then param = ", matches[4]" end
    if v["name"] == "Zauberwaffe" then param = ", matches[4]" end
    
    -- Wenn eine Stop-RegExpr existiert, wird beim AuslÃ¶sen des Triggers ein temporÃ¤rer One-Time-Stop-Trigger gesetzt.
    -- Da ich das folgende schon vor mehr als 20 Minuten geschrieben habe, verstehe ich es jetzt selber nicht mehr.
    -- Aber die Ersetzung von "\" durch "\\" MUSS sein, weil die einzelnen Maskierungen beim Verarbeiten entfallen,
    -- also jeweils immer eine. Und weil beim Stop-Timer-Trigger eine Verarbeitung mehr erfolgt als beim Start-Dings. 
    if v["stop"] ~= nil and v["stop"] ~= "" then
      stopTimer = [[; tempRegexTrigger("]]..string.gsub(v["stop"], [[\]], [[\\]])..[[", function() avalonUI.deregisterTimer("]]..v["name"]..[["]]..param..[[) end, 1)]]
    end

    -- Zusammenbau und Erzeugen des temporÃ¤ren Triggers:
    luaCode = [[avalonUI.registerTimer("]]..v["name"]..[[", "]]..v["duration"]..[["]]..param..[[)]] .. stopTimer
    tempRegexTrigger(v["start"], luaCode)
      
  end -- for  
end -- function avalonUI.createMixedTimer(timerStrings)



-- function avalonUI.createPermTimer(timerStrings)
-- Hier werden die Start- UND die Stop-Trigger als PERMANENTE Trigger erzeugt
-- Wenn diese permanenten Trigger von mir beim Entwickeln erzeugt werden, schreibt Mudlet
-- sie in diese Datei, also in den Code, und speichert sie. Dann wÃ¼rde ich die Datei packen
-- und als Modul ausliefern und die Trigger wÃ¤ren fest eincodiert. Wenn ich dran denken
-- wÃ¼rde, die Trigger vor dem Ausliefern immer zu lÃ¶schen, kÃ¶nnte ich die permantenten Trigger
-- trotzdem verwenden. Denn dann wÃ¼rden sie zwar auch bei der Installation von Avalet erzeugt
-- werden. Da Mudlet aber nicht in ein gepacktes Modul schreiben kann, wÃ¤ren sie nach Programm-
-- ende wieder gelÃ¶scht. Und mit der Abfrage, ob sie existieren, wÃ¼rden sie dann beim Programm-
-- START wieder neu erzeugt werden. Aber da ich da nicht dran denken werde, benutze ich statt
-- dessen die temporÃ¤ren Trigger. (Und die permanenten Trigger zur zum Debuggen.)
-- Sollte sich dieser Vorbehalt mal Ã¤ndern, warum auch immer, dann wÃ¤re es vielleicht
-- besser, die START-Trigger als permanente Trigger auszulegen, die STOP-Trigger dann als 
-- temporÃ¤re. Wie in der Funktion "avalonUI.createMixedTimer()"
function avalonUI.createPermTimer(timerStrings)

  -- Erzeugt eine sortierte Liste von Triggern. Weil es einfach schÃ¶ner ist, wenn man die
  -- Liste im Code-Editor von Mudlet sieht. Ist bei temporÃ¤ten Triggern ja unnÃ¶tig.
  local sortTimerStrings = function (a, b) return a["name"] &lt; b["name"] end
  table.sort(timerStrings, sortTimerStrings)

  for _, v in pairs(timerStrings) do

    -- Trigger nur erzeugen, wenn sie nicht schon existieren:  
    if not exists(v["name"].."Start", "trigger") then

      if v["duration"] == nil then
        v["duration"] = "false"
      end

      local param = ""
      local luaCode = ""
      -- Bei bestimmten Zaubern werden Begriffe aus dem auslÃ¶senden Text verwendet, um den
      -- Namen fÃ¼r den Timer zu bauen. Und zwar ist das bei den Kleriker-Segen der Fall,
      -- weil die anders nicht zu unterscheiden sind. Hier wird der dafÃ¼r notwendige Parameter gesetzt.
      -- (Beim Stop-Trigger dann das GegenstÃ¼ck, damit der richtige Timer gelÃ¶scht wird.)
      if v["name"] == "Segen" then param = ", matches[4]" end
      if v["name"] == "Zauberwaffe" then param = ", matches[4]" end
      
      -- Zusammenbau und Erzeugen des START-Triggers als permanter Trigger:
      luaCode = [[avalonUI.registerTimer("]]..v["name"]..[[", "]]..v["duration"]..[["]]..param..[[)]]
      permRegexTrigger(v["name"].."Start", "AvaletTriggerFuerTimer", {v["start"]}, luaCode)
    end -- if exists
      
    -- Nur bei Bedarf und wenn er nicht schon existiert: der STOP-Trigger:
    if not exists(v["name"].."Stop", "trigger") and v["stop"] ~= "" then
      -- Zusammenbau und Erzeugen des STOP-Triggers als permanenter Trigger:
      luaCode = [[avalonUI.deregisterTimer("]]..v["name"]..[["]]..param..[[)]]
      	permRegexTrigger(v["name"].."Stop", "AvaletTriggerFuerTimer", {v["stop"]}, luaCode)
    end -- if exists
  end -- for
end --function avalonUI.createPermTimer(timerStrings)



-- function avalonUI.createMixedTimer(timerStrings)
-- Hier werden die START-Trigger als PERMANENTE Trigger erzeugt. Und zwar so,
-- dass sie sich beim AuslÃ¶sen ihren eigenen TEMPORÃREN One-Time-STOP-Trigger
-- erzeugen
-- Siehe auch Kommentar zur vorherigen Funktion (createPermTimer())
function avalonUI.createMixedTimer(timerStrings)
  -- Beispiel fÃ¼r einen Timer-Trigger, der sich seinen eigenen Timer-Ende-Trigger setzt:
  -- permRegexTrigger("Flamme", "AvaletTriggerFuerTimer", {"^Flamme an!$"}, [[registerTimer("Flamme", "60"); tempRegexTrigger("^Flamme aus!$", function() removeTimer("Flamme") end, 1)]])
  -- Nur der Timer-Ende-Trigger:
  -- tempRegexTrigger("^Flamme aus!$", function() removeTimer("Flamme") end, 1)

  -- Erzeugt eine sortierte Liste von Triggern. Weil es einfach schÃ¶ner ist, wenn man die
  -- Liste im Code-Editor von Mudlet sieht. Ist bei temporÃ¤ten Triggern ja unnÃ¶tig.
  local sortTimerStrings = function (a, b) return a["name"] &lt; b["name"] end
  table.sort(timerStrings, sortTimerStrings)

  for _, v in pairs(timerStrings) do

    -- Eigentlich wÃ¤re es sinnvoll, der Trigger wÃ¼rde gelÃ¶scht werden, wenn er schon existiert.
    -- Weil man nur so ein Update der zu triggernden Texte machen kann. Geht aber nicht. Die
    -- Mudlet-Funktion "killTrigger" kann nur temporÃ¤re Trigger lÃ¶schen. (Evtl. kÃ¶nnte man hier
    -- Ã¼ber die Trigger-Group lÃ¶schen, aber dann mÃ¼sste man die neu erzeugen und das ging auch
    -- nicht. Siehe oben.)
    if not exists(v["name"], "trigger") then

      if v["duration"] == nil then
        v["duration"] = "false"
      end

      local param = ""
      local stopTimer = ""
      local luaCode = ""
      -- Bei bestimmten Zaubern werden Begriffe aus dem auslÃ¶senden Text verwendet, um den
      -- Namen fÃ¼r den Timer zu bauen. Und zwar ist das bei den Kleriker-Segen der Fall,
      -- weil die anders nicht zu unterscheiden sind. Hier wird der dafÃ¼r notwendige Parameter gesetzt.
      -- (Beim Stop-Trigger dann das GegenstÃ¼ck, damit der richtige Timer gelÃ¶scht wird.)
      if v["name"] == "Segen" then param = ", matches[4]" end
      if v["name"] == "Zauberwaffe" then param = ", matches[4]" end
      
      -- Wenn eine Stop-RegExpr existiert, wird beim AuslÃ¶sen des Triggers ein temporÃ¤rer One-Time-Stop-Trigger gesetzt.
      -- Da ich das folgende schon vor mehr als 20 Minuten geschrieben habe, verstehe ich es jetzt selber nicht mehr.
      -- Aber die Ersetzung von "\" durch "\\" muss sein, weil die einzelnen Maskierungen beim verarbeiten entfallen,
      -- also jeweils immer eine. Und weil beim Stop-Timer-Trigger eine Verarbeitung mehr erfolgt als beim Start-Dings. 
      if v["stop"] ~= nil and v["stop"] ~= "" then
        stopTimer = [[; tempRegexTrigger("]]..string.gsub(v["stop"], [[\]], [[\\]])..[[", function() avalonUI.deregisterTimer("]]..v["name"]..[["]]..param..[[) end, 1)]]
      end
      
      -- Zusammenbau und erzeugen des PERMANENTEN Start-Triggers, der sich einen eigenen TEMPORÃREN Stop-Trigger erzeugt:      
      luaCode = [[avalonUI.registerTimer("]]..v["name"]..[[", "]]..v["duration"]..[["]]..param..[[)]] .. stopTimer
      permRegexTrigger(v["name"], "AvaletTriggerFuerTimer", {v["start"]}, luaCode)

    end -- if not exists
      
  end -- for  
end -- function avalonUI.createMixedTimer(timerStrings)
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>settings</name>
			<packageName></packageName>
			<script>--Benutzerdefinierte Einstellungen

avalonUI.settings = avalonUI.settings or {}
avalonUI.settings.GUIframe  = avalonUI.settings.GUIframe or {}
avalonUI.settings.avalet    = avalonUI.settings.avalet or {}
avalonUI.settings.character = avalonUI.settings.character or {}
avalonUI.settings.chatTabs  = avalonUI.settings.chatTabs or {}


avalonUI.settings.avalet = {
  ["name"] = "Avalet",
  ["timerGaugeDirection"] = "goofy",
  ["chatTabs"] = {},
}

avalonUI.settings.character = {
  ["name"] = "",
  ["backgroundColor"] = "black",
}

--[[Tabs im Chat-Bereich
    Die Liste hier legt fest, welche Tabs angezeigt werden sollen. Der hier verwendete "Name" wird intern verwendet, um
    den Namen des Kanals zu finden. Das heisst, der Name hier muss exakt so geschrieben werden, wie er hier steht. Und 
    kann nicht verwendet werden, um den Tab kreativ zu beschriften. MÃ¶gliche KanÃ¤le sind:
    Reden, Sagen, Laber, Neuling, Gruppe, Volk, Gilde, Zuenfte, Schwafel, Tod, Monster, Gebruell, Logout, Raetsel, Spiele,
    Statue
    Geplant aber noch nicht mÃ¶glich: ein Sammeltab]]
avalonUI.settings.chatTabs = {
  {["name"] = "Reden", ["position"] = 1, ["aktiv"] = true},
  {["name"] = "Sagen", ["position"] = 2, ["aktiv"] = true},
  {["name"] = "Laber", ["position"] = 3, ["aktiv"] = true},
  {["name"] = "Neuling", ["position"] = 4, ["aktiv"] = true},
  {["name"] = "Gruppe", ["position"] = 5, ["aktiv"] = true},
  {["name"] = "Volk", ["position"] = 6, ["aktiv"] = true},
  {["name"] = "Gilde", ["position"] = 7, ["aktiv"] = true},
  --{["name"] = "Schwafel", ["position"] = 8, ["aktiv"] = true},
}


-- Einstellungen der HÃ¶he/Breite der Fensterbereiche
avalonUI.settings.GUIframe = {
  ["leftStartWidth"] = nil,
  ["leftStartHeight"] = nil,
  ["rightStartWidth"] = nil,
  ["rightStartHeight"] = nil,
}


</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>GUIFrame defaults</name>
			<packageName></packageName>
			<script>local mainW, mainH = getMainWindowSize()
local tabSheet = table.deepcopy(avalonUI.CSS.base)
tabSheet.stylesheet.margin = nil
--tabSheet:set("margin-right", "1px")
--tabSheet:set("margin-left", "1px")
--tabSheet:set("border-width", "2px")
----tabSheet:set("display", "none")
----tabSheet:set("visibility", "hidden")

--	background-color: rgba(0,0,0,100);
--	border-style: solid;
--	border-width: 1px;
--	border-radius: 10px;
--	border-color: white;
--	font: TypeWriter;
--	margin: 10px;
tabSheet:set("background-color", "rgba(0,0,0,100)")
tabSheet:set("border-style", "solid")
tabSheet:set("border-width", "1px")
tabSheet:set("border-radius", "10px")
tabSheet:set("border-color", "white")
tabSheet:set("font", "TypeWriter")
tabSheet:set("margin-left", "10px")
tabSheet:set("margin-right", "10px")
tabSheet:set("width", "98%")
tabSheet:set("height", "20px")


GUIframe.configs = {
    tabHeight = 20,
    tabStyle = tabSheet:getCSS(),
    tabEchoStyle = '&lt;center&gt;&lt;p style="font-size:13px; color:LightYellow"&gt;',
    leftStartWidth = math.floor(mainW * 0.16),       --math.floor(mainW / 6.8),
    leftStartHeight = math.floor(mainH / 2.5),        --math.floor(mainH / 3),
    rightStartWidth = math.floor(mainW * 0.35),        --math.floor(mainW / 3),
    rightStartHeight = math.floor(mainH / 2),    --math.floor(mainH * 0.42),
    topStartHeight = 60,   --30
    bottomStartHeight = 0, --65
    resizeHoverImage = "/imgs/blue_arrows.png",
    resizeRestImage = "/imgs/blue_arrows_20t.png",
    borderOffset = 0,
}</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>AvalonTime</name>
			<packageName></packageName>
			<script>function avalonUI.getAvalonTime()

  timeStr = ""

  local sec = os.time(os.date("*t"))-808437600
  --cecho("&lt;magenta&gt;\n"..sec.."\n")
  local jahr = math.floor(sec/31536000*13)
  sec = sec-(jahr*31536000/13)
  local tag = math.floor(sec/86400*13+1)
  sec = sec-((tag-1)*86400/13)
  local stunde = math.floor(sec/3600*13)
  if (stunde &lt;=9) then stunde ="0"..stunde;end 
  sec = sec-(stunde*3600/13)
  local minute = math.floor(sec/60*13)
  if (minute &lt;=9) then minute ="0"..minute;end 
  wtage={"Sonntag","Montag","Dienstag","Mittwoch","Donnerstag","Freitag","Samstag"}
  if (tag&lt;=365) then monat=12;atag=tag-334;end
  if (tag&lt;=334) then monat=11;atag=tag-304;end
  if (tag&lt;=304) then monat=10;atag=tag-273;end
  if (tag&lt;=273) then monat=9;atag=tag-243;end 
  if (tag&lt;=243) then monat=8;atag=tag-212;end
  if (tag&lt;=212) then monat=7;atag=tag-181;end
  if (tag&lt;=181) then monat=6;atag=tag-151;end
  if (tag&lt;=151) then monat=5;atag=tag-120;end
  if (tag&lt;=120) then monat=4;atag=tag-90;end
  if (tag&lt;=90) then monat=3;atag=tag-59;end
  if (tag&lt;=59) then monat=2;atag=tag-31;end
  if (tag&lt;=31) then monat=1;atag=tag;end
  season = "-"
  if tag &gt;=0 and tag &lt;=76 then season = "Winter";end
  if tag &gt;=77 and tag &lt;= 132 then season = "Fruehling";end
  if tag &gt;=133 and tag &lt;= 256 then season = "Sommer";end
  if tag &gt;=257 and tag &lt;= 322 then season = "Herbst";end
  if tag &gt;=323 then season = "W";end
  datum = {}
  datum.monat = monat
  datum.jahr = jahr
  datum.wtag = atag
  datum.wtagdesc = wtage[((tag+(jahr*365)+3)%7)+1]
  datum.stunde = stunde
  datum.minute = minute
  datum.season = season
  --ClockBox:echo([[&amp;lt;p style="font-size:12px"&amp;gt;&amp;lt;b&amp;gt;&amp;lt;font color="white"&amp;gt;]]..wtage[((tag+(jahr*365)+3)%7)+1]..", "..atag.."."..monat.."."..jahr.." "..stunde..":"..minute.." ("..season..")")
--[[
]]

  timeStr = wtage[((tag+(jahr*365)+3)%7)+1]..", "..atag.."."..monat.."."..jahr.." "..stunde..":"..minute.." ("..season..")"

  return timeStr

end


function avalonUI.getSimplifiedAvalonTime()

  simplAvaTime = nil
  
  return simplAvaTime
  
end

</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>ModelControl</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>createChatModel</name>
				<packageName></packageName>
				<script>-- createChatModel

--------------------------------------------
--- Tabs-Element rechts unten
-------------------------------------------
function avalonUI.createChatModel()
  -- Generelle Variablen fÃ¼r das Tab-Element
  GUIModel.tabElement = GUIModel.tabElement or {
    tabs = {"Reden", "Sagen", "Laber", "Neuling", "Gruppe", "Volk", "Gilde", "Schwafel"},
  }
  -- Speichert das aktuell ausgewÃ¤hlte Element:
  GUIModel.tabElement.currentTab = GUIModel.tabElement.currentTab or GUIModel.tabElement.tabs[1]
  
  for k,v in pairs(GUIModel.tabElement.tabs) do
  
    avalonUI.chats[v] = {}
    
  end

end



-- In der per ATCP empfangenen Kommunikation gibt es Formatierungsanweisungen,
-- die hier rausgefiltert werden.
local clearMessage = function(str)
  local message = str
  message = string.gsub(message, "%%%^ITALIC%%%^", "")
  message = string.gsub(message, "%%%^NO_ITALIC%%%^", "")
  message = string.gsub(message, "%%%^NC_html_begin_colour%(%#[A-Za-z0-9]+%)%%%^", "")
  message = string.gsub(message, "%%%^NC_html_end_colour%%%^", "")
  
  return message
end



-- Hier wird die Kommunikation verarbeitet, die Ã¼ber die Comm-KanÃ¤le per ATCP eingehen.
-- Eine erste Verarbeitung fand schon beim Eingang der Nachricht statt, also bei
-- ATCP --&gt; atcp (Trennung von channel und message nÃ¤mlich, aber auch die Zuordnung von
-- einzelnen KanÃ¤len zu Sammelbegriffen, bspswse "vr" zu "Volk".
function avalonUI.processMessage(channel, message)

  -- Die Nachricht kann Steuercode enthalten, beispielsweise fÃ¼r farbigen Text.
  -- Der wird hier rausgefiltert.
  message = clearMessage(message)
  
  local logfilename = ""
  if player.name ~= nil and player.name ~= "" then
    logfilename = string.title(player.name) .. channel
  else
    logfilename = channel
  end
  
  Logger:Log(logfilename, message, {"timestamp", split = 4000})

  local timestamp = getTime(true, "'['dd'.'MM'.'yyyy' - 'hh':'mm':'ss'.'zzz]: ")

  local line = ""

  -- Hier kÃ¶nnen auch Comm-Nachrichten landen, fÃ¼r die es keinen Tab gibt. Also:
  if avalonUI.chats[channel] ~= nil then
    -- Die Tabelle der einzelnen Chat-Tabs wird auf 500 Elemente begrenzt.
    -- Um Speicher zu sparen. Die Zahl kann sich noch Ã¤ndern, aber 500 schien
    -- mir erstmal ausreichend zu sein. Wenn die Tabelle lÃ¤nger ist, wird
    -- hier jeweils das erste Element entfernt.
    while #avalonUI.chats[channel] &gt;= 500 do
      table.remove(avalonUI.chats[channel], 1)
    end

    -- Timestamp vor die Zeile und ab damit in die Tabelle:
    line = timestamp .. message --.. "\n"
    table.insert(avalonUI.chats[channel], line)

    -- Aufbereitet wird die Anzeige bei der Ausgabe. DafÃ¼r sorgt:
    raiseEvent("RefreshTabElement", channel)
  end  
end


-- Teilweise gab es Anzeigeprobleme im Tab - die neuen Zeilen wurden
-- ausgegeben, aber der Fokus rutschte nicht weiter runter, so dass
-- die neuen Zeilen unterhalb des unteren Randes standen. Und andere
-- (weniger eindeutige) MerkwÃ¼rdigkeiten. Dabei fand das lÃ¶schen des
-- Tabs nur mit "clearWindow()" statt. Mit der zusÃ¤tzlichen Ausgabe
-- eines Leerzeichens scheint sich das Problem erledigt zu haben.
local clearTab = function(channel)
  debugc("&lt;magenta&gt;clearWindow: ".. channel .. "\n")    
  clearWindow(channel)
  avalonUI.tabElement.tabs[GUIModel.tabElement.currentTab.."console"]:echo(" ")
end



-- Wird ausgefÃ¼hrt, wenn per ATCP eine neue Kommunikation eingeht
-- und diese in die ChatTab-Tabelle geschrieben wurde (siehe oben).
function avalonUI.onRefreshTabElement(_, channel)

  local content = ""
  local lastdate = ""
  local date = ""
  local line = ""
  -- Wenn fÃ¼r den aktuell angezeigten Tab eine neue Nachricht eingeht ...
  if GUIModel.tabElement.currentTab == channel then
    debugc("Der TAB " .. channel .. " wird aktualisiert.")

    --... wird erstmal der alte Inhalt gelÃ¶scht.
    clearTab(channel)
    
    -- Dann wird fÃ¼r jede Zeile in der ChatTab-Tabelle ...
    for _,v in pairs(avalonUI.chats[channel]) do

      -- ... erstmal das Datum extrahiert. (Aus dem Timestamp am Anfang der Zeile.)
      date = string.gsub(v, "^%[(%d+%.%d+%.%d+) %- %d+:%d+:%d+%.%d+%]: .*$", "%1", 1)
      --content = ""
      
      -- Wenn der Tab noch leer ist, wird erstmal das Datum des ersten Eintrags ausgegeben.
      -- Und dann wieder bei jedem Datumswechsel. Dabei wird zusÃ¤tzlich noch ein Leerzeichen
      -- eingefÃ¼gt.
      if lastdate ~= date then
        if lastdate ~= "" then content = "\n" end
        content = content .. "\n~~~~~~~~~~~~~~~~~~~~ " .. date .. " ~~~~~~~~~~~~~~~~~~~~\n\n"
        lastdate = date
      end
      
      -- Die eigentliche Zeile besteht nur aus dem Zeitstempel und dem eigentlichen Text
      line = string.gsub(v, "^%[%d+%.%d+%.%d+ %- (%d+:%d+:%d+)%.%d+%]: (.*)$", "%1: %2", 1)
      content = content .. line .. "\n"

      -- Seit Mudlet 4.8 kann "echo()" nur noch 10k Zeichen auf einmal ausgeben. Hier wird
      -- deshalb nach 8k Zeichen der Content einmal ausgegeben (und dann geleert).
      if #content &gt; 8000 then
        avalonUI.tabElement.tabs[GUIModel.tabElement.currentTab.."console"]:echo(content)
        content = ""
      end
    end
    -- Zum Schluss wird noch der Rest vom Content ausgegeben, also alles unter 8k Zeichen.
    if content ~= "" then
      avalonUI.tabElement.tabs[GUIModel.tabElement.currentTab.."console"]:echo(content)
    end
  -- Wenn die Nachricht, die eingeht, NICHT fÃ¼r den aktuell angezeigten Tab ist, dann wird
  -- einfach nur der entsprechende Tab farbig markiert. Damit der User sieht, dass da noch
  -- ungelesene Nachrichten sind.
	else
    avalonUI.markTab(channel)
	end
end
registerAnonymousEventHandler("RefreshTabElement", "avalonUI.onRefreshTabElement")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createCounterModel</name>
				<packageName></packageName>
				<script>--createCounterModel

avalonUI.counter = avalonUI.counter or {}

avalonUI.counter = {
  {["Name"]="Session-EP", ["Groesse"]="EP", ["Basis"] = "Session"},
  {["Name"]="Arkanschild", ["Groesse"]="EP", ["Basis"] = "Arkanschild"},
  {["Name"]="Kampfdauer", ["Groesse"]="Zeit", ["Basis"] = "Kampf"},
  {["Name"]="EP-Verdoppelung", ["Groesse"]="EP", ["Basis"] = "EP-Verdoppelung"},
  {["Name"]="EP/Stunde", ["Groesse"]="EP", ["Basis"] = "Stunde"},
}

local schutzzauber = schutzzauber or {}
schutzzauber = {"Arkanschild", "Schild", "Kampfbeschwoerung", ""}

function avalonUI.createCounterModel()
  avalonUI.listOfCounter = avalonUI.listOfCounter or {}
  avalonUI.listOfCounter = {
    [1] = {["Name"]="EP", ["Groesse"]="EP", ["Basis"] = "EP", ["Basiswert"] = 0},
    [2] = {["Name"]="Session-EP", ["Groesse"]="EP", ["Basis"] = "Session", ["Basiswert"] = 0},
  }
  
end


function avalonUI.recreateCounter()
	--debugc("func initCounter()")
  
  -- Alle Counter unsichtbar machen und Beschriftung lÃ¶schen. Es gibt
  -- 6 Label-Elemente fÃ¼r Counter auf der OberflÃ¤che, also (max) 6 Timer:
  for k = 1, 6, 1 do
    avalonUI["Counter"..k]:hide()
    avalonUI["Counter"..k]:echo("")
  end

  -- Counter-Anzeige neu aufbauen:
  avalonUI.refreshCounter()
end --function initCounter()


function avalonUI.refreshCounter()
	--debugc("function refreshCounter")
  
  for k, v in pairs(avalonUI.listOfCounter) do
    avalonUI["Counter"..k]:show()
    ---- mylabel:echo(string.format("&lt;span style='color: rgb(0,0,0)'&gt;Hello World&lt;/span&gt;", redv, greenv, bluev))
    ----avalonUI["Counter"..k]:echo("&lt;span style='color: rgb(0,0,0)'&gt;&lt;b&gt;&amp;nbsp;"..v["Name"]..": " .. tostring(tonumber(player.ep) - tonumber(player.sessionEP)) .. "&lt;/b&gt;&lt;/span&gt;")
    --avalonUI["Counter"..k]:echo("&lt;b&gt;&amp;nbsp;"..v["Name"]..": " .. tostring(tonumber(player.ep) - tonumber(player.sessionEP)) .. "&lt;/b&gt;")
    if k == 1 then avalonUI["Counter"..k]:echo("&lt;b&gt;" .. v["Name"] ..":&lt;/b&gt;" .. thousands(tonumber(player.ep))) end
    if k == 2 then avalonUI["Counter"..k]:echo("&lt;b&gt;".. v["Name"] ..":&lt;/b&gt; " .. thousands(tonumber(player.ep) - tonumber(player.sessionEP))) end
  end
end

-- Das Problem mit dem SessionEP-ZÃ¤hler ist, dass es im Grunde keine MÃ¶glichkeit gibt,
-- ein echtes "Login", also den Session-Start, zu erkennen. Man kann ein "reconnect"
-- an Hand des Strings "Verwende alten Koerper..." erkennen (und dann nur hoffen, dass
-- das immer zuverlÃ¤ssig ist), aber um einen echten login davon unterscheiden zu kÃ¶nnen,
-- mÃ¼sste man zuverlÃ¤ssigere Daten haben. (ODER?)
-- Naja, man kÃ¶nnte bei sysConnection ein Flag "isLogin = true" setzen, und durch den Trigger auf
-- "Verwende alten Koerper..." kÃ¶nnte man das Flag auf "false" setzen. Das funktioniert vermutlich,
-- wenn WIRKLICH der Char-Name nicht vorher per ATCP kommt. Sollte gehen. TODO.
-- "\nSession-EP: " .. tostring(tonumber(player.ep) - tonumber(player.sessionEP)) .. "\n"

-- event == "AvalonEP"
function avalonUI.updateSessionEP(_, arg)
  debugc("Update SessionEP-Zaehler!")
  --cecho("&lt;magenta&gt;\nupdate Session-EP\n")
  --avalonUI["Counter1"]:echo("&lt;b&gt;&amp;nbsp;Session-EP: " .. tostring(tonumber(arg) - tonumber(player.sessionEP)) .. "&lt;/b&gt;")
  avalonUI["Counter1"]:echo("&lt;b&gt;EP:&amp;nbsp;&lt;/b&gt;" .. thousands(player.ep))
  avalonUI["Counter2"]:echo("&lt;b&gt;Session-EP:&amp;nbsp;&lt;/b&gt;" .. thousands(tonumber(arg) - tonumber(player.sessionEP)))
end
registerAnonymousEventHandler("AvalonEP", "avalonUI.updateSessionEP")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createInfoScreenModel</name>
				<packageName></packageName>
				<script>-----------------------------------------------------
-- Charakter-Informationen rechts oben (Infobox)
-----------------------------------------------------

function avalonUI.createInfoScreenModel()
  GUIModel.infobox = "\nWarte auf Daten..."
end



function avalonUI.updateInfoBox()
	GUIModel.infobox = "\n"
	if avalonUI ~= nil then 
		clearWindow("Infobox") 
	end
	if player.vollername == nil then 
		return
	end
	if string.len(player.vollername) ~= 0 then
		GUIModel.infobox = GUIModel.infobox .. "In Avalon bist Du bekannt als\n\n" .. player.vollername .. "\n\n"
		if string.len(player.gilde) ~= 0 then
			if player.gilde == "keine" then
				GUIModel.infobox = GUIModel.infobox .. "Du bist noch in keiner Gilde.\n"
			else
				if player.gilde == "Druiden" then
					GUIModel.infobox = GUIModel.infobox .. "Du bist bei den " .. player.gilde .. ".\n"
				elseif player.gilde == "Magier" then
					GUIModel.infobox = GUIModel.infobox .. "Du bist in der " .. player.gilde .. "gilde.\n"
				else
					GUIModel.infobox = GUIModel.infobox .. "Du bist " .. player.gilde .. ".\n"
				end
			end
		end
		if string.len(player.zuenfte) == 0 then
			GUIModel.infobox = GUIModel.infobox .. "Du uebst noch keine Berufe aus.\n"
		else
			local zuenfte = {}
			for i in string.gmatch(player.zuenfte, "%w+") do
				table.insert(zuenfte, i)
			end			
			str = ""
			for k,v in pairs(zuenfte) do
				if k == #zuenfte and k &gt; 1 then
					str = str .. " und "
				end
				str = str .. v
				if k &lt; #zuenfte - 1 then
					str = str .. ", "
				end
			end
			
			GUIModel.infobox = GUIModel.infobox .. "Du gehoerst den Zuenften " .. str .. " an.\n"
			--GUIModel.infobox = GUIModel.infobox .. "Deine Berufe sind: " .. player.zuenfte .. ".\n"
		end
  if string.len(player.alter) ~= 0 then
    -- Also ich habe keinen regulÃ¤ren Ausdruck gefunden, der Stunden und Minuten sowohl
    -- in der Mitte der Zeichenkette als auch am Anfang zuverlÃ¤ssig erkennt. Bestenfalls
    -- wurde dabei nur eine Ziffer Ã¼bernommen (also "8 Minuten" statt "28 Minuten"). Deshalb
    -- die zweistufige LÃ¶sung. Wer da besser ist als ich --&gt; mail me! (Aber erst testen!)
    -- TestfÃ¤lle:
    -- "38 Tage 40 Stunden 21 Minuten 41 Sekunden 3306101",
    -- "3 Tage 6 Stunden 2 Minuten 4 Sekunden 3306101",
    -- "6 Stunden 21 Minuten 41 Sekunden 3306101",
    -- "38 Tage 21 Minuten 41 Sekunden 3306101",
    -- "21 Minuten 41 Sekunden 3306101",
    -- "38 Tage 6 Stunden 41 Sekunden 3306101",
    local str = player.alter
    local tage = ""
    tage = string.gsub(str, "^(%d+%sTage?)%s.*", "%1", 1)
    if tage == str then
      tage = "0 Tage"
    end
    local stunden = ""
    stunden = string.gsub(str, ".*%s(%d+%sStunden?)%s.*", "%1", 1)
    if stunden == str then
      stunden = string.gsub(str, "^(%d+%sStunden?)%s.*", "%1", 1)
      if stunden == str then
        stunden = "0 Stunden"
      end
    end
    local minuten = ""
    minuten = string.gsub(str, ".*%s(%d+%sMinuten?)%s.*", "%1", 1)
    if minuten == str then
      minuten = string.gsub(str, "^(%d+%sMinuten?)%s.*", "%1", 1)
      if minuten == str then
        minuten = "0 Minuten"
      end
    end
    --local sekunden = ""
    --sekunden = string.gsub(str, ".*%s(%d+%sSekunden?)%s.*", "%1", 1)
    --if sekunden == str then
    --  sekunden = "0 Sekunden"
    --end
    
    str = tage .. " " .. stunden .. " und " .. minuten
    
    GUIModel.infobox = GUIModel.infobox .. "Du bist etwa " .. str .. " alt.\n"
    --GUIModel.infobox = GUIModel.infobox .. "Du bist " .. player.alter .. " alt\n"
  end
		if string.len(player.portfolio) ~= 0 then
			if (player.portfolio ~= "keines") then
				if player.portfolio == player.name then
					GUIModel.infobox = GUIModel.infobox .. "Du bist Erstie in Deinem Portfolio.\n\n"
				else
					GUIModel.infobox = GUIModel.infobox .. "Du bist Zweitie im Portfolio von " .. string.title(player.portfolio) .. ".\n\n"
				end
			end
		end
		if string.len(player.level) ~= 0 then
			GUIModel.infobox = GUIModel.infobox .. "Du bist Level " .. player.level .. "\n"
		end
--		if string.len(player.ep) ~= 0 then
--			GUIModel.infobox = GUIModel.infobox .. "DafÃ¼r hast du bisher " .. player.ep .. " Erfahrungspunkte gesammelt.\n\n"
--		end
		if string.len(player.gesinnung) ~= 0 then
			GUIModel.infobox = GUIModel.infobox .. "\nDeine Gesinnung ist " .. player.gesinnung .. ".\n"
		end
		if string.len(player.hunger) ~= 0 then
			GUIModel.infobox = GUIModel.infobox .. "Hunger: " .. player.hunger .. "\n"
		end
		if string.len(player.durst) ~= 0 then
			GUIModel.infobox = GUIModel.infobox .. "Durst: " .. player.durst .. "\n"
		end
		if string.len(player.durst) ~= 0 then
			GUIModel.infobox = GUIModel.infobox .. "Alkohol: " .. player.alk .. "\n"
		end
--    if player.schutz ~= nil then
--      GUIModel.infobox = GUIModel.infobox .. "\nSchutz: " .. player.schutz .. "\n"
--    end
    if player.istDunkel == "1" then
      GUIModel.infobox = GUIModel.infobox .. "\nAufenthaltsort: &lt;zu dunkel&gt;\n"
    else
      GUIModel.infobox = GUIModel.infobox .. "\nAufenthaltsort: " .. player.avalonRoomID .. "\n"
    end
    GUIModel.infobox = GUIModel.infobox .. "\nAvalon-Zeit: " .. avalonUI.getAvalonTime() .. "\n"
	else
		debugc("\nKeine Player-Daten vorhanden!\n")
		GUIModel.infobox = "\nWarte auf Daten...\n"
	end
end -- function avalonUI.updateInfoBox()



function avalonUI.onRefreshInfobox(event, args)
-- Diese Funktion kann aufgerufen werden, obwohl noch
-- kein Player-Objekt besteht. (Also obwohl der Player-Name noch nicht
-- per ATCP eingetroffen ist. Workaround: auf player.name testen.)
  if player.name ~= "" then
    -- Ich hab vergessen, warum ich das hier fÃ¼r nÃ¶tig hielt... Auskommentiert deshalb      
    --writeDataToFS(characterFilePath, player, "w")
    avalonUI.updateInfoBox()
    --avalonUI.infobox:echo(args)
    avalonUI.infobox:echo(GUIModel.infobox)
    --avalonUI.Health:setValue(tonumber(args[1]), tonumber(args[2]), "&lt;b&gt;" .. args[1] .. "/" .. args[2] .. "&lt;/b&gt;")
  end
end
registerAnonymousEventHandler("RefreshInfobox", "avalonUI.onRefreshInfobox")
--raiseEvent("RefreshCharacterVollername", ???)

</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createMapperModel</name>
				<packageName></packageName>
				<script>--createMapperModel()

function avalonUI.createMapperModel()

end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createTimerModel</name>
				<packageName></packageName>
				<script>-- timerModel
-- Hier geht es um die Daten, die unmittelbar auf der OberflÃ¤che angezeigt werden.
-- Also um die Liste mit Timern.
-- Auf der OberflÃ¤che gibt es immer (derzeit: 9) Timer-Gauges, die aber per default unsichtbar
-- sind und auch keinen Beschriftungstext enthalten. Diese "Timer-Slots" sind so sortiert, dass
-- der erste Slot UNTEN ist und der letzte OBEN. DIESE Sortierung findet also nicht hier statt,
-- sondern ist in der OberflÃ¤che fest eingebaut. (Aber sortiert wird hier schon, nÃ¤mlich nach
-- Restlaufzeit.)

-- function avalonUI.createTimerModel()
-- Initialisierung von allem hier.
function avalonUI.createTimerModel()
  avalonUI.listOfTimers = avalonUI.listOfTimers or {}
end -- function avalonUI.createTimerModel()


-- function sortListOfTimers()
-- RÃ¼ckgabewert: die sortierte Timer-Liste als Tabelle
-- Hier wird die Liste mit den Timern vor der Ausgabe nach Laufzeit sortiert. Als erstes kommen dabei die
-- Timer ohne Laufzeit, also "permantente Timer". Was nicht heiÃt, dass die lÃ¤nger laufen mÃ¼ssen als die
-- "temporÃ¤ren Timer". Da die Liste der Timer auf der OberflÃ¤che von UNTEN nach OBEN ausgegeben wird, stehen
-- die "permanenten Timer" dort also UNTEN!. Auch wenn sie hier die ersten in der sortierten Liste sein werden.
-- Durch die Sortierung nach Laufzeit ergibt sich bei den temporÃ¤ren Timern manchmal die Situation, dass 
-- ein weiter oben in der Ansicht stehender Timer (= geringe Restlaufzeit) noch einen lÃ¤ngeren Fortschritts-
-- Balken hat als ein weiter unten stehender (= lÃ¤ngere Laufzeit). Beispielsweise wird der Timer fÃ¼r 
-- "EP-Verdoppelung" mit einer Laufzeit von 1 Stunde und einer Restlaufzeit von 12 Minuten nur noch einen 
-- sehr kurzen Fortschrittsbalken haben, aber trotzdem noch lÃ¤nger laufen als ein frischer Arkanschild mit 
-- einer Laufzeit von 10 Minuten maximal. Ich fand das manchmal irritierend und hab Ã¼berlegt, die Restlaufzeit
-- mit im Timer anzuzeigen. Aber eigentlich sind mir das zu viele (letztlich Ã¼berflÃ¼ssige) Informationen.
-- Diese Funktion wird jedesmal ausgefÃ¼hrt, wenn das UI-Element fÃ¼r die Timer aktualisiert wird. Also einmal
-- pro Sekunde derzeit.
function avalonUI.sortListOfTimers()
	-- debugc("func sortListOfTimers()")
  
  local sortedListOfTimers = {}
  local remaining = 0
  
  for k, v in pairs(avalonUI.listOfTimers) do
		
    -- Wenn die "duration" auf "false" gesetzt ist, dann ist es ein Timer ohne Laufzeit, der die ganze
    -- Zeit mit vollem Fortschrittsbalken angezeigt wird. Und der durch einen Schluss-Trigger gelÃ¶scht
    -- werden muss. Sonst steht er bis zum Neustart von Mudlet in der Timer-Ãbersicht. (TODO!)
    if v["duration"] == "false" then
      
      -- Damit das mit dem sortieren der Liste klappt, werden hier etwas willkÃ¼rlich die Werte fÃ¼r
      -- remaining und duration gesetzt. Wichtig ist, dass die Zahl grÃ¶Ãer ist als der am lÃ¤ngsten
      -- laufende temporÃ¤re Timer. Das ist im Moment "EP-Verdoppelung" mit 3600 Sekunden.
      table.insert(sortedListOfTimers, {["name"] = v["name"], ["remaining"] = 60000, ["duration"] = 60000})

    -- Wenn "duration" NICHT false ist, ist es ein "temporÃ¤rer Timer" mit abnehmendem Fortschrittsbalken.
    else
      
      -- Restlaufzeit frisch berechnen
      remaining = (tonumber(v["duration"]) - ((os.time() - v["starttime"])))

      -- Wenn der Timer aus irgendwelchen GrÃ¼nden Ã¼brig geblieben ist, soll er trotzdem irgendwann 
      -- gelÃ¶scht werden. GrÃ¼nde kÃ¶nnten sein, dass die Ausgabe des MUDs irgendwie durcheinander geraten
      -- ist und der Beenden-Trigger deshalb nicht gegriffen hat. Oder ein connection lost oder was auch
      -- immer. Einen konkreten Grund gab es nicht, das ist eine VorsichtsmaÃnahme.
      -- Ein temporÃ¤rer Timer (mit einer Laufzeit) wird also gelÃ¶scht, wenn er 30 Sekunden oder mehr Ã¼ber
      -- seine Laufzeit ist. Unter sehr ungÃ¼nstigen UmstÃ¤nden (starke lags) kann es sein, dass 30 Sekunden
      -- nicht reichen. Aber ich glaube, dass das nur extrem selten passieren kann.
      -- Wenn der aktuelle Timer abgelaufen ist, dann ist der Schleifendurchlauf damit ja auch beendet. 
      if remaining &lt;= -30 then
        avalonUI.removeTimer(v["name"])
      else
        table.insert(sortedListOfTimers, {["name"] = v["name"], ["remaining"] = remaining, ["duration"] = v["duration"]})
      end
    end
  end

  -- Die fertige Timer-Liste wird jetzt noch nach Laufzeit sortiert
  local sortMyTimers = function(a, b) return a["remaining"] &gt; b["remaining"] end
  table.sort(sortedListOfTimers, sortMyTimers)

  return sortedListOfTimers

end --function sortListOfTimers()


-- function findTimerByName(name)
-- Hier wird der KEY des Timers in der Timer-Liste an Hand seines Namens
-- ermittelt. Wenn kein Timer mit dem Namen zu finden ist, gibt die
-- Funktion nil zurÃ¼ck.
function avalonUI.findTimerByName(name)
	--debugc("findTimerByName\n")

  --[[Wenn der Name bspswse "Erdaura" lautet, dann muss gefunden werden:
  "Erdaura I", "Erdaura II", "Erdaura III".
  Analog dazu die anderen Auren. Und Schild I bis V]]
  
  --https://stackoverflow.com/questions/29072601/lua-string-gsub-with-a-hyphen
  --[[
  local function replace(str, what, with)
    what = string.gsub(what, "[%(%)%.%+%-%*%?%[%]%^%$%%]", "%%%1") -- escape pattern
    with = string.gsub(with, "[%%]", "%%%%") -- escape replacement
    return string.gsub(str, what, with)
  end
  
  result = replace(data, value_1, value_2)
  result = replace(date, "-", "%-")
  
  s = string.gsub("Lua is cute", "cute", "great")
  
  lua if string.find("EP-Verdoppelung", "EP%-Verdoppelung") then echo("true") else echo("false") end
  ]]
  --[[string.find funktioniert nicht mit Zeichen wie dem Bindestrich. Das fÃ¼hrte zu Problemen bei dem 
  Timer fÃ¼r "EP-Verdoppelung".]]
  for k, v in pairs(avalonUI.listOfTimers) do
      ----if v["name"] == name then return k end
      --if string.find(v["name"], name) then return k end
      if string.find(v["name"], string.gsub(name, "%-", "%%-")) then return k end
      
  end
  return nil
end -- function findTimerByName(name)


-- Diese Funktion wird von den Triggern verwendet, die einen Timer erzeugen.
-- Der Timer wird hier der Tabelle "listOfTimer" hinzugefÃ¼gt, anschlieÃend
-- wird die Tabelle mit den sortierten Timern neu erzeugt und die Anzeige
-- auf der OberflÃ¤che aktualisiert.
function avalonUI.registerTimer(name, duration, param)
  --debugc("\nregisterTimer\n")
  param = param or nil
  if param ~= nil then
    name = name .. " " .. param
  end
  if duration == false or duration == nil then
    duration = "false"
  end
  
  if name == "Schild" then
    if string.find(player.schutz, name .. " V") then
      name = name .. " V"
    elseif string.find(player.schutz, name .. " IV") then
      name = name .. " IV"
    elseif string.find(player.schutz, name .. " III") then
      name = name .. " III"
    elseif string.find(player.schutz, name .. " II") then
      name = name .. " II"
    elseif string.find(player.schutz, name .. " I") then
      name = name .. " I"
    end
  end
  
  if name == "Weissschild" or name == "Schwarzschild" then
    if string.find(player.schutz, name .. " II") then
      name = name .. " II"
    elseif string.find(player.schutz, name .. " I") then
      name = name .. " I"
    end
  end
  
  if name == "Erdaura" or name == "Feueraura" or name == "Lebensaura" or name == "Todesaura" or name == "Luftaura" or name == "Wasseraura" then
    if string.find(player.schutz, name .. " III") then
      name = name .. " III"
      duration = "1200"
    elseif string.find(player.schutz, name .. " II") then
      name = name .. " II"
    elseif string.find(player.schutz, name .. " I") then
      name = name .. " I"
    end
  end

  table.insert(avalonUI.listOfTimers, {["name"] = name, ["starttime"] = os.time(), ["duration"] = duration})

  raiseEvent("RecreateTimerView")
end



-- function removeTimer("Magiertrance")
-- Diese Funktion wird aufgerufen, wenn ein Timer gelÃ¶scht werden soll. Also wenn er 
-- abgelaufen ist (bei denen, die von selbst terminieren) oder wenn das Ereignis ausgelÃ¶st
-- wird, das den Timer beendet. (Das ist der hÃ¤ufigere Fall, weil sich die Anzeige da
-- letztlich nach dem MUD richtet. Wenn das MUD sagt, dass die KB aus ist, dann ist sie aus.
-- Viele Zauber sind ohnehin nicht sonderlich pÃ¼nktlich, aber die Laufzeit kann sich auch 
-- durch lags verlÃ¤ngern. Teilweise ganz erheblich. Das "von selbst terminieren" ist deshalb
-- eigentlich unglÃ¼cklich, geht aber manchmal nicht anders. Beispiel dafÃ¼r ist die 
-- "EP-Verdoppelung", die vom MUD nicht abgekÃ¼ndigt wird.)
-- Speziell die Kleriker-Segen machen hier eine Sonderbehandlung notwendig, womit sich der
-- Parameter "param" begrÃ¼ndet. Da diese Segen (RÃ¼stungssegen, Waffensegen und Schildsegen)
-- die gleichen Texte ausgeben, und der Trigger deshalb nicht erkennen kann, mit welchem 
-- Zauber er es zu tun hat. Und da aber beim LÃSCHEN des Timers wichtig ist, nicht den falschen
-- zu lÃ¶schen. Versucht der Trigger, den GEGENSTAND, auf den Gezaubert wird, aus dem getriggerten
-- Text auszulesen. Was auch eigentlich ganz gut gelingt, aber nicht immer schick ist. Dieser
-- Gegenstands-Name wird dann fÃ¼r den Namen des Timers verwendet. Es ergibt sich also sowas wie
-- "Segen: Langschwert" oder (schlimmstenfalls) "Segen: Paar Echsenlederhandschuhe". Wenn der Timer
-- dann spÃ¤ter gelÃ¶scht werden soll, muss das mit diesem Namen geschehen. Und der steht hier im
-- Parameter "param". Diese LÃ¶sung ist nicht schÃ¶n, und wenn die GÃ¶tter mein flehentliches Bitten
-- erhÃ¶ren, bekommt Avalet hoffentlich kÃ¼nftig den Zauber per ATCP. Aber erstmal ist es jetzt so.
function avalonUI.removeTimer(name)
  -- debugc("removeTimer\n")

  key = avalonUI.findTimerByName(name)
  if key ~= nil then
    table.remove(avalonUI.listOfTimers, key)
  end
  
  -- Die Anzeige auf der OberflÃ¤che erneuern:
  raiseEvent("RecreateTimerView")
end --function removeTimer(name)


function avalonUI.deregisterTimer(name, param)
  -- Der Parameter "param" ist optional und wird hier deshalb erstmal zuverlÃ¤ssig gemacht.
  -- Wenn ein param gegeben ist, wird er zum Teil des Namens.
  param = param or nil
  if param ~= nil then
    name = name .. " " .. param
  end

  avalonUI.removeTimer(name)
  raiseEvent("RecreateTimerView")
end


-- function recreateTimer()
-- Diese Funktion baut die Timer-Anzeige auf der OberflÃ¤che neu auf. Das heiÃt,
-- sie macht erstmal alle Timer-Gauges unsichtbar, bevor sie die Funktion aufruft,
-- die neue Timer macht ("refreshTimer()"). Der Sinn ist, dass nicht bei jeder
-- Aktualisierung der Timer-Gauges diese erstmal unsichtbar gemacht werden. NÃ¶tig
-- ist das ja nur, wenn sich die Anzahl der Timer verÃ¤ndert.
function avalonUI.recreateTimer()
	--debugc("func recreateTimer\n")
  
  -- Alle Timer unsichtbar machen und Beschriftung lÃ¶schen. Es gibt
  -- 9 Gauge-Elemente auf der OberflÃ¤che, also (max) 9 Timer:
  for k = 1, 9, 1 do
    hideWindow("avalonUI.Timer"..k.."_front")
    hideWindow("avalonUI.Timer"..k.."_back")	
    avalonUI["Timer"..k]:setText ("")
  end

  -- Timer-Anzeige neu aufbauen:
  avalonUI.refreshTimer()
end --function recreateTimer()


-- function refreshTimer()
-- Wird durch den Sekunden-Timer direkt aufgerufen
-- Wird bei anderen Gelegenheiten indirekt Ã¼ber "recreateTimer()" aufgerufen.
-- Diese Funktion aktualisiert die Anzeige der Timer auf der OberflÃ¤che bzw.
-- sie sorgt Ã¼berhaupt fÃ¼r eine Anzeige von Timern auf der OberflÃ¤che.
-- Wenn sich die Anzahl der anzuzeigenden Timer nicht Ã¤ndernt, mÃ¼ssen die Gauge-
-- Elemente vorher nicht unsichtbar gemacht werden. Wenn sich die Anzahl Ã¤ndert,
-- wird "recreateTimer()" ausgefÃ¼hrt (und von dort dann diese Funktion).
function avalonUI.refreshTimer()
	--debugc("func refreshTimer\n")

  -- gleich wieder aussteigen, wenn es gar keine Timer gibt:
  -- Hintergrund: bei einem Disconnect ist manchmal der TriggerTimer aktiv
  -- geblieben. Nach dem reconnect ist allerdings die Timer-Liste leer,
  -- so dass der Timer lÃ¤uft, aber nichts angezeigt wird. Besser wÃ¤re
  -- vermutlich, die Timer vernÃ¼nftig zu inititalisieren, also ggf. auch
  -- Timer weiterlaufen zu lassen. (EP-Verdoppelung war es hier, vielleicht
  -- weil der Timer nicht durch einen Trigger beendet wird.) TODO
  if #avalonUI.listOfTimers == nil or #avalonUI.listOfTimers == 0 then
      disableTimer("avaletTimersTimer")
  end
  
  -- Erstmal die Timer-Liste sortieren lassen:
	local sortedListOfTimers = avalonUI.sortListOfTimers()

	local timerSchriftfarbe = "white"
  
  for k, v in pairs(sortedListOfTimers) do
    showWindow("avalonUI.Timer"..k.."_front")
    showWindow("avalonUI.Timer"..k.."_back")		
    -- Der Wert des Gauge-Elements, das die Restzeit anzeigt, darf
    -- nicht kleiner als 1 werden, sonst kommt die Anzeige durcheinander.
    -- AuÃerdem wird die Schriftfarbe verÃ¤ndert:
    -- "fuchsia" fÃ¼r 0 Sekunden Restlaufzeit und alles drÃ¼ber hinaus.
    -- "rot" fÃ¼r 30 bis 1 Sekunde Restlaufzeit.
    -- "gelb" fÃ¼r 60 bis 30 Sekunden Restlaufzeit.
    -- "weiÃ" immer sonst
    if v["remaining"] &lt; 1 then
      v["remaining"] = 1
      timerSchriftfarbe="fuchsia"
    elseif v["remaining"] &lt; 30 then
      timerSchriftfarbe="red"
    elseif v["remaining"] &lt; 60 then
      timerSchriftfarbe="yellow"
    else
      timerSchriftfarbe="white"
    end
    -- Wert des Timers setzen:
    avalonUI["Timer"..k]:setValue(tonumber(v["remaining"]), tonumber(v["duration"]), [[&lt;b&gt;&lt;font color="]]..timerSchriftfarbe..[["&gt;&amp;nbsp;]] .. v["name"] .. [[&lt;/b&gt;&lt;/font&gt;]])
  end
end


-- Hier wird der Sekunden-Timer, der die Timer jeweils neu
-- berechnen lÃ¤sst, aktiviert bzw. deaktiviert.
function avalonUI.onRecreateTimerView(event, args)
	--debugc("onRecreateTimerView\n")

  -- Warum auch immer die Anzahl der Elemente in listOfTimers = nil sein sollte...
  if #avalonUI.listOfTimers ~= nil then
    -- Wenn es Timer in der listOfTimers gibt...
    if #avalonUI.listOfTimers &gt; 0 then
      -- ... muss auch der Timer laufen, der einmal pro Sekunde die Timer-Anzeige
      -- auf der OberflÃ¤che aktualisiert.
      enableTimer("avaletTimersTimer")
    else
      -- Ohne anzuzeigende Timer in der Liste kann der Aktualisierungs-Timer Pause machen
      disableTimer("avaletTimersTimer")
    end
  else
    disableTimer("avaletTimersTimer")
  end
  -- SchlieÃlich wird noch die OberflÃ¤che aktualisiert.
  avalonUI.recreateTimer()
end
registerAnonymousEventHandler("RecreateTimerView", "avalonUI.onRecreateTimerView")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createTopMenuModel</name>
				<packageName></packageName>
				<script>-- TopMenu: Das MenÃ¼ oberhalb des Hauptfensters

-- function avalonUI.createTopMenuModel()
-- Erzeugt die Daten, die dann als MenÃ¼ oberhalb des Hauptfensters angezeigt werden.
-- Das Zahnrad (fÃ¼r das Einstellungen-MenÃ¼) wird (zur Zeit noch) in der View hinzugefÃ¼gt.
function avalonUI.createTopMenuModel()
  -- MenÃ¼-Label dÃ¼rfen nicht in einem Container sein, deshalb sind die 
  -- Top-Level-EintrÃ¤ge direkt auf der OberflÃ¤che positioniert.
  GUIModel.TopMenuEntries = {}
  --cecho("&lt;magenta&gt;TopMenuEntries\n")
  function addTopMenuEntry(label, position, childs)
  	--TODO: validierung der Parameter (insbesondere der childs)
  	table.insert(GUIModel.TopMenuEntries,position,{label,childs})
  end
  
  -- Dummy-MenÃ¼:
  --addTopMenuEntry("Top1", 1, {{"Child1", 1, "label1", "luafun", {"a1","a2","a3"}}, {"Child2", 2, "label2", "luafun",{"a12","a22","a32"}},{"Child3", 1, "label3","luafun",{"a31", "a32", "a33"}}})
  --addTopMenuEntry("Top2", 2, {{"Child1", 1, "label1", "luafun", {"a1","a2","a3"}}, {"Child2", 2, "label2", "luafun",{"a12","a22","a32"}},{"Child3", 1, "label3", "luafun",{"a31", "a32", "a33"}}})
  --addTopMenuEntry("Top1a", 1, {{"Child1", 1, "label1", "luafun", {"a1","a2","a3"}}, {"Child2", 2, "label2", "luafun",{"a12","a22","a32"}},{"Child3", 1, "label3", "luafun",{"a31", "a32", "a33"}}})
  
  -- Muster zum HinzufÃ¼gen eines MenÃ¼s:
  --addTopMenuEntry(
  --	"Top1", 
  --	1, 
  --	{
  --		{"childName1", 1, "childBeschriftung1", "luafun", {"a1","a2","a3"}}, 
  --		{"childName2", 2, "childBeschriftung2", "luafun", {"a1","a2","a3"}}, 
  --		{"childName1a", 1, "childBeschriftung1a", "luafun", {"a1","a2","a3"}}
  --	}
  --)

end -- function avalonUI.createTopMenuModel()</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createGaugeModel</name>
				<packageName></packageName>
				<script>--createGaugeModel()


function avalonUI.createGaugeModel()

end


--------------------------------------------------------------------------------
-- Refresh Event Handler
--------------------------------------------------------------------------------


function avalonUI.onRefreshHealthBar(event, args)
	-- Das Gauge-Element wird bei einem "current value" von 0 vollstÃ¤ndig
	-- gefÃ¼llt angezeigt. Und ich hab keine Ahnung, was bei einem negativen
	-- Wert geschehen wÃ¼rde. Deshalb wird hier jeder Wert unter 1 auf 1
	-- gesetzt. In dem Text auf dem Gauge muss aber natÃ¼rlich der wirkliche
	-- Wert stehen, deshalb die unterschiedliche Behandlung hier.
	local currentValue = args[1]
	if currentValue &lt; 1 then
		currentValue = 1
	end
	
	local percent = -1 --math.ceil((100 / args[2]) * args[1])
  if args[1] == args[2] then
    percent = 100
  elseif args[1] == 0 then
    percent = 0
  else 
    percent = math.floor((100 / args[2]) * args[1])
  end
	
	avalonUI.Health:setValue(tonumber(currentValue), tonumber(args[2]), "&lt;b&gt;&lt;center&gt;" .. args[1] .. "/" .. args[2] .. "&lt;/center&gt;&lt;/br&gt;&lt;center&gt;TP&lt;/center&gt;&lt;/br&gt;&lt;center&gt;("..percent.."%)&lt;/center&gt;&lt;/b&gt;")
	-- avalonUI.Health:setValue(100,100,[[&lt;b&gt;&lt;center&gt;999/999&lt;/center&gt;&lt;/br&gt;&lt;center&gt;TP&lt;/center&gt;&lt;/b&gt;]])
	-- [[&lt;b&gt;&lt;font color="]]..timerSchriftfarbe..[["&gt;&amp;nbsp;]] .. v["name"] .. [[&lt;/b&gt;&lt;/font&gt;]]
end
registerAnonymousEventHandler("RefreshHealthBar", "avalonUI.onRefreshHealthBar")


function avalonUI.onRefreshEnduranceBar(event, args)
	-- Das Gauge-Element wird bei einem "current value" von 0 vollstÃ¤ndig
	-- gefÃ¼llt angezeigt. Und ich hab keine Ahnung, was bei einem negativen
	-- Wert geschehen wÃ¼rde. Deshalb wird hier jeder Wert unter 1 auf 1
	-- gesetzt. In dem Text auf dem Gauge muss aber natÃ¼rlich der wirkliche
	-- Wert stehen, deshalb die unterschiedliche Behandlung hier.
	local currentValue = args[1]
	if currentValue &lt; 1 then
		currentValue = 1
	end
	
	local percent = -1 --math.ceil((100 / args[2]) * args[1])
  if args[1] == args[2] then
    percent = 100
  elseif args[1] == 0 then
    percent = 0
  else
    percent = math.floor((100 / args[2]) * args[1])
  end
	
	avalonUI.Endurance:setValue(tonumber(currentValue), tonumber(args[2]), "&lt;b&gt;&lt;center&gt;" .. tostring(args[1]) .. "/" .. tostring(args[2]) .. "&lt;/center&gt;&lt;/br&gt;&lt;center&gt;AP&lt;/center&gt;&lt;/br&gt;&lt;center&gt;("..percent.."%)&lt;/center&gt;&lt;/b&gt;")
end
registerAnonymousEventHandler("RefreshEnduranceBar", "avalonUI.onRefreshEnduranceBar")


function avalonUI.onRefreshSpellpointsBar(event, args)
	-- Das Gauge-Element wird bei einem "current value" von 0 vollstÃ¤ndig
	-- gefÃ¼llt angezeigt. Und ich hab keine Ahnung, was bei einem negativen
	-- Wert geschehen wÃ¼rde. Deshalb wird hier jeder Wert unter 1 auf 1
	-- gesetzt. In dem Text auf dem Gauge muss aber natÃ¼rlich der wirkliche
	-- Wert stehen, deshalb die unterschiedliche Behandlung hier.
	local currentValue = args[1]
	if currentValue &lt; 1 then
		currentValue = 1
	end
	
  local percent = -1 --math.ceil((100 / args[2]) * args[1])
  if args[1] == args[2] then
    percent = 100
  elseif args[1] == 0 then
    percent = 0
  else 
    percent = math.floor((100 / args[2]) * args[1])
  end
	
	avalonUI.Spellpoints:setValue(tonumber(currentValue), tonumber(args[2]), "&lt;b&gt;&lt;center&gt;" .. args[1] .. "/" .. args[2] .. "&lt;/center&gt;&lt;/br&gt;&lt;center&gt;ZP&lt;/center&gt;&lt;/br&gt;&lt;center&gt;("..percent.."%)&lt;/center&gt;&lt;/b&gt;")
end
registerAnonymousEventHandler("RefreshSpellpointsBar", "avalonUI.onRefreshSpellpointsBar")


function avalonUI.onRefreshManaBar(event, args)
	-- Das Gauge-Element wird bei einem "current value" von 0 vollstÃ¤ndig
	-- gefÃ¼llt angezeigt. Und ich hab keine Ahnung, was bei einem negativen
	-- Wert geschehen wÃ¼rde. Deshalb wird hier jeder Wert unter 1 auf 1
	-- gesetzt. In dem Text auf dem Gauge muss aber natÃ¼rlich der wirkliche
	-- Wert stehen, deshalb die unterschiedliche Behandlung hier.
	local currentValue = args[1]
	if currentValue &lt; 1 then
		currentValue = 1
	end
	
	local percent = -1 --math.ceil((100 / args[2]) * args[1])
  if args[1] == args[2] then
    percent = 100
  elseif args[1] == 0 then
    percent = 0
  else
    percent = math.floor((100 / args[2]) * args[1])
  end
	
	avalonUI.Mana:setValue(tonumber(currentValue), tonumber(args[2]), "&lt;b&gt;&lt;center&gt;" .. args[1] .. "/" .. args[2] .. " Mana ("..percent.."%)&lt;/center&gt;&lt;/b&gt;")
end
registerAnonymousEventHandler("RefreshManaBar", "avalonUI.onRefreshManaBar")
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createSettingsModel</name>
				<packageName></packageName>
				<script>--createSettingsModel

function avalonUI.createSettingsModel()
  -- Generelle Variablen fÃ¼r das Tab-Element
  GUIModel.settingsElement = GUIModel.settingsElement or {
    tabs = {"Diverses", "Chat-Tabs", "Farben", "Ãber Avalet"},
  }
  -- Speichert das aktuell ausgewÃ¤hlte Element:
  GUIModel.settingsElement.currentTab = GUIModel.settingsElement.currentTab or GUIModel.settingsElement.tabs[1]
  
  for k,v in pairs(GUIModel.tabElement.tabs) do
  
    avalonUI.chats[v] = {}
    
  end
  
  GUIModel.settingsElement.timerGaugeDirection = "goofy" --or ""

end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>View</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>buildUI</name>
				<packageName></packageName>
				<script>function avalonUI.buildUI()
  --avalonUI.buildBoxes()
  avalonUI.buildInfoScreen()
  avalonUI.buildChat()
  avalonUI.buildTopBar()
  --avalonUI.buildMapper()
  avalonUI.buildCounter()
  avalonUI.buildTimer()
  
  avalonUI.buildSettingsDialog()
  
  GUIframe.disable("top")
  GUIframe.disable("bottom")
  GUIframe.disable("right")
  GUIframe.disable("left")
end

function unlockUI()
  --GUIframe.enable("top")
  --GUIframe.enable("bottom")
  GUIframe.enable("right")
  GUIframe.enable("left")
  avalonUI.buildChat()
  raiseEvent("RecreateTimerView")
end

function lockUI()
  GUIframe.disable("top")
  GUIframe.disable("bottom")
  GUIframe.disable("right")
  GUIframe.disable("left")
  avalonUI.buildChat()
  raiseEvent("RecreateTimerView")
end


-- Diese Funktion wird durch den "sysInstall"-Event aufgerufen, also bei jedem
-- Neustart von Mudlet. Hier wird Avalet initialisiert. Eine weitere Funktion,
-- die beim "sysInstall"-Event aufgerufen wird, steht weiter unten.
function avalonUI.UIInstalled(_, name)
  if name ~= "Avalet" then
    return
  else
    player = avalonUI.initCharacter()
    avalonUI.initTimer()
    
    GUIModel = GUIModel or {}
    avalonUI.createInfoScreenModel()
    avalonUI.createChatModel()
    avalonUI.createTopMenuModel()
    --avalonUI.createMapperModel()
    avalonUI.createTimerModel()
    avalonUI.createCounterModel()
    avalonUI.createGaugeModel()  

    avalonUI.createSettingsModel()  
    
    avalonUI.buildUI()
    --tempTimer(0, [[avalonUI.updateChar()]])
  end
end
registerAnonymousEventHandler("sysInstall", "avalonUI.UIInstalled")


</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildBoxes</name>
				<packageName></packageName>
				<script>----------------------------------------
-- Boxes
-- Die Boxen definieren die entgÃ¼ltige Unterteilung der OberflÃ¤che. Es gibt also eine Boxen
-- fÃ¼r die Elemente, die TP, ZP, AP und Mana anzeigen. (Links unten.) Eine weitere fÃ¼r die 
-- Timer links in der Mitte. Eine weitere fÃ¼r das Karten-Widget links oben. Eine fÃ¼r die
-- Charakterinformationen rechts oben. Und eine fÃ¼r das Tab-Element rechts unten.
-- Im Bereich oben in der Mitte gibt es keine Box. Der Grund ist oben bei den Backgrounds 
-- dokumentiert.
-- Die Boxen haben hauptsÃ¤chlich den Zweck, einen (derzeit weiÃen) Rahmen um die Bereiche 
-- anzeigen zu kÃ¶nnen. Ansonsten sind sie Container fÃ¼r weitere Elemente, die die dort
-- sichtbaren Informationen anzeigen.
----------------------------------------
-- wird nicht verwendet!
function avalonUI.buildBoxes()
  -- Box1 ist das Element rechts oben, in dem die Charakterinformationen ausgegeben werden.
  avalonUI.Box1 = Geyser.Label:new({
  	name = "avalonUI.Box1",
  	x = 0, y = 0,
  	width = "100%",
  	height = "50%",
  })
  avalonUI.Box1:setStyleSheet(avalonUI.CSS.boxCSS:getCSS())
  --avalonUI.Box1:echo("&lt;center&gt;avalonUI.Box1")
  GUIframe.addWindow(avalonUI.Box1, 'Box1', 'topright')
  
end
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildChat</name>
				<packageName></packageName>
				<script>--------------------------------------------
--- Tabs-Element rechts unten
-------------------------------------------
function avalonUI.buildChat()

  -- Box2: In diesem Bereich wird das Tabulatoren-Element rechts unten angezeigt.
  avalonUI.Box2 = Geyser.Label:new({
  	name = "avalonUI.Box2",
  	x = 0, y = "50%",
  	width = "100%",-- 50%
  	height = "50%",
  })--, avalonUI.Right)
  avalonUI.Box2:setStyleSheet(avalonUI.CSS.boxCSS:getCSS())
  GUIframe.addWindow(avalonUI.Box2, "Chat", "bottomright")

  
  avalonUI.tabElement = {}
  -- Container, der alles andere enthÃ¤lt. Container sind unsichtbar, deshalb kein Stylesheet
  avalonUI.tabElement.Container = Geyser.Container:new({
    name = "avalonUI.tabElement.Container",
    x = "3%", y = "3%",
    width = "94%",
    height = "94%",
  }, avalonUI.Box2)

  -- die Kopfzeile des Tab-Elements, also da wo die Tabs sind
  avalonUI.tabElement.Header = Geyser.HBox:new({
    name = "avalonUI.tabElement.Header",
    x = 0, y = 0,
    width = "100%",
    height = "10%",
  }, avalonUI.tabElement.Container)


  -- Der KÃ¶rper des Tab-Elements, also da wo der Inhalt steht.
  -- Der Container fÃ¼r jeden Tab-Inhalt
  avalonUI.tabElement.Footer = Geyser.Label:new({
    name = "avalonUI.tabElement.Footer",
    x = 0, y = "10%",
    width = "100%",
    height = "90%",
  }, avalonUI.tabElement.Container)
  avalonUI.tabElement.Footer:setStyleSheet(avalonUI.CSS.tabElementFooterCSS:getCSS())


  -- Each window actually has two labels. One for the light blue background,
  -- and another for the dark blue center. This will create that dark blue center. 
  avalonUI.tabElement.Center = Geyser.Label:new({
    name = "avalonUI.tabElement.Center",
    x = 0, y = 0,
    width = "100%",
    height = "100%",
  }, avalonUI.tabElement.Footer)
  avalonUI.tabElement.Center:setStyleSheet(avalonUI.CSS.tabElementCenterCSS:getCSS())


  -- Hier werden die Tabs und die Seiten dazu erzeugt.
  avalonUI.tabElement.tabs = {}

	for k, v in pairs(GUIModel.tabElement.tabs) do
	
		if avalonUI.tabElement.tabs[v.."tab"] == nil then

			-- Erzeugt einen Tab fÃ¼r jeden Eintrag in der Menu-Liste
			avalonUI.tabElement.tabs[v.."tab"] = Geyser.Label:new({
				name = "avalonUI.tabElement.tabs."..v.."tab",
			  }, avalonUI.tabElement.Header)
			avalonUI.tabElement.tabs[v.."tab"]:setFontSize(avalonUI.chatTabFontSize)	  
			avalonUI.tabElement.tabs[v.."tab"]:setStyleSheet(avalonUI.CSS.MenuTabCSS:getCSS())
			avalonUI.tabElement.tabs[v.."tab"]:echo("&lt;center&gt;"..v)

			-- We need our tabs to do stuff when clicked, so we'll assign it 
     -- a callback function, avalonUI.tabElement.tabs.click, which we'll create later on.
     -- Our tab name is the argument. 
			avalonUI.tabElement.tabs[v.."tab"]:setClickCallback("avalonUI.tabElementOnClick", v)

			-- Now we create the windows that appear when each tab is clicked.
     -- Each window has two labels, one atop the other. The first, which we'll create here,
     -- has rounded edges on its bottom. 
			avalonUI.tabElement.tabs[v] = Geyser.Label:new({
				name = "avalonUI.tabElement.tabs."..v,
				x = 0, y = 0,
				width = "100%",
				height = "100%",
			  }, avalonUI.tabElement.Footer)
			avalonUI.tabElement.tabs[v]:setStyleSheet(avalonUI.CSS.tabElementAtopCSS:getCSS())
			-- The second label serves as the window's center and has rounded edges on all sides. 
     -- And a margin of 5px from it's parent, the label we just created. When adding stuff
     -- to your windows, this is the label you'll want to use. avalonUI.tabElement.tabs.&lt;tabname&gt;center
			avalonUI.tabElement.tabs[v.."center"] = Geyser.Label:new({
				name = "avalonUI.tabElement.tabs."..v.."center",
				x = 0, y = 0,
				width = "100%",
				height = "100%",
			  }, avalonUI.tabElement.tabs[v])
			avalonUI.tabElement.tabs[v.."center"]:setStyleSheet(avalonUI.CSS.tabElementCenterTabCSS:getCSS())

			--------
			-- Inhalte der Tabs
			-- Alle Tabs enthalten eine Mini-Console.
			-- Bei den Kanal-Tabs wird dort die Ausgabe der entsprechenden KanÃ¤le gesammelt angezeigt.
			-- Bei anderen Tabs gibt es andere Inhalte.
			-- Jede Minikonsole ist ansprechbar Ã¼ber ... ???
			avalonUI.tabElement.tabs[v.."console"] = Geyser.MiniConsole:new({
				name=string.title(v),
				x="2%", y="2%",
				width = "96%",
				height = "96%",
				autoWrap = true,
				color = "black",
				scrollBar = true,--false,
				fontSize = avalonUI.chatFontSize,
			}, avalonUI.tabElement.tabs[v.."center"])
			debugc("&lt;magenta&gt;Consolen-Name: "..string.title(v).."\n")
			setWindowWrap(string.title(v), 56)
			--avalonUI.infobox:setColor("black") -- give it a nice black background
			--avalonUI.infobox:setFont("Bitstream Vera Sans Mono")
      if avalonUI.font ~= "main" then
        avalonUI.tabElement.tabs[v.."console"]:setFont(avalonUI.font)
      else
        avalonUI.tabElement.tabs[v.."console"]:setFont(getFont("main"))
      end      
			--clearWindow("avalonUI.tabElement.tabs." .. v .. "console")
		--	avalonUI.tabElement.tabs[v.."console"]:echo(GUIModel.tabElement["chat"..v])
			avalonUI.tabElement.tabs[v.."console"]:echo(v)

			-- Finally, we hide all the windows and end the for loop.
			avalonUI.tabElement.tabs[v]:hide()

		end -- if nil
	end  -- for

  raiseEvent("RefreshTabElement", GUIModel.tabElement.currentTab)
  --avalonUI.tabElement.tabs[GUIModel.tabElement.currentTab]:show()
  avalonUI.tabElementOnClick(GUIModel.tabElement.currentTab)

end


-- The last step is to create our callback function for when a tab is clicked.
-- This will hide that tab that is stored in menu.current, set menu.current to
-- the clicked tab, and then show the menu.current tab. 
function avalonUI.tabElementOnClick(tab)
	-- Das hier funktioniert nur, wenn die Tab-Beschriftung dem Channel
	-- entspricht, also dem Namen der Datei, in die die Inhalte des
	-- Tabs vorher geschrieben wurden. Minus dem .txt
--avalonUI.tabElement.tabs[tab.."tab"]:setFontSize(avalonUI.chatTabFontSize)  
  avalonUI.tabElement.tabs[GUIModel.tabElement.currentTab.."tab"]:setStyleSheet(avalonUI.CSS.MenuTabCSS:getCSS())
	avalonUI.tabElement.tabs[GUIModel.tabElement.currentTab]:hide()
	GUIModel.tabElement.currentTab = tab
	--refreshTabElement(tab)
  --echo("TAB: " .. tab .. "\n")
  raiseEvent("RefreshTabElement", tab)
  avalonUI.tabElement.tabs[tab.."tab"]:setStyleSheet(avalonUI.CSS.MenuTabCurrentCSS:getCSS())
  avalonUI.tabElement.tabs[GUIModel.tabElement.currentTab]:show()
end

function avalonUI.markTab(tab)
  --Manche KanÃ¤le haben keinen Tab, der wÃ¤re dann hier "nil" (gebrÃ¼ll z.b.)
  if avalonUI.tabElement.tabs[tab.."tab"] == nil then
    debugc("\n\nTab zum Markieren ist nil: "..tab.."\n\n")
  elseif avalonUI.CSS.MenuTabMarkedCSS == nil then
    debugc("\n\nCSS zum Markieren ist nil: "..tab.."\n\n")
  else
    avalonUI.tabElement.tabs[tab.."tab"]:setStyleSheet(avalonUI.CSS.MenuTabMarkedCSS:getCSS())
  end
  
  --avalonUI.tabElement.tabs[tab.."tab"]:setStyleSheet(avalonUI.CSS.MenuTabMarkedCSS:getCSS())

end


</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildCounter</name>
				<packageName></packageName>
				<script>function avalonUI.buildCounter()

  -- Box5 enthÃ¤lt die Fortschrittsbalken, mit denen die Timer angezeigt werden. Links in 
  -- der Mitte. Box5 ist kein Label-Element, sondern ein Container, und die sind unsichtbar(?)
  -- Deshalb geht das hier mit dem weiÃen Rahmen nicht. LÃ¶sung ist, hier noch ein Label
  -- zu nehmen, dort dann den Container drin, und in dem dann die Gauges.
  avalonUI.Box4a = Geyser.Container:new({
  	name = "avalonUI.Box4a",
  	x = "0%", y = "0%",
  	width = "100%",
  	height = "50%",
  })--, avalonUI.Box5a)
  GUIframe.addWindow(avalonUI.Box4a, "Zaehler", "topleft")  


  avalonUI.Box4 = Geyser.Label:new({
    name = "avalonUI.Box4",
    x = "0%", y = "0%",
    width = "100%",
    height = "100%",
  }, avalonUI.Box4a)
  avalonUI.Box4:setStyleSheet(avalonUI.CSS.boxCSS:getCSS())
  --GUIframe.addWindow(avalonUI.Box4, "Zaehler", "topleft")

---------------------------------------------------------------------------
  -- Gauges fÃ¼r die Timer
  -- Hier werden (derzeit) 9 Gauge-Elemente fÃ¼r die Timer erzeugt und positioniert.
  -- in der Funktion "recreateTimer" werden die Timer dann alle unsichtbar und
  -- nur die benÃ¶tigten werden wieder sichtbar und mit Werten beschrieben.
  -- Eigentlich war geplant, die Timer dynamischer zu gestalten, so dass es auch
  -- mehr als neun werden kÃ¶nnten. (Der Rest sollte dann etwas zusammen rÃ¼cken.)
  -- Aber es scheint nicht mÃ¶glich zu sein, einmal erzeugte Gauge-Elemente wieder
  -- zu lÃ¶schen. (Auf nil setzen wirkt jedenfalls nicht.) Deshalb die statische
  -- LÃ¶sung und das unsichtbar machen.
  ---------------------------------------------------------------------------
  
  for k = 1, 6, 1 do
    avalonUI["Counter"..k] = Geyser.Label:new({
      name = "avalonUI.Counter"..k,
      x = "3%", y = (4 + (k-1)*15).."%",
      width="94%", height="17%",
    }, avalonUI.Box4)
    avalonUI["Counter"..k]:setStyleSheet(avalonUI.CSS.counterCSS:getCSS())
    avalonUI["Counter"..k]:setFontSize(10)
    avalonUI["Counter"..k]:hide()
  end

  --avalonUI["Counter1"]:echo("&lt;b&gt;&amp;nbsp;Session-EP: 782392&amp;nbsp;")
  --avalonUI["Counter2"]:echo("&lt;b&gt;&amp;nbsp;EP/EP-Verdoppelung: 662958&amp;nbsp;")
  --avalonUI["Counter3"]:echo("&lt;b&gt;&amp;nbsp;EP letzte Stunde: 731294&amp;nbsp;&lt;/b&gt;")
  --avalonUI["Counter4"]:echo("&lt;b&gt;&amp;nbsp;EP/Arkanschild: 43392&amp;nbsp;&lt;/b&gt;&lt;\ br&gt;&amp;nbsp;letzter Wert: 41625&amp;nbsp;")
  --avalonUI["Counter5"]:echo("&lt;b&gt;&amp;nbsp;Kampfdauer: 232s&amp;nbsp;&lt;/b&gt;&lt;\ br&gt;&amp;nbsp;letzter Wert: 376s&amp;nbsp;")

  avalonUI.recreateCounter()

end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildInfoScreen</name>
				<packageName></packageName>
				<script>-----------------------------------------------------
-- Charakter-Informationen rechts oben
-----------------------------------------------------
function avalonUI.buildInfoScreen()

  -- Box1 ist das Element rechts oben, in dem die Charakterinformationen ausgegeben werden.
  avalonUI.Box1 = Geyser.Label:new({
  	name = "avalonUI.Box1",
  	x = 0, y = 0,
  	width = "100%",
  	height = "50%",
  })
  avalonUI.Box1:setStyleSheet(avalonUI.CSS.boxCSS:getCSS())
  --avalonUI.Box1:echo("&lt;center&gt;avalonUI.Box1")
  GUIframe.addWindow(avalonUI.Box1, "Info-Screen", "topright")
    
  avalonUI.infobox = Geyser.MiniConsole:new({
    name="Infobox",
    x="3%", y="3%",
    width = "94%",
    height = "94%",
    autoWrap = true,
    color = "black",
    scrollBar = false,
    fontSize = avalonUI.infoBoxFontSize,
  }, avalonUI.Box1)
  avalonUI.infobox:setColor("black") -- give it a nice black background
  --avalonUI.infobox:setFont("Bitstream Vera Sans Mono")
  if avalonUI.font ~= "main" then
    avalonUI.infobox:setFont(avalonUI.font)
  else
    avalonUI.infobox:setFont(getFont("main"))
  end
  
  setWindowWrap("Infobox", 60)
  clearWindow("Infobox")
  --avalonUI.infobox:echo(GUIModel.infobox)
  --avalonUI.infobox:echo("initialisiert")

end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildMapper</name>
				<packageName></packageName>
				<script>function avalonUI.buildMapper()

  avalonUI.Box4 = Geyser.Label:new({
    name = "avalonUI.Box4",
    x = "0%", y = "0%",
    width = "100%",
    height = "50%",
  })--, avalonUI.Left)
  avalonUI.Box4:setStyleSheet(avalonUI.CSS.boxCSS:getCSS())
  GUIframe.addWindow(avalonUI.Box4, "Map", "topleft")
  
  
  ----------------------------------------
  -- Mapper (Karte) links oben
  ----------------------------------------
  
--  avalonUI.Mapper = Geyser.Mapper:new({ 
--  	name = "Mapper",
--  	x = "5%", y = "5%", 
--  	width = "90%", 
--  	height = "90%"
--  }, avalonUI.Box4)

end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildTimer</name>
				<packageName></packageName>
				<script>function avalonUI.buildTimer()
  
  -- Box5 enthÃ¤lt die Fortschrittsbalken, mit denen die Timer angezeigt werden. Links in 
  -- der Mitte. Box5 ist kein Label-Element, sondern ein Container, und die sind unsichtbar(?)
  -- Deshalb geht das hier mit dem weiÃen Rahmen nicht. LÃ¶sung ist, hier noch ein Label
  -- zu nehmen, dort dann den Container drin, und in dem dann die Gauges.
  avalonUI.Box5c = Geyser.Container:new({
  	name = "avalonUI.Box5c",
  	x = "0%", y = "0%",
  	width = "100%",
  	height = "100%",
  })--, avalonUI.Box5a)
  --avalonUI.Box5:setStyleSheet(avalonUI.CSS.BoxCSS:getCSS())
  GUIframe.addWindow(avalonUI.Box5c, "Timer", "bottomleft")  



  avalonUI.Box5a = Geyser.Label:new({
  	name = "avalonUI.Box5a",
  	x = "0%", y = "0%",
  	width = "100%",
  	height = "70%",
  }, avalonUI.Box5c)--, avalonUI.Left)
  avalonUI.Box5a:setStyleSheet(avalonUI.CSS.boxCSS:getCSS())
  --GUIframe.addWindow(avalonUI.Box5a, "Timer", "bottomleft")  

  
--  avalonUI.Box5 = Geyser.Container:new({
--  	name = "avalonUI.Box5",
--  	x = "2%", y = "0%",
--  	width = "98%",
--  	height = "100%",
--  }, avalonUI.Box5a)
--  --avalonUI.Box5:setStyleSheet(avalonUI.CSS.BoxCSS:getCSS())

  -- Box7 enthÃ¤lt die Fortschrittsbalken, mit denen TP, AP, ZP und Mana angezeigt werden. Links
  -- unten. Box7 ist auch kein Label-Element, sondern ein Container, deshalb gilt auch hier,
  -- was oben bei Box5 dokumentiert ist. Auch ein TODO.
  avalonUI.Box7 = Geyser.Container:new({
    name = "avalonUI.Box7",
    x = "0%", y = "70%",
    width = "100%",
    height = "30%",
  }, avalonUI.Box5c)
  --avalonUI.Box7:setStyleSheet(avalonUI.BoxCSS:getCSS())
  
  
  
  
  
  
  ---------------------------------------------------------------------------
  -- Gauges fÃ¼r die Timer
  -- Hier werden (derzeit) 9 Gauge-Elemente fÃ¼r die Timer erzeugt und positioniert.
  -- in der Funktion "recreateTimer" werden die Timer dann alle unsichtbar und
  -- nur die benÃ¶tigten werden wieder sichtbar und mit Werten beschrieben.
  -- Eigentlich war geplant, die Timer dynamischer zu gestalten, so dass es auch
  -- mehr als neun werden kÃ¶nnten. (Der Rest sollte dann etwas zusammen rÃ¼cken.)
  -- Aber es scheint nicht mÃ¶glich zu sein, einmal erzeugte Gauge-Elemente wieder
  -- zu lÃ¶schen. (Auf nil setzen wirkt jedenfalls nicht.) Deshalb die statische
  -- LÃ¶sung und das unsichtbar machen.
  ---------------------------------------------------------------------------
  
  for k = 1, 9, 1 do
  	avalonUI["Timer"..k] = Geyser.Gauge:new({
  		name = "avalonUI.Timer"..k,
  		x = "5%", y = (100-(k*10)-5).."%",
  		width="90%", height="9%",
  		orientation = avalonUI.timerOrientation, --"goofy"
  	}, avalonUI.Box5a)
  	avalonUI["Timer"..k].back:setStyleSheet(avalonUI.CSS.GaugeBackCSS:getCSS())
  	avalonUI.CSS.GaugeFrontCSS:set("background-color", avalonUI.GaugeFrontColorTimer)
  	avalonUI["Timer"..k].front:setStyleSheet(avalonUI.CSS.GaugeFrontCSS:getCSS())
  	avalonUI["Timer"..k]:setValue(600, 600, "")
  end
  
  avalonUI.recreateTimer()
  
  
  -----------------------------------
  -- Gauges fÃ¼r TP, AP, ZP und Mana
  -----------------------------------
  
  avalonUI.Health = Geyser.Gauge:new({
    name = "avalonUI.Health",
    x = "2%", y = "0%",
    width="30%", height="75%",
    orientation="vertical",
  }, avalonUI.Box7)
  avalonUI.Health.back:setStyleSheet(avalonUI.CSS.GaugeBackCSS:getCSS())
  avalonUI.CSS.GaugeFrontCSS:set("background-color", avalonUI.GaugeFrontColorTP)
  avalonUI.Health.front:setStyleSheet(avalonUI.CSS.GaugeFrontCSS:getCSS())
  avalonUI.Health.text:setStyleSheet(avalonUI.CSS.GaugeTextCSS:getCSS())
  avalonUI.Health.text:setFontSize(9)	
  avalonUI.Health:setValue(100,100,[[&lt;b&gt;&lt;center&gt;TP&lt;/center&gt;&lt;/b&gt;]])

  
  avalonUI.Endurance = Geyser.Gauge:new({
    name = "avalonUI.Endurance",
    x = "35%", y = "0%",
    width="30%", height="75%",
    orientation="vertical",
  }, avalonUI.Box7)
  avalonUI.Endurance.back:setStyleSheet(avalonUI.CSS.GaugeBackCSS:getCSS())
  avalonUI.CSS.GaugeFrontCSS:set("background-color", avalonUI.GaugeFrontColorAP)
  avalonUI.Endurance.front:setStyleSheet(avalonUI.CSS.GaugeFrontCSS:getCSS())
  avalonUI.Endurance.text:setStyleSheet(avalonUI.CSS.GaugeTextCSS:getCSS())
  avalonUI.Endurance.text:setFontSize(9)
  avalonUI.Endurance:setValue(100,100,[[&lt;b&gt;&lt;center&gt;AP&lt;/center&gt;&lt;/b&gt;]])
  
  
  avalonUI.Spellpoints = Geyser.Gauge:new({
    name = "avalonUI.Spellpoints",
    x = "68%", y = "0%",
    width="30%", height="75%",
    orientation="vertical",
  }, avalonUI.Box7)
  avalonUI.Spellpoints.back:setStyleSheet(avalonUI.CSS.GaugeBackCSS:getCSS())
  avalonUI.CSS.GaugeFrontCSS:set("background-color", avalonUI.GaugeFrontColorZP)
  avalonUI.Spellpoints.front:setStyleSheet(avalonUI.CSS.GaugeFrontCSS:getCSS())
  avalonUI.Spellpoints.text:setStyleSheet(avalonUI.CSS.GaugeTextCSS:getCSS())
  avalonUI.Spellpoints.text:setFontSize(9)
  avalonUI.Spellpoints:setValue(100,100, [[&lt;b&gt;&lt;center&gt;ZP&lt;/center&gt;&lt;/b&gt;]])

  
  avalonUI.Mana = Geyser.Gauge:new({
    name = "avalonUI.Mana",
    x = "2%", y = "78%",
    width="96%", height="20%",
  }, avalonUI.Box7)
  avalonUI.Mana.back:setStyleSheet(avalonUI.CSS.GaugeBackCSS:getCSS())
  avalonUI.CSS.GaugeFrontCSS:set("background-color", avalonUI.GaugeFrontColorMana)
  avalonUI.Mana.front:setStyleSheet(avalonUI.CSS.GaugeFrontCSS:getCSS())
  avalonUI.Mana.text:setFontSize(9)
  avalonUI.Mana:setValue(9999,9999, [[&lt;b&gt;&lt;center&gt;Mana&lt;/center&gt;&lt;/b&gt;]])

end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>buildTopMenu</name>
				<packageName></packageName>
				<script>-- Top-MenÃ¼
-- MenÃ¼-Label dÃ¼rfen nicht in einem Container sein, deshalb sind die 
-- Top-Level-EintrÃ¤ge direkt auf der OberflÃ¤che positioniert.

function avalonUI.buildTopBar()

  avalonUI.topBar = Geyser.Label:new({
    name = "avalonUI.topBar",
    x = "15%", y = "0%",
    width = "50%",
    height = "7%",
    --nestable = true,
  })
  avalonUI.topBar:setStyleSheet(avalonUI.CSS.boxCSS:getCSS())
  GUIframe.addWindow(avalonUI.topBar, "TopBar", "top")

	d = 0
	for k, v in ipairs(GUIModel.TopMenuEntries) do

		avalonUI["TopMenu"..v[1]] = Geyser.Label:new({ 
			name = "TopMenu"..v[1], 
			x = tostring(17+d*10).."%", 
			y = "1.5%" , 
			width = 200,
			height = 35,
			nestable = true,
		})
		avalonUI["TopMenu"..v[1]]:setStyleSheet(avalonUI.CSS.MenuLabelCSS:getCSS())
		avalonUI["TopMenu"..v[1]]:setFontSize(12)
		avalonUI["TopMenu"..v[1]]:echo(v[1])
		--GUI["TopMenu"..v[1]]:echo([[&lt;p style="font-size:22px"&gt;&lt;b&gt;&lt;font color="white"&gt;]]..v[1])
		--setLabelClickCallback( "TopMenuOptions", "ClickTopMenuPreferences")
		--setLabelClickCallback(labelName, luaFunctionName, [any arguments])
		local subMenuEntries = {}
		for k2, v2 in ipairs(v[2]) do
			-- erstmal sortierte table der sub-entries bauen
			table.insert(subMenuEntries, v2[2], {v2[1], v2[3], v2[4], v2[5]}) -- tabelle, position, {name, message, luafunct, args}
		end
		for k3, v3 in ipairs(subMenuEntries) do
			avalonUI["TopMenu"..v[1]..v3[1]] = avalonUI["TopMenu"..v[1]]:addChild({
				name = "TopMenu"..v[1]..v3[1],
				height = 50,
				width = 100, 
				flyOut=true,
				layoutDir="BV", 
				message=v3[2]
			})
			avalonUI["TopMenu"..v[1]..v3[1]]:setStyleSheet(avalonUI.CSS.MenuLabelCSS:getCSS())
			--TopMenuOptions[i]:setStyleSheet(LabelCSS:getCSS())
			--setLabelClickCallback( "TopMenuOptions"..i, "ClickTopMenuCallback","tDir[i]","bla bla")
			--setLabelClickCallback(labelName, luaFunctionName, [any arguments])
		end

		--if v[5] then
		--	for i=1,#v[5] do
		--		echo ("arg["..i.."] = "..v[5][i].."\n")
		--	end
		--end
		d = d+1
	end
    
  
  -------------------------
  -- MenÃ¼ "Options"
  -------------------------
  -- wird hier extra hinzugefÃ¼gt.
  -- MenÃ¼-Label dÃ¼rfen nicht in einem Container sein, deshalb sind die Top-Level-EintrÃ¤ge direkt auf der OberflÃ¤che positioniert.
  avalonUI.TopMenuOptions= Geyser.Label:new({ 
  	name = "TopMenuOptions", 
  	x = "62%", 
  	y = "1.5%" , 
  	width = 35,
  	height = 30,
  	nestable = true,
  })
  avalonUI.TopMenuOptions:setStyleSheet(avalonUI.CSS.MenuLabelCSS:getCSS())
  avalonUI.TopMenuOptions:setFontSize(12)
  avalonUI.TopMenuOptions:setCursor("PointingHand")
  avalonUI.TopMenuOptions:echo([[&amp;#9881;]])
  --avalonUI.TopMenuOptions:echo([[&lt;p style="font-size:22px"&gt;&lt;b&gt;&lt;font color="white"&gt;&amp;#9881;]])
  --setLabelClickCallback( "TopMenuOptions", "ClickTopMenuPreferences")
  setLabelClickCallback( "TopMenuOptions", "avalonUI.showSettingsDialog")
  --setLabelClickCallback(labelName, luaFunctionName, [any arguments])
  
  --i = 1
  --avalonUI.TopMenuOptions[i] = avalonUI.TopMenuOptions:addChild({
  --	name = "TopMenuOptions"..i,
  --	height = 50,
  --	width = 100, 
  --	flyOut=true,
  --	layoutDir="BV", 
  --	message="comming soon"
  --})
  --avalonUI.TopMenuOptions[i]:setStyleSheet(avalonUI.CSS.MenuLabelCSS:getCSS())
  ----setLabelClickCallback( "TopMenuOptions"..i, "ClickTopMenuCallback","tDir[i]","bla bla")
  ----setLabelClickCallback(labelName, luaFunctionName, [any arguments])

end</script>
				<eventHandlerList />
			</Script>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>SettingsDialog</name>
				<packageName></packageName>
				<script>--SettingsDialog
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>buildSettingsDialog</name>
					<packageName></packageName>
					<script>-- buildSettings
-- Also das UI fÃ¼r die Settings zu machen war wirklich kein SpaÃ. Die Elemente, die
-- Mudlet dafÃ¼r bereit stellt, sind mehr als dÃ¼rftig. Kann aber auch sein, dass ich
-- einfach eine falsche Vorstellung entwickelt hab, wie das aussehen soll. Statt mehr
-- Ã¼ber Mudlet zu wissen und das dann einfach so zu machen, wie es vllt. gedacht ist.
-- Jedenfalls tuts mir fÃ¼r jede/n leid, die/der sich hier einarbeiten muss.
-- Ach ja: mÃ¶glicherweise wÃ¤re eine bessere LÃ¶sung gewesen, eine Miniconsole zu verwenden,
-- und das MenÃ¼ dann irgendwie mit anklickbarem Text zu machen. Die Anleitung dafÃ¼r hab
-- ich wohl gesehen. Aber ich bin mit den FormatierungsmÃ¶glichkeiten nicht zurecht gekommen.
-- Also mit den anscheinend nicht vorhandenen FormatierungsmÃ¶glichkeiten. Und weil auch
-- keine Unicode-Zeichen dargestellt wurden, hab ich das nicht weiter verfolgt. Das 
-- wÃ¤re aber vielleicht ein vielversprechender Ansatz. 


-- Die Tabs, zu denen hinzugefÃ¼gt werden muss:
-- avalonUI.settings.Diversescenter
-- avalonUI.settings.Chats-Tabscenter
-- avalonUI.settings.Farbencenter
-- avalonUI.settings.Ãber Avaletcenter


function avalonUI.buildSettingsDialog()

--  settingsDialogWindow = Geyser.UserWindow:new({
--    name = "settingsDialogWindow",
--    titleText ="Einstellungen", -- only available since Mudlet 4.8+
--    x = "20%", y="20%",
--    width="30%", height ="40%"
--  })
--  settingsDialogWindow:disableAutoDock()

  mainWidth, mainHeight = getMainWindowSize()
  
  posX = 0
  posX = mainWidth/2 - avalonUI.settingsSettings.width/2
  posY = 0
  posY = mainHeight/2 - avalonUI.settingsSettings.height/2
  
  avalonUI.settingsDialogWindow = avalonUI.settingsWindow or Adjustable.Container:new({name="avalonUI.settingsDialogWindow"})
  --avalonUI.settingsDialogWindow:setTitle("Einstellungen")       -- "Titel" ist per default grÃ¼n
  avalonUI.settingsDialogWindow:setTitle("Einstellungen","white") -- Hier ist der Titel weiÃ
  avalonUI.settingsDialogWindow:resize(avalonUI.settingsSettings.width, avalonUI.settingsSettings.height)
  avalonUI.settingsDialogWindow:move(posX, posY)
  avalonUI.settingsDialogWindow:setFontSize(14)

  avalonUI.settings.createTabbedLayer()
  avalonUI.settings.addTabs()

-- avalonUI.settings.Diversescenter
-- avalonUI.settings.Chats-Tabscenter
-- avalonUI.settings.Farbencenter
-- avalonUI.settings.Ãber Avaletcenter

  --cecho("&amp;lt;magenta&amp;gt;\n1\n")
--  avalonUI.createSettingsTabs()
  --cecho("&amp;lt;magenta&amp;gt;\n2\n")
  avalonUI.buildGeneralSettings()
  --cecho("&amp;lt;magenta&amp;gt;\n3\n")
  avalonUI.buildChatTabSettings()
  --cecho("&amp;lt;magenta&amp;gt;\n4\n")
--  avalonUI.buildColorSettings()
  --cecho("&amp;lt;magenta&amp;gt;\n5\n")
--  avalonUI.buildAboutSettings()
  --cecho("&amp;lt;magenta&amp;gt;\n6\n")
  
  --avalonUI.settings[v]:hide()
  
  avalonUI.hideSettingsDialog()

end

function avalonUI.settings.createTabbedLayer()

  avalonUI.settingsHeader = Geyser.HBox:new({
    name = "avalonUI.settingsHeader",
    x = "1%", y = "2%",
    width = "98%",
    height = "8%",
  }, avalonUI.settingsDialogWindow)

  
  avalonUI.settingsFooter = avalonUI.settingsFooter or Geyser.Label:new({
    name = "avalonUI.settingsFooter",
    x = "1%", y = "10%",
    width = "98%",
    height = "90%",
    color = "red"
  }, avalonUI.settingsDialogWindow)
  --avalonUI.tabElement.Footer:setStyleSheet(avalonUI.CSS.tabElementFooterCSS:getCSS())
  avalonUI.settingsFooter:setStyleSheet(avalonUI.CSS.tabElementFooterCSS:getCSS())

end


function avalonUI.settings.addTabs()

  for k,v in pairs(avalonUI.settingsSettings.tabs) do

    -- Hier werden die einzelnen Tabs erzeugt. ...
    avalonUI.settings[v.."tab"] = avalonUI.settings[v.."tab"] or Geyser.Label:new({
      name = "avalonUI.settings."..v.."tab",
    })
    avalonUI.settingsHeader:add(avalonUI.settings[v.."tab"])
    avalonUI.settings[v.."tab"]:setFontSize(avalonUI.chatTabFontSize)	  
    avalonUI.settings[v.."tab"]:setStyleSheet(avalonUI.CSS.MenuTabCSS:getCSS())
    avalonUI.settings[v.."tab"]:echo("&lt;center&gt;"..v)
    avalonUI.settings[v.."tab"]:setCursor("PointingHand")
    avalonUI.settings[v.."tab"]:setClickCallback("avalonUI.settingsClick",v)
    
    -- ... Und zu jedem Tab noch ein Label fÃ¼r den Inhalt.  
    avalonUI.settings[v] = avalonUI.settings[v] or Geyser.Label:new({
      name = "avalonUI.settings."..v,
      x = 0, y = 0, width = "100%", height = "100%",
    }, avalonUI.settingsFooter)
    avalonUI.settings[v]:setStyleSheet(avalonUI.CSS.tabElementAtopCSS:getCSS())

    avalonUI.settings[v]:hide()

  end
  --avalonUI.settingsHeader:show() 
end


function avalonUI.toggleSettingsDialogVisibility()
  if avalonUI.settingsSettings.isSettingsDialogVisible then
    avalonUI.settingsSettings.isSettingsDialogVisible = false
    settingsDialogWindow:hide()
  else
    avalonUI.settingsSettings.isSettingsDialogVisible = true
    settingsDialogWindow:show()
  end
end

function avalonUI.showSettingsDialog()
  avalonUI.settingsSettings.isSettingsDialogVisible = true
  avalonUI.settingsDialogWindow:show()
end

function avalonUI.hideSettingsDialog()
  avalonUI.settingsSettings.isSettingsDialogVisible = false
  avalonUI.settingsDialogWindow:hide()
end

function avalonUI.settingsClick(tab)
--GUIModel.settingsElement.tabs
  avalonUI.settings[GUIModel.settingsElement.currentTab]:hide()
  --settingsSettings.current:hide()
  GUIModel.settingsElement.currentTab = tab
  --settingsSettings.current:show()
  avalonUI.settings[GUIModel.settingsElement.currentTab]:show()
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tabGeneral</name>
					<packageName></packageName>
					<script>--tabGeneral

function avalonUI.buildGeneralSettings()

--  titleLabel = Geyser.Label:new({
--    x=0, y=15, height=30, width="100%", 
--    color="red", 
--    message="&lt;b&gt;&lt;center&gt;Aenderungen werden erst nach Neustart von Mudlet uebernommen!&lt;/center&gt;&lt;/b&gt;"
--  }, avalonUI.settings["Diverses"])
--  titleLabel:setFontSize(12)
----  titleLabel:echo("&lt;b&gt;&lt;center&gt;Ãnderungen werden erst nach Neustart von Mudlet Ã¼bernommen!&lt;/center&gt;&lt;/b&gt;")
  
  contentGeneralSettings = Geyser.VBox:new({x="2%", y="2%", height=300, width="96%", color="white"}, avalonUI.settings["Diverses"])
  
  titleTimer = Geyser.Label:new({height="60%", width="100%", color="black", message="&lt;b&gt;Timer&lt;/b&gt;"}, contentGeneralSettings)-- avalonUI.settings["Diverses"])
  titleTimer:setFontSize(12)

  textTimer = Geyser.Label:new({height=10, width="100%", color="black", message = "Aenderungen werden erst durch einen Neustart von Mudlet wirksam."}, contentGeneralSettings)
  textTimer:setFontSize(11)

  choiceFancyTimer = Geyser.Label:new({height = 20, width = "100%", color = "black", message = [[&amp;#9678;]] .. "&amp;nbsp;&lt;i&gt;fancy RÃ¼ckschritts&lt;/i&gt;balken ODER"}, contentGeneralSettings)-- avalonUI.settings["Diverses"])
  choiceFancyTimer:setFontSize(11)
  choiceFancyTimer:setCursor("PointingHand")
  --choiceFancyTimer:setClickCallback("avalonUI.settingsClick",v)
  choiceUnfancyTimer = Geyser.Label:new({height = 20, width = "100%", color = "black", message = [[&amp;#9711;]] .. " langweiliger Fortschrittsbalken"}, contentGeneralSettings)-- avalonUI.settings["Diverses"])
  choiceUnfancyTimer:setFontSize(11)
  choiceUnfancyTimer:setCursor("PointingHand")
  --choiceUnfancyTimer:setClickCallback("avalonUI.settingsClick",v)

  spacer = Geyser.Label:new({height=10, width="100%", color="black"}, contentGeneralSettings)

  titleLockUI = Geyser.Label:new({height=40, width="100%", color="black", message="&lt;b&gt;OberflÃ¤che sperren&lt;/b&gt;"}, contentGeneralSettings)-- avalonUI.settings["Diverses"])
  titleLockUI:setFontSize(12)

  textLockUI = Geyser.Label:new({height=10, width="100%", color="black", message = "Aenderungen werden durch einen Neustart zurÃ¼ckgesetzt."}, contentGeneralSettings)
  textLockUI:setFontSize(11)

  checkboxLockUI = Geyser.Label:new({height = 20, width = "100%", color = "black", message = [[&amp;#9745;]] .. "&amp;nbsp;Seitenbereich der OberflÃ¤che sperren."}, contentGeneralSettings)-- avalonUI.settings["Diverses"])
  checkboxLockUI:setFontSize(11)
  checkboxLockUI:setCursor("PointingHand")
  --checkboxLockUI:setClickCallback("avalonUI.settingsClick",v)


--  generalLabel = Geyser.Label:new({x=0, y=400, height=100, width="100%", color="white"}, avalonUI.settings["Diverses"])
--  generalLabel:setFontSize(11)
--  local settings = ""
--  settings = settings .. "&amp;lt;center&amp;gt;&amp;lt;b&amp;gt;Ãnderungen machen einen Neustart von Mudlet notwendig!&amp;lt;/b&amp;gt;&amp;lt;/center&amp;gt;&amp;lt;br&amp;gt;"
--  --settings = settings .. [[&amp;amp;#9744;]] .. " leere Checkbox&amp;lt;br&amp;gt;"
--  --settings = settings .. [[&amp;amp;#9745;]] .. " Checkbox mit Haken&amp;lt;br&amp;gt;"
--  --settings = settings .. [[&amp;amp;#9746;]] .. " Checkbox mit Kreuz&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;"
--  settings = settings .. "&amp;lt;br&amp;gt;&amp;lt;b&amp;gt;Timer&amp;lt;/b&amp;gt;&amp;lt;br&amp;gt;"
--  settings = settings .. [[&amp;amp;#9678;]] .. " &amp;lt;i&amp;gt;fancy RÃ¼ckschritts&amp;lt;/i&amp;gt;balken ODER&amp;lt;br&amp;gt;"
--  settings = settings .. [[&amp;amp;#9711;]] .. " langweiliger Fortschrittsbalken&amp;lt;br&amp;gt;"
-- settings = settings .. "&amp;lt;br&amp;gt;&amp;lt;b&amp;gt;Diverses&amp;lt;/b&amp;gt;&amp;lt;br&amp;gt;"
--  settings = settings .. [[&amp;amp;#128306;]] .. "Lock/unlock UI" .. [[&amp;amp;#128307;]] .. "&amp;lt;br&amp;gt;"
--  --testLabel:echo([[&amp;amp;#9745;]] .. " Timer mit &amp;lt;i&amp;gt;fancy RÃ¼ckschritts&amp;lt;/i&amp;gt;balken")
--  generalLabel:echo(settings)
end

</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tabChats</name>
					<packageName></packageName>
					<script>--tabChats

-- avalonUI.settings.Diversescenter
-- avalonUI.settings.Chats-Tabscenter
-- avalonUI.settings.Farbencenter
-- avalonUI.settings.Ãber Avaletcenter
function avalonUI.buildChatTabSettings()

  avalonUI.chatTabContainer = avalonUI.chatTabContainer or Geyser.Container:new({
    name = "avalonUI.chatTabContainer",
    x = 0, y = 0,
    width = "100%",
    height = "100%",
  }, avalonUI.settings["Chats-Tabs"])
  -- der muss noch irgendwo hinzugefÃ¼gt werden

  avalonUI.chatTabHeader = Geyser.Label:new({
    name = "avalonUI.chatTabHeader",
    x = "0%", y = "0%", width = "100%", height = "10%",
  }, avalonUI.chatTabContainer)
  avalonUI.chatTabHeader:echo("ChatTab-Konfiguratione")

  avalonUI.chatTabContent = Geyser.Container:new({
    name = "avalonUI.chatTabContent",
    x = "0%", y = "10%", width = "100%", height = "90%",
  }, avalonUI.chatTabContainer)
  avalonUI.chatTabContentRowCheckbox = Geyser.VBox:new({
    name = "avalonUI.chatTabContentRowCheckbox",
    x = 0, y = 0, width = 20, height = "100%",
  }, avalonUI.chatTabContent)
  avalonUI.chatTabContentRowOneDown = Geyser.VBox:new({
    name = "avalonUI.chatTabContentRowOneDown",
    x = 25, y = 0, width = 20, height = "100%",
  }, avalonUI.chatTabContent)
  avalonUI.chatTabContentRowOneUp = Geyser.VBox:new({
    name = "avalonUI.chatTabContentRowOneUp",
    x = 45, y = 0, width = 20, height = "100%",
  }, avalonUI.chatTabContent)
  avalonUI.chatTabContentName = Geyser.VBox:new({
    name = "avalonUI.chatTabContentName",
    x = 70, y = 0, width = 450, height = "100%",
  }, avalonUI.chatTabContent)
  
  --Reden, Sagen, Laber, Neuling, Gruppe, Volk, Gilde, Zuenfte, Schwafel, Tod, Sammeltab (auÃerdem: Monster, Gebruell, Logout, Raetsel, Spiele, Statue)
  local test = test or {"Reden", "Sagen", "Laber", "Neuling", "Gruppe", "Volk", "Gilde", "Zuenfte", "Schwafel", "Tod", "Sammeltab", "Monster", "Gebruell", "Logout", "Raetsel", "Spiele", "Statue"}
--  local test = test or {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"}
  
  local fontsize = 12
  
  for k,v in pairs(test) do

    avalonUI["test"..k.."Checkbox"] = Geyser.Label:new({
      name = "avalonUI.test"..k.."Checkbox",
      x = 0, y = ((k-1)*10), width = 10, height = 10,
      fgColor="white",
      color="black",
      message=[[&amp;#9745;]]
    }, avalonUI.chatTabContentRowCheckbox)
    avalonUI["test"..k.."Checkbox"]:setFontSize(fontsize)
    avalonUI["test"..k.."Checkbox"]:setCursor("PointingHand")
    avalonUI["test"..k.."OneDown"] = Geyser.Label:new({
      name = "avalonUI.test"..k.."OneDown",
      x = 20, y = ((k-1)*10), width = 10, height = 10,
      fgColor="white",
      color="black",
      message=[[&lt;b&gt;&amp;#9661;&lt;/b&gt;]]
    }, avalonUI.chatTabContentRowOneDown)
    avalonUI["test"..k.."OneDown"]:setFontSize(fontsize)
    avalonUI["test"..k.."OneDown"]:setCursor("PointingHand")
    avalonUI["test"..k.."OneUp"] = Geyser.Label:new({
      name = "avalonUI.test"..k.."OneUp",
      x = 40, y = ((k-1)*10), width = 10, height = 10,
      fgColor="white",
      color="black",
      message=[[&lt;b&gt;&amp;#9651;&lt;/b&gt;]]
    }, avalonUI.chatTabContentRowOneUp)
    avalonUI["test"..k.."OneUp"]:setFontSize(fontsize)
    avalonUI["test"..k.."OneUp"]:setCursor("PointingHand")
    avalonUI["test"..k.."Label"] = Geyser.Label:new({
      name = "avalonUI.test"..k.."Label",
      x = 60, y = ((k-1)*10), width = "90%", height = 10,
      fgColor="white",
      color="black",
      message="&amp;nbsp;Reden &amp;#127760;"
    }, avalonUI.chatTabContentName)
    avalonUI["test"..k.."Label"]:setFontSize(fontsize)
    --avalonUI["test"..k.."Label"]:setCursor("PointingHand")
  
  end
  
  avalonUI.chatTabFooter = Geyser.Label:new({
    name = "avalonUI.chatTabFooter",
    x = "0%", y = "90%",
    width = "100%",
    height = "10%",
  }, avalonUI.chatTabContainer)
  avalonUI.chatTabFooter:echo("Ãnderungen werden erst nach Neustart von Mudlet Ã¼bernommen!")

end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tabColor</name>
					<packageName></packageName>
					<script>--tabColor</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tabAbout</name>
					<packageName></packageName>
					<script>--tabAbout</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>ATCP</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>atcp</name>
				<packageName></packageName>
				<script>----------------------------------------
-- ATCP-Handling
-- In diesem Script findet der Umgang mit den ATCP-Daten statt,
-- die Avalon sendet (und empfÃ¤ngt) 
-- Eine Beschreibung der ATCP-Schnittstelle von Avalon findet sich im Wiki:
-- https://avalon.mud.de/wiki/avalon:atcp
--
-- Anscheinend wird in einer Tabelle mit dem Namen "atcp", wenn sie existiert(?),
-- alles gespeichert, was per atcp reinkommt.
--atcp = {}


----------------------------------------
-- onATCPEvent
----------------------------------------

function onATCPEvent(event, arg)
	cecho("&lt;magenta&gt;Wer dies lesen kann, hat einen Fehler gefunden! (atcp.lua, funct. onATCPEvent\n")
end

----------------------------------------------------------------------------------------
-- Misc
----------------------------------------------------------------------------------------

-- event == "AvalonGrafikVermeiden"
function onATCPEventAvalonGrafikVermeiden(event, arg)
	debugc("AvalonGrafikVermeiden = " .. tostring(arg) .. "\n")

--	channel = "ATCP"
--	message = "AvalonGrafikVermeiden = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonGrafikVermeiden", "onATCPEventAvalonGrafikVermeiden")



-- event == "AuthRequest"
function onATCPEventAuthRequest(event, arg)
	debugc("AuthRequest = " .. tostring(arg) .. "\n")
  --cecho("\n&lt;magenta&gt;AuthRequest: " .. tostring(arg) .. "\n")
--	channel = "ATCP"
--	message = "AuthRequest = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AuthRequest", "onATCPEventAuthRequest")



----------------------------------------------------------------------------------------
--  Charakter-Daten/Spielstand
----------------------------------------------------------------------------------------

-- event == "AvalonName"
function onATCPEventAvalonName(event, arg)
  debugc("&lt;magenta&gt;AvalonName per ATCP empfangen!\n")
  debugc("&lt;magenta&gt;AvalonName: " .. arg .."\n")
  if player.name ~= arg then
    --cecho("&lt;magenta&gt;\nplayer.name ~= arg\n")
    if string.len(player.name) == 0 then
      avalonUI.initPlayer(arg)
    end
    player.name = arg
    raiseEvent("RefreshInfobox", arg)
  end
end
registerAnonymousEventHandler("AvalonName", "onATCPEventAvalonName")



-- event == "AvalonVollName"
function onATCPEventAvalonVollName(event, arg)
	debugc("&lt;magenta&gt;AvalonVollName per ATCP empfangen!\n")
	if player.vollername ~= arg then
		player.vollername = arg
		raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonVollName", "onATCPEventAvalonVollName")



-- event == "AvalonPortfolio"
function onATCPEventAvalonPortfolio(event, arg)
	debugc("&lt;magenta&gt;AvalonPortfolio per ATCP empfangen!\n")
	if player.portfolio ~= arg then 
		player.portfolio = arg
		raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonPortfolio", "onATCPEventAvalonPortfolio")



-- event == "AvalonGilde"
function onATCPEventAvalonGilde(event, arg)
	debugc("&lt;magenta&gt;AvalonGilde per ATCP empfangen!\n")
	if player.gilde ~= arg then
		player.gilde = arg
		raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonGilde", "onATCPEventAvalonGilde")


-- event == "AvalonZuenfte"
function onATCPEventAvalonZuenfte(event, arg)
	debugc("&lt;magenta&gt;AvalonZuenfte per ATCP empfangen!\n")
	if player.zuenfte ~= arg then 
		player.zuenfte = arg
		raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonZuenfte", "onATCPEventAvalonZuenfte")



-- event == "AvalonAlter"
function onATCPEventAvalonAlter(event, arg)
	debugc("&lt;magenta&gt;AvalonAlter per ATCP empfangen: " .. arg .. "\n")
	if player.alter ~= arg then 
		player.alter = arg
		raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonAlter", "onATCPEventAvalonAlter")



-- event == "AvalonLevel"
function onATCPEventAvalonLevel(event, arg)
	debugc("&lt;magenta&gt;AvalonLevel per ATCP empfangen!\n")
	if player.level ~= arg then
		player.level = arg
		raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonLevel", "onATCPEventAvalonLevel")



-- event == "AvalonEP"
function onATCPEventAvalonEP(event, arg)
	debugc("&lt;magenta&gt;AvalonEP per ATCP empfangen!\n")
	if player.ep ~= arg then
		player.ep = arg
    --player.sessionEP = tonumber(arg) - tonumber(player.sessionEP)
		raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonEP", "onATCPEventAvalonEP")



-- event == "AvalonGesinnung"
function onATCPEventAvalonGesinnung(event, arg)
	debugc("&lt;magenta&gt;AvalonGesinnung per ATCP empfangen!\n")
	if player.gesinnung ~= arg then 
		player.gesinnung = arg
		raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonGesinnung", "onATCPEventAvalonGesinnung")



-- event == "AvalonHunger"
-- Die Texte fÃ¼r Hunger und fÃ¼r Durst hatten am Ende ein Leerzeichen zu viel.
-- Aber ein Trim kann nie schaden.
function onATCPEventAvalonHunger(event, arg)
	debugc("&lt;magenta&gt;AvalonHunger per ATCP empfangen!\n")
	arg = string.trim(arg)
	if player.hunger ~= arg then 
		player.hunger = arg
		raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonHunger", "onATCPEventAvalonHunger")



-- event == "AvalonDurst"
-- Die Texte fÃ¼r Hunger und fÃ¼r Durst haben am Ende ein Leerzeichen zu viel.
function onATCPEventAvalonDurst(event, arg)
	debugc("&lt;magenta&gt;AvalonDurst per ATCP empfangen!\n")
	arg = string.trim(arg)
	if player.durst ~= arg then
		player.durst = arg
		raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonDurst", "onATCPEventAvalonDurst")


-- event == "AvalonHoehe"
function onATCPEventAvalonHoehe(event, arg)
	debugc("&lt;magenta&gt;AvalonHoehe per ATCP empfangen!\n")
	arg = string.trim(arg)
	if player.hoehe ~= arg then
		player.hoehe = arg
		-- raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonHoehe", "onATCPEventAvalonHoehe")



-- event == "AvalonFlucht"
function onATCPEventAvalonFlucht(event, arg)
	debugc("&lt;magenta&gt;AvalonFlucht per ATCP empfangen!\n")
	arg = string.trim(arg)
	if player.flucht ~= arg then
		player.flucht = arg
		-- raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonFlucht", "onATCPEventAvalonFlucht")



-- event == "AvalonSchutz"
function onATCPEventAvalonSchutz(event, arg)
	debugc("&lt;magenta&gt;AvalonSchutz per ATCP empfangen!\n")
	arg = string.trim(arg)
	if player.schutz ~= arg then
		player.schutz = arg
    -- Wenn ein Schutzzauber hinzu kommt, gibt es eine ATCP-Message. Wenn ein
    -- Schutz wegfÃ¤llt, gibt es aber keine. Um die Anzeige (und was sonst noch 
    -- so davon abhÃ¤ngt...) zu aktualisieren, werden hier deshalb bei jeder
    -- VerÃ¤nderung ... Das ist doch quatsch. Anders lÃ¶sen. 
    --sendATCP("ava_req_update")
		-- raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonSchutz", "onATCPEventAvalonSchutz")



-- event == "AvalonGruppe"
function onATCPEventAvalonGruppe(event, arg)
	debugc("&lt;magenta&gt;AvalonGruppe per ATCP empfangen!\n")
	arg = string.trim(arg)
	if player.gruppenname ~= arg then
		player.gruppenname = arg
		-- raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonGruppe", "onATCPEventAvalonGruppe")



-- event == "AvalonZaubern"
function onATCPEventAvalonZaubern(event, arg)
	debugc("&lt;magenta&gt;AvalonZaubern per ATCP empfangen!\n")
	arg = string.trim(arg)
	if player.zaubern ~= arg then
		player.zaubern = arg
		-- raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonZaubern", "onATCPEventAvalonZaubern")



-- event == "AvalonKampf"
function onATCPEventAvalonKampf(event, arg)
	debugc("&lt;magenta&gt;AvalonKampf per ATCP empfangen!\n")
	--cecho("\n&lt;magenta&gt;AvalonKampf: "..arg.."\n")
	arg = string.trim(arg)
	if player.kampf ~= arg then
		player.kampf = arg
		-- raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonKampf", "onATCPEventAvalonKampf")



-- event == "AvalonAngegriffen"
function onATCPEventAvalonAngegriffen(event, arg)
	debugc("&lt;magenta&gt;AvalonAngegriffen per ATCP empfangen!\n")
	arg = string.trim(arg)
	if player.angegriffen ~= arg then
		player.angegriffen = arg
		-- raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonAngegriffen", "onATCPEventAvalonAngegriffen")



-- event == "AvalonGetoetet"
function onATCPEventAvalonGetoetet(event, arg)
	debugc("&lt;magenta&gt;AvalonGetoetet per ATCP empfangen!\n")
	arg = string.trim(arg)
	if player.getoetet ~= arg then
		player.getoetet = arg
		-- raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonGetoetet", "onATCPEventAvalonGetoetet")



-- event == "AvalonGruppeGetoetet"
function onATCPEventAvalonGruppeGetoetet(event, arg)
	debugc("&lt;magenta&gt;AvalonGruppeGetoetet per ATCP empfangen!\n")
	arg = string.trim(arg)
	if player.gruppeGetoetet ~= arg then
		player.gruppeGetoetet = arg
		-- raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonGruppeGetoetet", "onATCPEventAvalonGruppeGetoetet")



-- event == "AvalonAllyGetoetet"
function onATCPEventAvalonAllyGetoetet(event, arg)
	debugc("&lt;magenta&gt;AvalonAllyGetoetet per ATCP empfangen!\n")
	arg = string.trim(arg)
	if player.allyGetoetet ~= arg then
		player.allyGetoetet = arg
		-- raiseEvent("RefreshInfobox", arg)
	end
end
registerAnonymousEventHandler("AvalonAllyGetoetet", "onATCPEventAvalonAllyGetoetet")



----------------------------------------------------------------------------------------
--  TP, TPMAX, AP, APMAX, ZP, ZPMAX, MP, MPMAX
----------------------------------------------------------------------------------------

-- event == "AvalonTP"
function onATCPEventAvalonTP(event, arg)
	if player.stats.tp ~= tonumber(arg) then 
		player.stats.tp = tonumber(arg)
		raiseEvent("RefreshHealthBar", {player.stats.tp, player.stats.tp_max})
	end
end
registerAnonymousEventHandler("AvalonTP", "onATCPEventAvalonTP")



-- event == "AvalonMAXTP"
function onATCPEventAvalonMAXT(event, arg)
	if player.stats.tp_max ~= tonumber(arg) then
		player.stats.tp_max = tonumber(arg)
		raiseEvent("RefreshHealthBar", {player.stats.tp, player.stats.tp_max})
	end
end
registerAnonymousEventHandler("AvalonMAXTP", "onATCPEventAvalonMAXT")



-- event == "AvalonAP"
function onATCPEventAvalonAP(event, arg)
	if player.stats.ap ~= tonumber(arg) then 
		player.stats.ap = tonumber(arg)
		raiseEvent("RefreshEnduranceBar", {player.stats.ap, player.stats.ap_max})
	end
end
registerAnonymousEventHandler("AvalonAP", "onATCPEventAvalonAP")



-- event == "AvalonMAXAP"
function onATCPEventAvalonMAXAP(event, arg)
	if player.stats.ap_max ~= tonumber(arg) then 
		player.stats.ap_max = tonumber(arg)
		raiseEvent("RefreshEnduranceBar", {player.stats.ap, player.stats.ap_max})
	end
end
registerAnonymousEventHandler("AvalonMAXAP", "onATCPEventAvalonMAXAP")



-- event == "AvalonSP"
function onATCPEventAvalonSP(event, arg)
	if player.stats.zp ~= tonumber(arg) then 
		player.stats.zp = tonumber(arg)
		raiseEvent("RefreshSpellpointsBar", {player.stats.zp, player.stats.zp_max})
	end
end
registerAnonymousEventHandler("AvalonSP", "onATCPEventAvalonSP")



-- event == "AvalonMAXSP"
function onATCPEventAvalonMAXSP(event, arg)
	if player.stats.zp_max ~= tonumber(arg) then 
		player.stats.zp_max = tonumber(arg)
		raiseEvent("RefreshSpellpointsBar", {player.stats.zp, player.stats.zp_max})
	end
end
registerAnonymousEventHandler("AvalonMAXSP", "onATCPEventAvalonMAXSP")



-- event == "AvalonMP"
function onATCPEventAvalonMP(event, arg)
	if player.stats.mp ~= tonumber(arg) then
		player.stats.mp = tonumber(arg)
		raiseEvent("RefreshManaBar", {player.stats.mp, player.stats.mp_max})
	end
end
registerAnonymousEventHandler("AvalonMP", "onATCPEventAvalonMP")



-- event == "AvalonMAXMP"
function onATCPEventAvalonMAXMP(event, arg)
	if player.stats.mp_max ~= tonumber(arg) then
		player.stats.mp_max = tonumber(arg)
		raiseEvent("RefreshManaBar", {player.stats.mp, player.stats.mp_max})
	end
end
registerAnonymousEventHandler("AvalonMAXMP", "onATCPEventAvalonMAXMP")



----------------------------------------------------------------------------------------
--  Kommunikation
--
-- Meldungen Ã¼ber channel:
-- Avalon.Channel [kanalname] [Nachricht]
----------------------------------------------------------------------------------------

-- event == "AvalonChannel"
function onATCPEventAvalonChannel(event, arg)
  debugc("AvalonChannel = " .. arg .. "\n")
  
  -- Zu Beginn der ATCP-Nachricht steht der Kanal, Ã¼ber den sie geschickt wurde.
  -- Wenn ein Mensch per "vr" zu den Menschen spricht, dann steht da: "mensch ..."
  -- Dieser Kanal wird hier extrahiert. Gleichzeitig wird der erste Buchstabe in
  -- einen GroÃbuchstaben geÃ¤ndert.
  channel = string.title(string.match(arg, "^(%w+)"))
  -- Die eigentliche Nachricht ist der Teil nach dem ersten Leerzeichen.
  message = arg:gsub("^.-%s", "", 1)
  -- Die Nachricht kann Steuercode enthalten, beispielsweise fÃ¼r farbigen Text.
  -- Der wird hier rausgefiltert.
  --message = clearMessage(message)
  
  -- Die Channelnamen hÃ¤ngen davon ab, in welcher Gilde, Zunft, in welchem Volk etc. der Char ist.
  -- Auf der OberflÃ¤che sollen die Kanalnamen aber "Volk" und "Gilde" etc. heiÃen. ZÃ¼nfte sollen
  -- auÃerdem zusammengefasst werden, das wird ja sonst viel zu viele Tabs. 
  -- Um an die "echten" Channelnamen zu kommen, plÃ¼ndere ich mal das Skript von Twrx. Sollte da
  -- nicht alles richtig ankommen, melden sich hoffentlich die Spieler.
  if channel == "Hyraskrieger" then channel = "Gilde" end
  if channel == "Golemkultisten" then channel = "Gilde" end
  if channel == "Daemonenkrieger" then channel = "Gilde" end
  if channel == "Runenschmied" then channel = "Gilde" end
  if channel == "Barden" then channel = "Gilde" end
  if channel == "Kleriker" then channel = "Gilde" end
  if channel == "Druiden" then channel = "Gilde" end
  if channel == "Nekromanten" then channel = "Gilde" end
  if channel == "Magier" then channel = "Gilde" end

  if channel == "Schneider" then channel = "Zuenfte" end
  if channel == "Orkjaeger" then channel = "Zuenfte" end
  if channel == "Koeche" then channel = "Zuenfte" end
  
  if channel == "Mensch" then channel = "Volk" end
  if channel == "Hobbit" then channel = "Volk" end
  if channel == "Elf" then channel = "Volk" end
  if channel == "Dunkelelf" then channel = "Volk" end
  if channel == "Zwerg" then channel = "Volk" end
  if channel == "Chaoszentaur" then channel = "Volk" end
  if channel == "Amphib" then channel = "Volk" end
  
  -- SchlieÃlich wird die Nachricht in das entsprechende Logfile geschrieben.
  -- Diese Dateien liegen im "log"-Verzeichnis im jeweiligen Mudlet-Profil.
  -- Und sie sind nach dem Kanalnamen benannt. ("Sagen.txt")
  -- TODO: Charakternamen hinzufÃ¼gen, damit ein Profil auch mit unterschiedlichen
  --       Charakteren gespielt werden kann.
--  Logger:Log(channel, message, {"timestamp", split = 4000})
  avalonUI.processMessage(channel, message)
  -- AnschlieÃend muss evtl. die Anzeige auf der OberflÃ¤che aktualisiert werden.
  -- DafÃ¼r sorgt dieses Event:
--  raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonChannel", "onATCPEventAvalonChannel")



-- event == "AvalonComm" (Sagen)
function onATCPEventAvalonComm(event, arg)
  debugc("AvalonComm = " .. arg .. "\n")
  -- Der Kanalname steht auch am Anfang der Nachricht, aber in Kapitalien.
  -- Ich setz den einfach mal von Hand:  
  channel = "Sagen"
  -- Die eigentliche Nachricht ist der Teil hinter dem ersten Leerzeichen,
  -- alles vorher wird hier abgeschnitten.
  message = arg:gsub("^.-%s", "", 1)
  -- Die Nachricht wird von Steuercode (Farbe) befreit:
  --message = clearMessage(message)
  -- Die Nachricht wird in das entsprechende Logfile geschrieben:
  --Logger:Log(channel, message, {"timestamp", split = 4000})
  avalonUI.processMessage(channel, message)
  -- Die Anzeige auf der OberflÃ¤che wird ggf. aktualisiert:
  --raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonComm", "onATCPEventAvalonComm")



-- event == "AvalonRComm" (Reden)
function onATCPEventAvalonRComm(event, arg)
	debugc("AvalonRComm = " .. arg .. "\n")
	channel = "Reden"
	message = arg:gsub("^.-%s", "", 1)
	--message = clearMessage(message)
	--Logger:Log(channel, message, {"timestamp", split = 4000})
  avalonUI.processMessage(channel, message)
	--raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonRComm", "onATCPEventAvalonRComm")



-- event == "AvalonSoul" (Sagen)
function onATCPEventAvalonSoul(event, arg)
	debugc("AvalonSoul = " .. arg .. "\n")
	channel = "Sagen"
	message = arg:gsub("^.-%s", "", 1)
	--message = clearMessage(message)
	--Logger:Log(channel, message, {"timestamp", split = 4000})
  avalonUI.processMessage(channel, message)
	--raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonSoul", "onATCPEventAvalonSoul")



-- event == "AvalonRSoul" (Reden)
function onATCPEventAvalonRSoul(event, arg)
  debugc("AvalonRSoul = " .. arg .. "\n")
  channel = "Reden"
  -- Kanalnamen aus der Nachricht entfernen:
  message = arg:gsub("^.-%s", "", 1)
  -- Formatierungen entfernen:
  --message = clearMessage(message)
  -- Nachricht ins logfile schreiben:
  --Logger:Log(channel, message, {"timestamp", split = 4000})
  avalonUI.processMessage(channel, message)
  -- evtl. Anzeige auf der OberflÃ¤che aktualisieren:
  --raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonRSoul", "onATCPEventAvalonRSoul")



----------------------------------------------------------------------------------------
--  ??? Item-Handling
----------------------------------------------------------------------------------------

-- event == "AvalonInventarRein"
function onATCPEventAvalonInventarRein(event, arg)
	debugc("AvalonInventarRein = " .. arg .. "\n")
	
	if player.inventarRein ~= arg then
		player.inventarRein = arg
--		raiseEvent("RefreshInfobox", arg)
	end
--	channel = "ATCP"
--	message = "AvalonInventarRein = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonInventarRein", "onATCPEventAvalonInventarRein")



-- event == "AvalonInventarRaus"
function onATCPEventAvalonInventarRaus(event, arg)
	debugc("AvalonInventarRaus = " .. arg .. "\n")
	
	if player.inventarRaus ~= arg then
		player.inventarRaus = arg
--		raiseEvent("RefreshInfobox", arg)
	end
--	channel = "ATCP"
--	message = "AvalonInventarRaus = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonInventarRaus", "onATCPEventAvalonInventarRaus")



-- event == "AvalonBehaelterRein"
function onATCPEventAvalonBehaelterRein(event, arg)
	debugc("AvalonBehaelterRein = " .. arg .. "\n")
	
	if player.behaelterRein ~= arg then
		player.behaelterRein = arg
--		raiseEvent("RefreshInfobox", arg)
	end
--	channel = "ATCP"
--	message = "AvalonBehaelterRein = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonBehaelterRein", "onATCPEventAvalonBehaelterRein")



-- event == "AvalonBehaelterRaus"
function onATCPEventAvalonBehaelterRaus(event, arg)
	debugc("AvalonBehaelterRaus = " .. arg .. "\n")
	
	if player.behaelterRaus ~= arg then
		player.behaelterRaus = arg
--		raiseEvent("RefreshInfobox", arg)
	end
--	channel = "ATCP"
--	message = "AvalonBehaelterRaus = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonBehaelterRaus", "onATCPEventAvalonBehaelterRaus")



-- event == "AvalonGefuehrt"
function onATCPEventAvalonGefuehrt(event, arg)
	debugc("AvalonAvalonGefuehrt = " .. arg .. "\n")
	
	if player.gefuehrt ~= arg then
		player.gefuehrt = arg
--		raiseEvent("RefreshInfobox", arg)
	end
--	channel = "ATCP"
--	message = "AvalonGefuehrt = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonGefuehrt", "onATCPEventAvalonGefuehrt")



-- event == "AvalonGesenkt"
function onATCPEventAvalonGesenkt(event, arg)
	debugc("AvalonGesenkt = " .. arg .. "\n")
	
	if player.gesenkt ~= arg then
		player.gesenkt = arg
--		raiseEvent("RefreshInfobox", arg)
	end
--	channel = "ATCP"
--	message = "AvalonGesenkt = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonGesenkt", "onATCPEventAvalonGesenkt")



-- event == "AvalonAngezogen"
function onATCPEventAvalonAngezogen(event, arg)
	debugc("AvalonAvalonAngezogen = " .. arg .. "\n")
	
	if player.angezogen ~= arg then
		player.angezogen = arg
--		raiseEvent("RefreshInfobox", arg)
	end
--	channel = "ATCP"
--	message = "AvalonAngezogen = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonAngezogen", "onATCPEventAvalonAngezogen")



-- event == "AvalonAusgezogen"
function onATCPEventAvalonAusgezogen(event, arg)
	debugc("AvalonGesenkt = " .. arg .. "\n")
	
	if player.ausgezogen ~= arg then
		player.ausgezogen = arg
--		raiseEvent("RefreshInfobox", arg)
	end
--	channel = "ATCP"
--	message = "AvalonAusgezogen = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonAusgezogen", "onATCPEventAvalonAusgezogen")



--------------------------------------------------------------------
-- Map/Mapper
--------------------------------------------------------------------

-- event == "AvalonDunkel"
function onATCPEventAvalonDunkel(event, arg)
  debugc("AvalonDunkel = " .. tostring(arg) .. "\n")
  --cecho("&lt;magenta&gt;AvalonDunkel = " .. tostring(arg) .. "\n")

  if (player.istDunkel ~= tostring(arg)) then
    player.istDunkel = tostring(arg)
    raiseEvent("RefreshInfobox", arg)
  end
--	-- mapper.dunkel gibt es nicht, bei bedarf anlegen	
--	if tmapper.dunkel ~= arg then
--		tmapper.dunkel = arg
--	end
--	channel = "ATCP"
--	message = "AvalonDunkel = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
  --raiseEvent("RefreshInfobox", arg)
end
registerAnonymousEventHandler("AvalonDunkel", "onATCPEventAvalonDunkel")



-- event == "AvalonRoomID"
function onATCPEventAvalonRoomID(event, arg)
  debugc("AvalonRoomID = " .. tostring(arg) .. "\n")
  --cecho("\n&lt;magenta&gt;"..tostring(arg).."\n")

  player.avalonRoomID = ""
  --player.avalonRoomID = tostring(arg)
  str = string.gsub(arg, "^%S*%s+(.+)", "%1", 1)
  player.avalonRoomID = str
  str = string.gsub(arg, "^raum/(%S*)%s+.+", "%1", 1)
  player.avalonRoomHash = str
  
  --cecho("&lt;magenta&gt;avalonRoomHash: " .. str .. "\n")

--	-- tMapper.roomID gibt es nicht, bei bedarf anlegen	
--	if tMapper.roomID ~= arg then
--		tMapper.roomID = arg
--	end
--	channel = "ATCP"
--	message = "AvalonRoomID = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
  raiseEvent("RefreshInfobox", arg)
end
registerAnonymousEventHandler("AvalonRoomID", "onATCPEventAvalonRoomID")



-- event == "AvalonRoomBrief"
function onATCPEventAvalonRoomBrief(event, arg)
	debugc("AvalonRoomBrief = " .. tostring(arg) .. "\n")

--	-- tMapper.roomBrief gibt es nicht, bei bedarf anlegen	
--	if tMapper.roomBrief ~= arg then
--		tMapper.roomBrief = arg
--	end
--	channel = "ATCP"
--	message = "AvalonRoomBrief = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonRoomBrief", "onATCPEventAvalonRoomBrief")



-- event == "AvalonArea"
function onATCPEventAvalonArea(event, arg)
	debugc("AvalonArea = " .. tostring(arg) .. "\n")

--	-- tMapper.area gibt es nicht, bei bedarf anlegen	
--	if tMapper.area ~= arg then
--		tMapper.area = arg
--	end
--	channel = "ATCP"
--	message = "AvalonArea = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonArea", "onATCPEventAvalonArea")



-- event == "AvalonInv"
function onATCPEventAvalonInv(event, arg)
	debugc("AvalonInv = " .. tostring(arg) .. "\n")

--	-- tMapper.inv gibt es nicht, bei bedarf anlegen	
--	if tMapper.inv ~= arg then
--		tMapper.inv = arg
--	end
--	channel = "ATCP"
--	message = "AvalonInv = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonInv", "onATCPEventAvalonInv")



-- event == "AvalonSite"
function onATCPEventAvalonSite(event, arg)
	debugc("AvalonSite = " .. tostring(arg) .. "\n")

--	-- tMapper.site gibt es nicht, bei bedarf anlegen	
--	if tMapper.site ~= arg then
--		tMapper.site = arg
--	end
--	channel = "ATCP"
--	message = "AvalonSite = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonSite", "onATCPEventAvalonSite")



-- event == "AvalonExits"
function onATCPEventAvalonExits(event, arg)
	debugc("AvalonExits = " .. tostring(arg) .. "\n")

--	-- tMapper.exits gibt es nicht, bei bedarf anlegen	
--	if tMapper.exits ~= arg then
--		tMapper.exits = arg
--	end
--	channel = "ATCP"
--	message = "AvalonExits = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonExits", "onATCPEventAvalonExits")



-- event == "AvalonAvalonWeg"
function onATCPEventAvalonAvalonWeg(event, arg)
	debugc("AvalonAvalonWeg = " .. tostring(arg) .. "\n")

--	-- tMapper.avalonWeg gibt es nicht, bei bedarf anlegen	
--	if tMapper.avalonWeg ~= arg then
--		tMapper.avalonWeg = arg
--	end
--	channel = "ATCP"
--	message = "AvalonAvalonWeg = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonAvalonWeg", "onATCPEventAvalonAvalonWeg")



-- event == "AvalonAvalonIcon16"
function onATCPEventAvalonAvalonIcon16(event, arg)
	debugc("AvalonAvalonWeg = " .. tostring(arg) .. "\n")

--	-- tMapper.avalonIcon16 gibt es nicht, bei bedarf anlegen	
--	if tMapper.avalonIcon16 ~= arg then
--		tMapper.avalonIcon16 = arg
--	end
--	channel = "ATCP"
--	message = "AvalonAvalonIcon16 = " .. arg .. "\n"
--	Logger:Log(channel, message, {"timestamp"})
--	raiseEvent("RefreshTabElement", channel)
end
registerAnonymousEventHandler("AvalonAvalonIcon16", "onATCPEventAvalonAvalonIcon16")



--------------------------------------------------------------------
-- onKill wird durch einen kill ausgelÃ¶st -- ab hier nicht funktionsfÃ¤hig
--------------------------------------------------------------------

function onKillEvent(event,name,file)
	--sendATCP("ava_req_inv", "hier")
	if tMetzel and tMetzel.sMode ~= nil then fMetzelGetoetet() end 
	--sendAll("r","t bewohner")
end
--registerAnonymousEventHandler("KillEvent", "onKillEvent")

-- Script: AvalonAllyGetoetet
function AvalonAllyGetoetet(event,arg)
	onATCP (event,arg)
	raiseEvent("onKillEvent",arg)
end
--registerAnonymousEventHandler("AvalonAllyGetoetet", "AvalonAllyGetoetet")

-- Script: AvalonAP
function AvalonAP(event,arg)
	tPlayer.diffap = tonumber(arg) - tonumber(tPlayer.ap)
	onATCP (event,arg)
end
--registerAnonymousEventHandler("AvalonAP", "AvalonAP")


-- Script: AvalonBehaelterRaus
function AvalonBehaelterRaus(event,arg)
	onATCP (event,arg)
	--sendATCP("ava_req_inv", "mich")
end
--registerAnonymousEventHandler("AvalonBehaelterRaus", "AvalonBehaelterRaus")

-- Script: AvalonBehaelterRein
function AvalonBehaelterRein(event,arg)
	onATCP (event,arg)
	--sendATCP("ava_req_inv", "mich")
end
--registerAnonymousEventHandler("AvalonBehaelterRein", "AvalonBehaelterRein")
</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage>
		<KeyGroup isActive="yes" isFolder="yes">
			<name>Keypadfunktionen</name>
			<packageName></packageName>
			<script></script>
			<command></command>
			<keyCode>-1</keyCode>
			<keyModifier>-1</keyModifier>
			<Key isActive="yes" isFolder="no">
				<name>9 - nordosten</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",9)</script>
				<command></command>
				<keyCode>57</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>8 - norden</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",8)</script>
				<command></command>
				<keyCode>56</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>7 - nordwesten</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",7)</script>
				<command></command>
				<keyCode>55</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>6 - osten</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",6)</script>
				<command></command>
				<keyCode>54</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>5 - schau</name>
				<packageName></packageName>
				<script>sendATCP("ava_req_iid", "hier")
raiseEvent("keyPadEvent",5)
				</script>
				<command></command>
				<keyCode>53</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>4 - westen</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",4)</script>
				<command></command>
				<keyCode>52</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>3 - suedosten</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",3)</script>
				<command></command>
				<keyCode>51</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>2 - sueden</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",2)</script>
				<command></command>
				<keyCode>50</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>1 - suedwesten</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",1)</script>
				<command></command>
				<keyCode>49</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>- - hoch</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",10)</script>
				<command></command>
				<keyCode>45</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>+ - runter</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",11)</script>
				<command></command>
				<keyCode>43</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>/ - rein</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",12)</script>
				<command></command>
				<keyCode>47</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>* - raus</name>
				<packageName></packageName>
				<script>raiseEvent("keyPadEvent",13)</script>
				<command></command>
				<keyCode>42</keyCode>
				<keyModifier>536870912</keyModifier>
			</Key>
		</KeyGroup>
		<KeyGroup isActive="yes" isFolder="yes">
			<name>Fernrohr</name>
			<packageName></packageName>
			<script></script>
			<command></command>
			<keyCode>-1</keyCode>
			<keyModifier>-1</keyModifier>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-1</name>
				<packageName></packageName>
				<script></script>
				<command>spaehe sw</command>
				<keyCode>49</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-2</name>
				<packageName></packageName>
				<script></script>
				<command>spaehe s</command>
				<keyCode>50</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-3</name>
				<packageName></packageName>
				<script></script>
				<command>spaehe so</command>
				<keyCode>51</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-4</name>
				<packageName></packageName>
				<script></script>
				<command>spaehe w</command>
				<keyCode>52</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-5</name>
				<packageName></packageName>
				<script></script>
				<command>schau</command>
				<keyCode>53</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-6</name>
				<packageName></packageName>
				<script></script>
				<command>spaehe o</command>
				<keyCode>54</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-7</name>
				<packageName></packageName>
				<script></script>
				<command>spaehe nw</command>
				<keyCode>55</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-8</name>
				<packageName></packageName>
				<script></script>
				<command>spaehe n</command>
				<keyCode>56</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
			<Key isActive="yes" isFolder="no">
				<name>Ctrl+Keypad-9</name>
				<packageName></packageName>
				<script></script>
				<command>spaehe no</command>
				<keyCode>57</keyCode>
				<keyModifier>603979776</keyModifier>
			</Key>
		</KeyGroup>
	</KeyPackage>
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
